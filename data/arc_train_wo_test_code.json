[
{"name": "ed36ccf7.json", "data": {"train": [{"input": [[9, 0, 0], [9, 9, 9], [9, 9, 9]], "output": [[0, 9, 9], [0, 9, 9], [9, 9, 9]]}, {"input": [[6, 6, 6], [0, 0, 0], [6, 6, 0]], "output": [[6, 0, 0], [6, 0, 6], [6, 0, 6]]}, {"input": [[0, 0, 9], [0, 0, 9], [9, 9, 9]], "output": [[9, 9, 9], [0, 0, 9], [0, 0, 9]]}, {"input": [[2, 0, 2], [0, 0, 2], [0, 2, 2]], "output": [[2, 2, 2], [0, 0, 2], [2, 0, 0]]}], "test": [{"input": [[0, 0, 0], [5, 0, 0], [0, 5, 5]], "output": [[0, 0, 5], [0, 0, 5], [0, 5, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef rotate_90_counterclockwise(input_grid: np.ndarray) -> np.ndarray:\n    return np.rot90(input_grid, k=1)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = rotate_90_counterclockwise(input_grid)\n    return output_grid"},
{"name": "fcc82909.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 9, 9, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 8, 0, 0, 0, 0, 0, 0], [0, 0, 9, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 8, 0, 0, 0, 0, 0, 0], [0, 0, 9, 4, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 2, 1, 0, 0], [0, 0, 3, 3, 0, 0, 1, 2, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 4, 0, 0, 9, 8, 0, 0], [0, 0, 6, 7, 0, 0, 8, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 4, 0, 0, 9, 8, 0, 0], [0, 0, 6, 7, 0, 0, 8, 9, 0, 0], [0, 0, 3, 3, 0, 0, 3, 3, 0, 0], [0, 0, 3, 3, 0, 0, 3, 3, 0, 0], [0, 0, 3, 3, 7, 6, 0, 0, 0, 0], [0, 0, 3, 3, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 2, 9, 0, 0], [2, 1, 0, 0, 0, 0, 1, 6, 0, 0], [0, 0, 0, 4, 7, 0, 0, 0, 0, 0], [0, 0, 0, 8, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 2, 9, 0, 0], [2, 1, 0, 0, 0, 0, 1, 6, 0, 0], [3, 3, 0, 4, 7, 0, 3, 3, 0, 0], [3, 3, 0, 8, 4, 0, 3, 3, 0, 0], [0, 0, 0, 3, 3, 0, 3, 3, 0, 0], [0, 0, 0, 3, 3, 0, 3, 3, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_2x2_grids(input_grid: np.ndarray, locs: List[Tuple[int, int]], n: List[int]) -> np.ndarray:\n    \"\"\"\n      This function takes in a numpy array as input_grid, a list of tuples containing the row and column indices\n      of all 2x2 pixels that are not black (represented by the integer value 0), and a list of integers, where each\n      integer represents the number of unique non-black colors in the corresponding 2x2 pixel. It returns a numpy array\n      where for each 2x2 pixel, the n * 2 pixels just under it are changed to green.\n\n      Args:\n      - input_grid: A numpy array of shape (n, m) representing the input grid\n      - locs: A list of tuples containing the row and column indices of all 2x2 pixels that are not black\n      - n: A list of integers, where each integer represents the number of unique non-black colors in the corresponding 2x2 pixel\n\n      Returns:\n      - A numpy array where for each 2x2 pixel, the n * 2 pixels just under it are changed to green\n      \"\"\"\n    out_grid = input_grid.copy()\n    for i, loc in enumerate(locs):\n        x, y = loc\n        for j in range(n[i]):\n            for k in range(2):\n                out_grid[x + j + 2, y + k] = green\n    return out_grid\n\ndef get_num_colors_2x2(input_grid: np.ndarray, locs: List[Tuple[int, int]]) -> List[int]:\n    num_colors = []\n    for loc in locs:\n        i, j = loc\n        colors = set([input_grid[i][j], input_grid[i][j + 1], input_grid[i + 1][j], input_grid[i + 1][j + 1]])\n        num_colors.append(len(colors))\n    return num_colors\n\ndef find_non_black_2x2_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    locs = []\n    for i in range(input_grid.shape[0] - 1):\n        for j in range(input_grid.shape[1] - 1):\n            if input_grid[i][j] != black and input_grid[i][j + 1] != black and (input_grid[i + 1][j] != black) and (input_grid[i + 1][j + 1] != black):\n                locs.append((i, j))\n    return locs\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    locs = find_non_black_2x2_pixels(input_grid)\n    n = get_num_colors_2x2(input_grid, locs)\n    out_grid = color_2x2_grids(input_grid, locs, n)\n    return out_grid"},
{"name": "4c4377d9.json", "data": {"train": [{"input": [[9, 9, 5, 9], [5, 5, 9, 9], [9, 5, 9, 9]], "output": [[9, 5, 9, 9], [5, 5, 9, 9], [9, 9, 5, 9], [9, 9, 5, 9], [5, 5, 9, 9], [9, 5, 9, 9]]}, {"input": [[4, 1, 1, 4], [1, 1, 1, 1], [4, 4, 4, 1]], "output": [[4, 4, 4, 1], [1, 1, 1, 1], [4, 1, 1, 4], [4, 1, 1, 4], [1, 1, 1, 1], [4, 4, 4, 1]]}, {"input": [[9, 4, 9, 4], [9, 9, 4, 4], [4, 4, 4, 4]], "output": [[4, 4, 4, 4], [9, 9, 4, 4], [9, 4, 9, 4], [9, 4, 9, 4], [9, 9, 4, 4], [4, 4, 4, 4]]}, {"input": [[3, 3, 5, 5], [3, 5, 5, 3], [5, 5, 3, 3]], "output": [[5, 5, 3, 3], [3, 5, 5, 3], [3, 3, 5, 5], [3, 3, 5, 5], [3, 5, 5, 3], [5, 5, 3, 3]]}], "test": [{"input": [[4, 4, 9, 9], [4, 4, 4, 4], [4, 4, 9, 9]], "output": [[4, 4, 9, 9], [4, 4, 4, 4], [4, 4, 9, 9], [4, 4, 9, 9], [4, 4, 4, 4], [4, 4, 9, 9]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef get_combination_array(flip_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    return np.concatenate((flip_grid, input_grid), axis=0)\n\ndef flip_up_down(input_grid: np.ndarray) -> np.ndarray:\n    return np.flipud(input_grid)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    flip_grid = flip_up_down(input_grid)\n    output = get_combination_array(flip_grid, input_grid)\n    return output"},
{"name": "68b16354.json", "data": {"train": [{"input": [[8, 1, 2, 1, 4], [4, 4, 2, 4, 8], [3, 7, 2, 4, 8], [2, 7, 7, 8, 7], [8, 7, 7, 4, 8]], "output": [[8, 7, 7, 4, 8], [2, 7, 7, 8, 7], [3, 7, 2, 4, 8], [4, 4, 2, 4, 8], [8, 1, 2, 1, 4]]}, {"input": [[7, 3, 3, 1, 2], [1, 8, 2, 4, 1], [2, 7, 8, 7, 2], [7, 7, 4, 1, 8], [8, 1, 7, 7, 1]], "output": [[8, 1, 7, 7, 1], [7, 7, 4, 1, 8], [2, 7, 8, 7, 2], [1, 8, 2, 4, 1], [7, 3, 3, 1, 2]]}, {"input": [[2, 7, 4, 3, 4, 8, 3], [2, 3, 7, 1, 2, 3, 3], [8, 7, 4, 3, 2, 2, 4], [1, 1, 2, 1, 4, 4, 7], [2, 4, 3, 1, 1, 4, 1], [4, 8, 7, 4, 4, 8, 2], [7, 3, 8, 4, 3, 2, 8]], "output": [[7, 3, 8, 4, 3, 2, 8], [4, 8, 7, 4, 4, 8, 2], [2, 4, 3, 1, 1, 4, 1], [1, 1, 2, 1, 4, 4, 7], [8, 7, 4, 3, 2, 2, 4], [2, 3, 7, 1, 2, 3, 3], [2, 7, 4, 3, 4, 8, 3]]}], "test": [{"input": [[2, 8, 1, 3, 2, 4, 1], [4, 4, 1, 1, 4, 3, 4], [1, 1, 1, 1, 4, 7, 3], [1, 1, 2, 3, 8, 1, 3], [4, 1, 1, 1, 7, 8, 4], [3, 2, 8, 4, 1, 8, 4], [1, 4, 7, 1, 2, 3, 4]], "output": [[1, 4, 7, 1, 2, 3, 4], [3, 2, 8, 4, 1, 8, 4], [4, 1, 1, 1, 7, 8, 4], [1, 1, 2, 3, 8, 1, 3], [1, 1, 1, 1, 4, 7, 3], [4, 4, 1, 1, 4, 3, 4], [2, 8, 1, 3, 2, 4, 1]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef flip_vertically(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you should see...many pixels of various colors\n    The output grid size...is the same as the input grid size\n    To make the output, you have to...flip the input grid vertically\n    \"\"\"\n    output_grid = np.flipud(input_grid)\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you should see...many pixels of various colors\n    The output grid size...is the same as the input grid size\n    To make the output, you have to...flip the input grid vertically\n    \"\"\"\n    output_grid = flip_vertically(input_grid)\n    return output_grid"},
{"name": "a5f85a15.json", "data": {"train": [{"input": [[2, 0, 0], [0, 2, 0], [0, 0, 2]], "output": [[2, 0, 0], [0, 4, 0], [0, 0, 2]]}, {"input": [[0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 9, 0, 0, 0, 0], [0, 0, 0, 0, 9, 0, 0, 0], [0, 0, 0, 0, 0, 9, 0, 0], [9, 0, 0, 0, 0, 0, 9, 0], [0, 9, 0, 0, 0, 0, 0, 9], [0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 9, 0, 0, 0, 0]], "output": [[0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 9, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0], [9, 0, 0, 0, 0, 0, 9, 0], [0, 4, 0, 0, 0, 0, 0, 4], [0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0]]}, {"input": [[0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0], [3, 0, 0, 0, 0, 3], [0, 3, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0]], "output": [[0, 0, 3, 0, 0, 0], [0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 3, 0], [3, 0, 0, 0, 0, 4], [0, 4, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 6, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 6], [6, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 6, 0]], "output": [[0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 6, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 4], [6, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_pixels_in_bottom_right_direction(grid: np.ndarray, loc: Tuple[int, int], color: int) -> np.ndarray:\n    i, j = loc\n    colour = color\n    while i < grid.shape[0] and j < grid.shape[1]:\n        if grid[i][j] != black:\n            grid[i][j] = colour\n        colour = yellow if colour != yellow else color\n        i += 1\n        j += 1\n    return grid\n\ndef get_pixel_color(grid: np.ndarray, loc: Tuple[int, int]) -> int:\n    return grid[loc[0]][loc[1]]\n\ndef get_non_black_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    non_black_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black and (i == 0 or j == 0):\n                non_black_pixels.append((i, j))\n    return non_black_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = input_grid\n    locs = get_non_black_pixels(input_grid)\n    color = get_pixel_color(input_grid, locs[0])\n    for loc in locs:\n        output_grid = change_pixels_in_bottom_right_direction(output_grid, loc, color)\n    return output_grid"},
{"name": "cce03e0d.json", "data": {"train": [{"input": [[1, 0, 0], [2, 1, 0], [0, 0, 1]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0], [2, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 1, 2], [1, 1, 0], [2, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 1, 2], [0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[2, 1, 2], [0, 2, 1], [2, 1, 0]], "output": [[2, 1, 2, 0, 0, 0, 2, 1, 2], [0, 2, 1, 0, 0, 0, 0, 2, 1], [2, 1, 0, 0, 0, 0, 2, 1, 0], [0, 0, 0, 2, 1, 2, 0, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0, 0], [0, 0, 0, 2, 1, 0, 0, 0, 0], [2, 1, 2, 0, 0, 0, 0, 0, 0], [0, 2, 1, 0, 0, 0, 0, 0, 0], [2, 1, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[1, 2, 2], [2, 0, 1], [1, 2, 0]], "output": [[0, 0, 0, 1, 2, 2, 1, 2, 2], [0, 0, 0, 2, 0, 1, 2, 0, 1], [0, 0, 0, 1, 2, 0, 1, 2, 0], [1, 2, 2, 0, 0, 0, 0, 0, 0], [2, 0, 1, 0, 0, 0, 0, 0, 0], [1, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 2, 2, 0, 0, 0], [0, 0, 0, 2, 0, 1, 0, 0, 0], [0, 0, 0, 1, 2, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef copy_to_3x3_grid(input_grid: np.ndarray, output_grid: np.ndarray, i: int, j: int) -> np.ndarray:\n    output_grid[3 * i:3 * i + 3, 3 * j:3 * j + 3] = input_grid\n    return output_grid\n\ndef make_grid() -> np.ndarray:\n    return np.zeros((9, 9), dtype=int)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = make_grid()\n    for i in range(3):\n        for j in range(3):\n            if input_grid[i, j] == red:\n                output_grid = copy_to_3x3_grid(input_grid, output_grid, i, j)\n    return output_grid"},
{"name": "1190e5a7.json", "data": {"train": [{"input": [[3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3], [3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3], [3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3], [3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3], [3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3], [3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3], [3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3], [3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3], [3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3], [3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3], [3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3], [3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3], [3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 3, 3, 7, 3]], "output": [[3, 3, 3, 3], [3, 3, 3, 3]]}, {"input": [[1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 8, 1, 1, 1, 1, 1, 1]], "output": [[1, 1], [1, 1], [1, 1]]}, {"input": [[3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3], [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 1, 3, 1, 3]], "output": [[3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3]]}], "test": [{"input": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 1, 1, 1, 5, 1]], "output": [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef generate_output_grid(major_color: int, vertical_line_num: int, horizontal_line_num: int) -> np.ndarray:\n    \"\"\"\n    Given the major color, number of grids in the first row that are not of major color, and number of grids in the first column that are not of major color,\n    this function generates an output grid of size (horizontal_line_num + 1) x (vertical_line_num + 1) where all grids are of major color.\n\n    Args:\n    major_color: An integer representing the major color in the grid.\n    vertical_line_num: An integer representing the number of grids in the first row that are not of major color.\n    horizontal_line_num: An integer representing the number of grids in the first column that are not of major color.\n\n    Returns:\n    A numpy array representing the output grid.\n    \"\"\"\n    output = np.full((horizontal_line_num + 1, vertical_line_num + 1), major_color)\n    return output\n\ndef find_horizontal_line_num(input_grid: np.ndarray, major_color: int) -> int:\n    \"\"\"\n    Given an input grid and the major color, this function finds the number of grids in the first column that are not of major color.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    major_color: An integer representing the major color in the grid.\n\n    Returns:\n    An integer representing the number of grids in the first column that are not of major color.\n    \"\"\"\n    first_column = input_grid[:, 0]\n    return len(first_column) - np.count_nonzero(first_column == major_color)\n\ndef find_vertical_line_num(input_grid: np.ndarray, major_color: int) -> int:\n    \"\"\"\n    Given an input grid and the major color, this function finds the number of grids in the first row that are not of major color.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    major_color: An integer representing the major color in the grid.\n\n    Returns:\n    An integer representing the number of grids in the first row that are not of major color.\n    \"\"\"\n    first_row = input_grid[0]\n    return len(first_row) - np.count_nonzero(first_row == major_color)\n\ndef find_major_color(input_grid: np.ndarray) -> int:\n    \"\"\"\n    Given an input grid, this function finds the major color in the grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    An integer representing the major color in the grid.\n    \"\"\"\n    color_counts = np.bincount(input_grid.flatten())\n    major_color = np.argmax(color_counts)\n    return major_color\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    major_color = find_major_color(input_grid)\n    vertical_line_num = find_vertical_line_num(input_grid, major_color)\n    horizontal_line_num = find_horizontal_line_num(input_grid, major_color)\n    output = generate_output_grid(major_color, vertical_line_num, horizontal_line_num)\n    return output"},
{"name": "d90796e8.json", "data": {"train": [{"input": [[3, 2, 0], [0, 0, 0], [0, 5, 0]], "output": [[8, 0, 0], [0, 0, 0], [0, 5, 0]]}, {"input": [[5, 0, 0, 0, 0, 0], [0, 0, 3, 2, 0, 0], [0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 2], [0, 2, 0, 0, 0, 0], [5, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[5, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0], [5, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 2, 0], [3, 0, 0, 0, 0, 0, 3], [5, 0, 2, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0], [3, 2, 0, 0, 0, 3, 0], [0, 0, 0, 5, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 2, 0], [3, 0, 0, 0, 0, 0, 3], [5, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 8, 0], [0, 0, 0, 5, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 2, 0, 0, 0, 5], [0, 2, 0, 0, 0, 0, 3, 2, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 2], [5, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0], [5, 3, 0, 0, 0, 5, 0, 2, 0]], "output": [[0, 0, 0, 0, 2, 0, 0, 0, 5], [0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 2], [5, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0], [5, 3, 0, 0, 0, 5, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef get_adjacent_points(i: int, j: int, rows: int, cols: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    This function takes in the row and column indices of a point in a grid and returns a list of tuples representing the row and column indices of its adjacent points.\n    \n    Args:\n    - i: An integer representing the row index of the point.\n    - j: An integer representing the column index of the point.\n    - rows: An integer representing the number of rows in the grid.\n    - cols: An integer representing the number of columns in the grid.\n    \n    Returns:\n    - adjacent_points: A list of tuples representing the row and column indices of the adjacent points.\n    \"\"\"\n    adjacent_points = []\n    if i > 0:\n        adjacent_points.append((i - 1, j))\n    if i < rows - 1:\n        adjacent_points.append((i + 1, j))\n    if j > 0:\n        adjacent_points.append((i, j - 1))\n    if j < cols - 1:\n        adjacent_points.append((i, j + 1))\n    return adjacent_points\n\ndef process_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes in a numpy array representing a grid of colors and processes it according to the following rules:\n    - For every red point in the grid, if it has green adjacent points, turn that green adjacent point to teal and turn the red point to black.\n    - Return the processed grid.\n    \n    Args:\n    - input_grid: A numpy array representing a grid of colors. Each element in the array is an integer representing a color.\n    \n    Returns:\n    - output_grid: A numpy array representing the processed grid of colors.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] == red:\n                adjacent_points = get_adjacent_points(i, j, rows, cols)\n                for point in adjacent_points:\n                    if input_grid[point[0]][point[1]] == green:\n                        output_grid[point[0]][point[1]] = teal\n                        output_grid[i][j] = black\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = process_grid(input_grid)\n    return output_grid"},
{"name": "3906de3d.json", "data": {"train": [{"input": [[0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0]], "output": [[0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 2, 1, 1, 0, 0, 0], [0, 0, 1, 1, 2, 1, 1, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 0, 1, 0, 1, 1, 0], [0, 0, 1, 1, 0, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 2, 0, 2, 0, 0, 0]], "output": [[0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 2, 1, 1, 1, 1, 0], [0, 0, 1, 1, 0, 1, 2, 1, 1, 0], [0, 0, 1, 1, 0, 1, 2, 1, 1, 0], [0, 0, 0, 0, 0, 0, 2, 1, 1, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1, 0, 1], [0, 1, 1, 0, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 2, 0, 0, 2, 0, 2, 0], [0, 0, 0, 2, 2, 0, 2, 0, 2, 0], [0, 0, 0, 2, 2, 0, 2, 0, 2, 0]], "output": [[0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 1, 2, 1, 1, 1, 1, 1, 1], [0, 1, 1, 2, 1, 1, 1, 1, 2, 1], [0, 1, 1, 2, 2, 1, 2, 1, 2, 1], [0, 0, 0, 0, 2, 0, 2, 0, 2, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 1, 1, 1, 1, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 0, 0, 1, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 2, 1], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 2, 0, 0, 2, 0], [0, 0, 2, 0, 0, 2, 0, 0, 2, 0], [0, 0, 2, 0, 2, 2, 0, 0, 2, 0], [0, 0, 2, 0, 2, 2, 2, 0, 2, 0]], "output": [[0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 2, 1, 1, 1, 1, 1, 2, 1], [0, 1, 2, 1, 2, 1, 2, 1, 2, 1], [0, 1, 2, 1, 2, 2, 0, 1, 2, 1], [0, 0, 0, 1, 0, 2, 0, 0, 2, 1], [0, 0, 0, 0, 0, 2, 0, 0, 2, 0], [0, 0, 0, 0, 0, 2, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef move_red_squares_up_by_distance(grid: np.ndarray, column_distance: Tuple[int, int]) -> np.ndarray:\n    col, distance = column_distance\n    red_indices = np.where(grid[:, col] == red)[0]\n    for index in red_indices:\n        grid[index - distance, col] = red\n        grid[index, col] = black\n    return grid\n\ndef generate_column_distances(output_grid: np.ndarray) -> Dict[int, int]:\n    column_distances = {}\n    for col in range(output_grid.shape[1]):\n        if red in output_grid[:, col]:\n            red_index = np.where(output_grid[:, col] == red)[0][0]\n            black_index = np.where(output_grid[:, col] == black)[0][0]\n            distance = red_index - black_index\n            column_distances[col] = distance\n    return column_distances\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n    dict = generate_column_distances(output_grid)\n    for kv in dict.items():\n        output_grid = move_red_squares_up_by_distance(output_grid, kv)\n    return output_grid"},
{"name": "8d5021e8.json", "data": {"train": [{"input": [[0, 8], [0, 0], [0, 8]], "output": [[8, 0, 0, 8], [0, 0, 0, 0], [8, 0, 0, 8], [8, 0, 0, 8], [0, 0, 0, 0], [8, 0, 0, 8], [8, 0, 0, 8], [0, 0, 0, 0], [8, 0, 0, 8]]}, {"input": [[2, 0], [2, 2], [2, 0]], "output": [[0, 2, 2, 0], [2, 2, 2, 2], [0, 2, 2, 0], [0, 2, 2, 0], [2, 2, 2, 2], [0, 2, 2, 0], [0, 2, 2, 0], [2, 2, 2, 2], [0, 2, 2, 0]]}, {"input": [[0, 0], [0, 5], [5, 0]], "output": [[0, 5, 5, 0], [5, 0, 0, 5], [0, 0, 0, 0], [0, 0, 0, 0], [5, 0, 0, 5], [0, 5, 5, 0], [0, 5, 5, 0], [5, 0, 0, 5], [0, 0, 0, 0]]}], "test": [{"input": [[3, 3], [3, 0], [3, 3]], "output": [[3, 3, 3, 3], [0, 3, 3, 0], [3, 3, 3, 3], [3, 3, 3, 3], [0, 3, 3, 0], [3, 3, 3, 3], [3, 3, 3, 3], [0, 3, 3, 0], [3, 3, 3, 3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef concatenate_grids(grid1: List[List[int]], grid2: List[List[int]], grid3: List[List[int]]) -> np.ndarray:\n    \"\"\"\n    This function concatenates the three input grids to a new numpy array along axis 0.\n\n    Args:\n    grid1: A list of lists containing integers representing the first input grid.\n    grid2: A list of lists containing integers representing the second input grid.\n    grid3: A list of lists containing integers representing the third input grid.\n\n    Returns:\n    A numpy array containing integers representing the concatenated grid.\n    \"\"\"\n    return np.concatenate((grid1, grid2, grid3), axis=0)\n\ndef mirror_top_boundary(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    This function mirrors the input grid's symmetry with the top boundary.\n\n    Args:\n    input_grid: A list of lists containing integers representing the input grid.\n\n    Returns:\n    A list of lists containing integers representing the mirrored grid.\n    \"\"\"\n    return input_grid[::-1]\n\ndef mirror_left_boundary(input):\n    return np.concatenate((input[:, ::-1], input), axis=1)\n\ndef transform_grid(input_grid):\n    t1 = mirror_left_boundary(input_grid)\n    t2 = mirror_top_boundary(t1)\n    t3 = concatenate_grids(t2, t1, t2)\n    return t3"},
{"name": "c1d99e64.json", "data": {"train": [{"input": [[1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1]], "output": [[1, 0, 0, 0, 1, 1, 1, 1, 2, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 2, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 1, 1, 1, 0, 0, 1, 1, 2, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 1, 0, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 1, 0, 1, 1, 0, 2, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [1, 0, 0, 1, 1, 0, 1, 0, 2, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0], [1, 1, 0, 0, 1, 1, 1, 1, 2, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [1, 1, 1, 0, 0, 1, 1, 1, 2, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 2, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 1, 0, 0, 1, 2, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1]]}, {"input": [[8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 0, 8, 8], [0, 8, 0, 0, 0, 0, 8, 8, 8, 8, 0, 8, 8, 8], [8, 8, 0, 8, 0, 8, 8, 8, 8, 8, 0, 0, 8, 8], [8, 0, 8, 8, 0, 8, 8, 0, 0, 8, 0, 8, 8, 0], [8, 8, 8, 8, 0, 8, 8, 0, 0, 0, 0, 8, 8, 8], [8, 8, 8, 0, 0, 8, 8, 0, 8, 0, 0, 8, 8, 8], [8, 0, 8, 8, 0, 8, 8, 8, 8, 8, 0, 0, 0, 8], [8, 8, 0, 0, 0, 8, 0, 0, 8, 8, 0, 0, 8, 8], [8, 0, 0, 8, 0, 8, 8, 8, 0, 8, 0, 8, 8, 8], [8, 8, 0, 8, 0, 8, 8, 8, 8, 8, 0, 0, 8, 0], [0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8], [8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 0, 8, 0]], "output": [[8, 8, 8, 8, 2, 8, 8, 8, 8, 8, 2, 0, 8, 8], [0, 8, 0, 0, 2, 0, 8, 8, 8, 8, 2, 8, 8, 8], [8, 8, 0, 8, 2, 8, 8, 8, 8, 8, 2, 0, 8, 8], [8, 0, 8, 8, 2, 8, 8, 0, 0, 8, 2, 8, 8, 0], [8, 8, 8, 8, 2, 8, 8, 0, 0, 0, 2, 8, 8, 8], [8, 8, 8, 0, 2, 8, 8, 0, 8, 0, 2, 8, 8, 8], [8, 0, 8, 8, 2, 8, 8, 8, 8, 8, 2, 0, 0, 8], [8, 8, 0, 0, 2, 8, 0, 0, 8, 8, 2, 0, 8, 8], [8, 0, 0, 8, 2, 8, 8, 8, 0, 8, 2, 8, 8, 8], [8, 8, 0, 8, 2, 8, 8, 8, 8, 8, 2, 0, 8, 0], [0, 8, 0, 8, 2, 0, 0, 0, 0, 0, 2, 8, 0, 8], [8, 8, 8, 8, 2, 8, 8, 8, 8, 8, 2, 0, 8, 0]]}, {"input": [[3, 0, 3, 3, 3, 3, 3, 0, 3, 3, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 3, 3, 0, 3, 0, 3, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 3, 0, 0, 3, 3, 0, 3, 0, 3, 3, 0, 0], [3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3], [3, 0, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 0, 3, 3], [0, 0, 3, 0, 3, 0, 3, 0, 3, 0, 0, 3, 3, 3, 0], [3, 0, 0, 3, 3, 3, 0, 0, 3, 0, 3, 3, 0, 0, 3], [3, 0, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 0, 3], [3, 0, 0, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [3, 0, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 0, 3, 3], [3, 0, 3, 3, 3, 0, 3, 0, 0, 3, 0, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 3, 0, 0, 3, 0, 3, 3, 0, 3, 3, 3, 3, 0], [3, 0, 0, 3, 0, 3, 3, 0, 3, 0, 3, 3, 0, 0, 3], [3, 0, 0, 3, 3, 3, 3, 3, 0, 3, 3, 0, 0, 3, 3], [0, 0, 3, 3, 0, 3, 3, 0, 0, 3, 0, 3, 0, 3, 0]], "output": [[3, 2, 3, 3, 3, 3, 3, 0, 3, 3, 3, 0, 3, 0, 3], [3, 2, 3, 0, 3, 3, 3, 0, 3, 0, 3, 0, 0, 3, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [3, 2, 0, 3, 0, 0, 3, 3, 0, 3, 0, 3, 3, 0, 0], [3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3], [3, 2, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 0, 3, 3], [0, 2, 3, 0, 3, 0, 3, 0, 3, 0, 0, 3, 3, 3, 0], [3, 2, 0, 3, 3, 3, 0, 0, 3, 0, 3, 3, 0, 0, 3], [3, 2, 3, 3, 3, 3, 3, 0, 3, 3, 3, 3, 3, 0, 3], [3, 2, 0, 3, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0], [3, 2, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 0, 3, 3], [3, 2, 3, 3, 3, 0, 3, 0, 0, 3, 0, 3, 3, 3, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [3, 2, 3, 0, 0, 3, 0, 3, 3, 0, 3, 3, 3, 3, 0], [3, 2, 0, 3, 0, 3, 3, 0, 3, 0, 3, 3, 0, 0, 3], [3, 2, 0, 3, 3, 3, 3, 3, 0, 3, 3, 0, 0, 3, 3], [0, 2, 3, 3, 0, 3, 3, 0, 0, 3, 0, 3, 0, 3, 0]]}], "test": [{"input": [[4, 0, 4, 0, 4, 4, 0, 0, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 0, 4, 4, 0, 4, 0, 0], [4, 4, 4, 0, 0, 4, 0, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 0], [4, 4, 0, 4, 4, 4, 0, 0, 0, 0, 4, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 0, 4, 4, 4], [4, 4, 4, 0, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 0, 4, 0, 4, 0, 4], [4, 0, 0, 4, 0, 4, 0, 4, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 4, 0, 4, 0, 4, 4, 4], [4, 4, 4, 4, 4, 0, 0, 4, 0, 4, 0, 0, 4, 4, 0, 0, 4, 4, 4, 0, 0, 0, 0, 4, 0], [0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 0, 4, 0, 4, 0, 0, 4, 0, 4], [4, 4, 4, 0, 4, 4, 0, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 4, 4, 4, 0, 0, 4, 4, 4], [4, 0, 4, 4, 4, 0, 0, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 0, 0, 0, 4], [4, 4, 0, 4, 0, 0, 0, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 4, 4, 0, 0, 4, 4, 4, 4, 0, 0, 4, 4], [4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 0, 4, 0, 4, 4, 0, 4, 4, 4, 4, 0, 4, 4, 4], [4, 4, 4, 4, 4, 0, 0, 4, 0, 4, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 4, 0, 4], [0, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 0, 4, 4, 4, 0, 4, 4, 0], [0, 4, 4, 4, 4, 0, 0, 4, 4, 4, 0, 4, 0, 4, 0, 4, 4, 4, 4, 4, 4, 0, 0, 4, 4], [4, 4, 4, 0, 4, 4, 0, 0, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 4, 0, 4, 4, 4, 0, 4, 4, 0, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 0, 0, 0, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 4, 0, 4, 0, 4, 4, 4, 0, 0, 0, 0, 4, 0, 4, 4, 4, 0, 4, 4, 4], [0, 4, 4, 4, 4, 4, 0, 4, 0, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 0, 4, 4, 4], [4, 4, 4, 4, 4, 4, 0, 4, 4, 0, 0, 0, 0, 4, 4, 4, 0, 0, 4, 4, 4, 0, 4, 4, 0], [4, 0, 4, 0, 4, 4, 0, 4, 0, 0, 0, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 0, 0, 4, 0], [4, 4, 0, 4, 0, 4, 0, 0, 4, 0, 4, 4, 0, 4, 4, 0, 0, 0, 4, 0, 4, 0, 4, 4, 4], [4, 0, 0, 4, 4, 4, 0, 4, 0, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 0, 0, 0, 4, 4, 4]], "output": [[4, 0, 4, 0, 4, 4, 2, 0, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 0, 4, 4, 2, 4, 0, 0], [4, 4, 4, 0, 0, 4, 2, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 2, 4, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [4, 0, 4, 4, 4, 0, 2, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 0], [4, 4, 0, 4, 4, 4, 2, 0, 0, 0, 4, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 2, 4, 4, 4], [4, 4, 4, 0, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 0, 4, 2, 4, 0, 4], [4, 0, 0, 4, 0, 4, 2, 4, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 4, 0, 4, 2, 4, 4, 4], [4, 4, 4, 4, 4, 0, 2, 4, 0, 4, 0, 0, 4, 4, 0, 0, 4, 4, 4, 0, 0, 2, 0, 4, 0], [0, 4, 4, 0, 4, 4, 2, 4, 4, 0, 4, 4, 0, 4, 4, 0, 0, 4, 0, 4, 0, 2, 4, 0, 4], [4, 4, 4, 0, 4, 4, 2, 0, 4, 4, 4, 4, 4, 0, 0, 4, 0, 4, 4, 4, 0, 2, 4, 4, 4], [4, 0, 4, 4, 4, 0, 2, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 2, 0, 0, 4], [4, 4, 0, 4, 0, 0, 2, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 2, 4, 4, 4], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 4, 4, 0, 0, 0, 2, 0, 4, 4, 4, 4, 0, 4, 4, 0, 0, 4, 4, 4, 4, 2, 0, 4, 4], [4, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 0, 4, 0, 4, 4, 0, 4, 4, 4, 4, 2, 4, 4, 4], [4, 4, 4, 4, 4, 0, 2, 4, 0, 4, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 0, 2, 4, 0, 4], [0, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 0, 4, 4, 4, 2, 4, 4, 0], [0, 4, 4, 4, 4, 0, 2, 4, 4, 4, 0, 4, 0, 4, 0, 4, 4, 4, 4, 4, 4, 2, 0, 4, 4], [4, 4, 4, 0, 4, 4, 2, 0, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 0, 0, 0], [4, 4, 0, 4, 4, 4, 2, 4, 4, 0, 4, 4, 4, 0, 4, 4, 4, 0, 4, 4, 0, 2, 0, 4, 4], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [4, 4, 4, 4, 0, 4, 2, 4, 0, 4, 4, 4, 0, 0, 0, 0, 4, 0, 4, 4, 4, 2, 4, 4, 4], [0, 4, 4, 4, 4, 4, 2, 4, 0, 4, 0, 4, 4, 0, 4, 4, 0, 4, 4, 0, 4, 2, 4, 4, 4], [4, 4, 4, 4, 4, 4, 2, 4, 4, 0, 0, 0, 0, 4, 4, 4, 0, 0, 4, 4, 4, 2, 4, 4, 0], [4, 0, 4, 0, 4, 4, 2, 4, 0, 0, 0, 4, 4, 4, 4, 4, 0, 4, 0, 4, 4, 2, 0, 4, 0], [4, 4, 0, 4, 0, 4, 2, 0, 4, 0, 4, 4, 0, 4, 4, 0, 0, 0, 4, 0, 4, 2, 4, 4, 4], [4, 0, 0, 4, 4, 4, 2, 4, 0, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 0, 0, 2, 4, 4, 4]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef paint_rows_and_columns(input_grid: np.ndarray, ngrid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Traverse each row in the inputgrid, if the row is all black, paint the corresponding row in the ngrid red.\n    Traverse each column in inputgrid, if the column is all black, paint the corresponding column in ngrid red.\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i] == black):\n            ngrid[i] = red\n    for j in range(input_grid.shape[1]):\n        if np.all(input_grid[:, j] == black):\n            ngrid[:, j] = red\n    return ngrid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    ngrid = input_grid.copy()\n    ans_grid = paint_rows_and_columns(input_grid, ngrid)\n    return ans_grid"},
{"name": "50cb2852.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 2, 8, 8, 8, 2, 0, 0, 0, 1, 8, 1, 0, 0], [0, 0, 2, 8, 8, 8, 2, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 2, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 8, 8, 8, 8, 8, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 8, 8, 8, 8, 8, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 8, 8, 8, 8, 8, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 2, 8, 8, 2, 0, 0, 0, 0, 0, 0], [0, 2, 8, 8, 2, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 8, 8, 8, 8, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0], [3, 3, 3, 3, 0, 0, 2, 2, 2, 2, 0, 0, 0], [3, 3, 3, 3, 0, 0, 2, 2, 2, 2, 0, 0, 0], [3, 3, 3, 3, 0, 0, 2, 2, 2, 2, 0, 0, 0], [3, 3, 3, 3, 0, 0, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0], [3, 3, 3, 3, 0, 0, 2, 8, 8, 2, 0, 0, 0], [3, 8, 8, 3, 0, 0, 2, 8, 8, 2, 0, 0, 0], [3, 8, 8, 3, 0, 0, 2, 8, 8, 2, 0, 0, 0], [3, 3, 3, 3, 0, 0, 2, 8, 8, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0], [0, 0, 1, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0]]}], "test": [{"input": [[0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 3, 3, 3, 3], [0, 0, 2, 2, 2, 2, 2, 2, 0, 3, 3, 3, 3], [0, 0, 2, 2, 2, 2, 2, 2, 0, 3, 3, 3, 3], [0, 0, 2, 2, 2, 2, 2, 2, 0, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3]], "output": [[0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 8, 8, 8, 1, 0, 0, 1, 1, 1, 0, 0], [0, 1, 8, 8, 8, 1, 0, 0, 1, 8, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 8, 8, 8, 8, 2, 0, 0, 0, 0, 0], [0, 0, 2, 8, 8, 8, 8, 2, 0, 3, 3, 3, 3], [0, 0, 2, 8, 8, 8, 8, 2, 0, 3, 8, 8, 3], [0, 0, 2, 8, 8, 8, 8, 2, 0, 3, 8, 8, 3], [0, 0, 2, 2, 2, 2, 2, 2, 0, 3, 8, 8, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 8, 8, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 8, 8, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_non_black_cells(input_grid):\n    \"\"\"\n    Traverse every position of input. For every position which is not black, if all of the four connected positions of it are not black, change the position to teal.\n    \"\"\"\n    rows, cols = input_grid.shape\n    output_grid = np.copy(input_grid)\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] != black:\n                if i > 0 and j > 0 and (i < rows - 1) and (j < cols - 1):\n                    if input_grid[i - 1][j] != black and input_grid[i + 1][j] != black and (input_grid[i][j - 1] != black) and (input_grid[i][j + 1] != black):\n                        output_grid[i][j] = teal\n    return output_grid\n\ndef transform_grid(input_grid):\n    output = color_non_black_cells(input_grid)\n    return output"},
{"name": "eb281b96.json", "data": {"train": [{"input": [[0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8]], "output": [[0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8], [0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0], [0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0]]}, {"input": [[0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0], [2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2]], "output": [[0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0], [2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0], [2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0]]}], "test": [{"input": [[0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3]], "output": [[0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0], [0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef flip_pattern(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Flips the input grid vertically\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    \n    Returns:\n    A numpy array representing the flipped grid\n    \"\"\"\n    return np.flipud(input_grid)\n\ndef create_output_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Creates a new output grid with the same width as the input grid and four times the height minus three\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    \n    Returns:\n    A numpy array representing the output grid\n    \"\"\"\n    output_grid = np.zeros((input_grid.shape[0] * 4 - 3, input_grid.shape[1]), dtype=int)\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you should see the whole grid as a pattern                                                                                                            \n    The output grid size...is the same horizontally and multiplied by 4 vertically (and subtract 3)                                                                     \n    To make the output, flip the pattern vertically 3 times to create a continuous pattern that is symmetrical both vertically and horizontally                         \n    \"\"\"\n    output_grid = create_output_grid(input_grid)\n    original_pattern = input_grid\n    fliped_pattern = flip_pattern(input_grid)\n    output_grid[:original_pattern.shape[0], :] = original_pattern\n    output_grid[input_grid.shape[0] - 1:input_grid.shape[0] * 2 - 1, :] = fliped_pattern\n    output_grid[input_grid.shape[0] * 2 - 2:input_grid.shape[0] * 3 - 2, :] = input_grid\n    output_grid[input_grid.shape[0] * 3 - 3:input_grid.shape[0] * 4 - 3, :] = fliped_pattern\n    return output_grid"},
{"name": "b91ae062.json", "data": {"train": [{"input": [[6, 7, 0], [0, 6, 6], [0, 0, 0]], "output": [[6, 6, 7, 7, 0, 0], [6, 6, 7, 7, 0, 0], [0, 0, 6, 6, 6, 6], [0, 0, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]}, {"input": [[1, 0, 4], [0, 4, 0], [0, 1, 0]], "output": [[1, 1, 0, 0, 4, 4], [1, 1, 0, 0, 4, 4], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0]]}, {"input": [[3, 2, 0], [0, 7, 3], [0, 0, 0]], "output": [[3, 3, 3, 2, 2, 2, 0, 0, 0], [3, 3, 3, 2, 2, 2, 0, 0, 0], [3, 3, 3, 2, 2, 2, 0, 0, 0], [0, 0, 0, 7, 7, 7, 3, 3, 3], [0, 0, 0, 7, 7, 7, 3, 3, 3], [0, 0, 0, 7, 7, 7, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 8, 0], [0, 6, 6], [9, 8, 0]], "output": [[0, 0, 0, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 6, 6], [0, 0, 0, 6, 6, 6, 6, 6, 6], [0, 0, 0, 6, 6, 6, 6, 6, 6], [9, 9, 9, 8, 8, 8, 0, 0, 0], [9, 9, 9, 8, 8, 8, 0, 0, 0], [9, 9, 9, 8, 8, 8, 0, 0, 0]]}, {"input": [[4, 0, 3], [2, 2, 0], [0, 0, 8]], "output": [[4, 4, 4, 4, 0, 0, 0, 0, 3, 3, 3, 3], [4, 4, 4, 4, 0, 0, 0, 0, 3, 3, 3, 3], [4, 4, 4, 4, 0, 0, 0, 0, 3, 3, 3, 3], [4, 4, 4, 4, 0, 0, 0, 0, 3, 3, 3, 3], [2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8]]}], "test": [{"input": [[0, 1, 0], [0, 8, 7], [9, 9, 0]], "output": [[0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 7, 7, 7, 7], [0, 0, 0, 0, 8, 8, 8, 8, 7, 7, 7, 7], [0, 0, 0, 0, 8, 8, 8, 8, 7, 7, 7, 7], [0, 0, 0, 0, 8, 8, 8, 8, 7, 7, 7, 7], [9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 9, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef modify_pixel_color(input_grid: np.ndarray, output_grid: np.ndarray, n: int) -> np.ndarray:\n    for i in range(len(output_grid)):\n        for j in range(len(output_grid[0])):\n            output_grid[i][j] = input_grid[int(i / n)][int(j / n)]\n    return output_grid\n\ndef create_black_image(n: int) -> np.ndarray:\n    return np.zeros((3 * n, 3 * n))\n\ndef count_colors(input_grid: np.ndarray) -> int:\n    n = len(np.unique(input_grid)) - 1\n    return n\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    n = count_colors(input_grid)\n    output_grid = create_black_image(n)\n    output_grid = modify_pixel_color(input_grid, output_grid, n)\n    return output_grid"},
{"name": "d06dbe63.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef move_left_two_points(input_grid: np.ndarray, current_point: Tuple[int, int]) -> Tuple[int, int]:\n    \"\"\"\n    Given a 2D numpy array and a tuple of coordinates, returns the coordinates of the point two columns to the left of the current point.\n    \"\"\"\n    row, col = current_point\n    return (row, col - 2)\n\ndef draw_left_points_grey(input_grid: np.ndarray, current_point: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Given a 2D numpy array and a tuple of coordinates, draws the two left adjacent points of the current point to grey.\n    \"\"\"\n    row, col = current_point\n    if col > 0:\n        input_grid[row][col - 1] = grey\n    if col > 1:\n        input_grid[row][col - 2] = grey\n    return input_grid\n\ndef move_down_two_points(input_grid: np.ndarray, current_point: Tuple[int, int]) -> Tuple[int, int]:\n    \"\"\"\n    Given a 2D numpy array and a tuple of coordinates, returns the coordinates of the point two rows below the current point.\n    \"\"\"\n    row, col = current_point\n    return (row + 2, col)\n\ndef draw_lower_points_grey(input_grid: np.ndarray, current_point: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Given a 2D numpy array and a tuple of coordinates, draws the two lower adjacent points of the current point to grey.\n    \"\"\"\n    row, col = current_point\n    if row < input_grid.shape[0] - 1:\n        input_grid[row + 1][col] = grey\n    if row < input_grid.shape[0] - 2:\n        input_grid[row + 2][col] = grey\n    return input_grid\n\ndef move_right_two_points(input_grid: np.ndarray, current_point: Tuple[int, int]) -> Tuple[int, int]:\n    \"\"\"\n    Given a 2D numpy array and a tuple of coordinates, returns the coordinates of the point two columns to the right of the current point.\n    \"\"\"\n    row, col = current_point\n    return (row, col + 2)\n\ndef draw_right_points_grey(input_grid: np.ndarray, current_point: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Given a 2D numpy array and a tuple of coordinates, draws the two right adjacent points of the current point to grey.\n    \"\"\"\n    row, col = current_point\n    if col < input_grid.shape[1] - 1:\n        input_grid[row][col + 1] = grey\n    if col < input_grid.shape[1] - 2:\n        input_grid[row][col + 2] = grey\n    return input_grid\n\ndef move_up_two_points(input_grid: np.ndarray, current_point: Tuple[int, int]) -> Tuple[int, int]:\n    \"\"\"\n    Given a 2D numpy array and a tuple of coordinates, returns the coordinates of the point two rows above the current point.\n    \"\"\"\n    row, col = current_point\n    return (row - 2, col)\n\ndef draw_upper_points_grey(input_grid: np.ndarray, current_point: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Given a 2D numpy array and a tuple of coordinates, draws the two upper points of the current point to grey.\n    \"\"\"\n    row, col = current_point\n    if row > 0:\n        input_grid[row - 1][col] = grey\n    if row > 1:\n        input_grid[row - 2][col] = grey\n    return input_grid\n\ndef _check_boundary(input_grid: np.ndarray, current_point: Tuple[int, int]) -> bool:\n    \"\"\"\n    Given a 2D numpy array and a tuple of coordinates, returns True if the coordinates are within the boundaries of the array.\n    \"\"\"\n    rows, cols = input_grid.shape\n    row, col = current_point\n    return 0 <= row < rows and 0 <= col < cols\n\ndef find_teal_point(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Given a 2D numpy array, returns the coordinates of the first occurrence of the value \"teal\".\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == teal:\n                return (i, j)\n    raise ValueError('Teal point not found in input grid.')\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    teal_point = find_teal_point(input_grid)\n    current_point = teal_point\n    while _check_boundary(input_grid, current_point):\n        input_grid = draw_upper_points_grey(input_grid, current_point)\n        current_point = move_up_two_points(input_grid, current_point)\n        if _check_boundary(input_grid, current_point) == False:\n            break\n        input_grid = draw_right_points_grey(input_grid, current_point)\n        current_point = move_right_two_points(input_grid, current_point)\n    current_point = teal_point\n    while _check_boundary(input_grid, current_point):\n        input_grid = draw_lower_points_grey(input_grid, current_point)\n        current_point = move_down_two_points(input_grid, current_point)\n        if _check_boundary(input_grid, current_point) == False:\n            break\n        input_grid = draw_left_points_grey(input_grid, current_point)\n        current_point = move_left_two_points(input_grid, current_point)\n    return input_grid"},
{"name": "d4a91cb9.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 2, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 2, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 2, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_black_pixels_with_yellow_in_column(input_grid: np.ndarray, x1: int, x2: int, y1: int) -> np.ndarray:\n    for i in range(x1, x2 + 1):\n        if input_grid[i][y1] == black:\n            input_grid[i][y1] = yellow\n    return input_grid\n\ndef replace_black_pixels_with_yellow(input_grid: np.ndarray, y1: int, y2: int, x2: int) -> np.ndarray:\n    for j in range(y1, y2 + 1):\n        if input_grid[x2][j] == black:\n            input_grid[x2][j] = yellow\n    return input_grid\n\ndef get_min_max(x: int, y: int) -> Tuple[int, int]:\n    return (min(x, y), max(x, y))\n\ndef find_red_pixel(input_grid: np.ndarray) -> Tuple[int, int]:\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                return (i, j)\n\ndef find_teal_pixel(input_grid: np.ndarray) -> Tuple[int, int]:\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == teal:\n                return (i, j)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    x1, y1 = find_teal_pixel(input_grid)\n    x2, y2 = find_red_pixel(input_grid)\n    a1, a2 = get_min_max(x1, x2)\n    b1, b2 = get_min_max(y1, y2)\n    out = replace_black_pixels_with_yellow(input_grid, b1, b2, x2)\n    out = replace_black_pixels_with_yellow_in_column(out, a1, a2, y1)\n    return out"},
{"name": "aedd82e4.json", "data": {"train": [{"input": [[0, 2, 2], [0, 2, 2], [2, 0, 0]], "output": [[0, 2, 2], [0, 2, 2], [1, 0, 0]]}, {"input": [[2, 2, 2, 0], [0, 2, 0, 0], [0, 0, 0, 2], [0, 2, 0, 0]], "output": [[2, 2, 2, 0], [0, 2, 0, 0], [0, 0, 0, 1], [0, 1, 0, 0]]}, {"input": [[2, 2, 0, 0], [0, 2, 0, 0], [2, 2, 0, 2], [0, 0, 0, 0], [0, 2, 2, 2]], "output": [[2, 2, 0, 0], [0, 2, 0, 0], [2, 2, 0, 1], [0, 0, 0, 0], [0, 2, 2, 2]]}, {"input": [[2, 2, 0], [2, 0, 2], [0, 2, 0]], "output": [[2, 2, 0], [2, 0, 1], [0, 1, 0]]}], "test": [{"input": [[2, 2, 0, 2], [0, 2, 0, 0], [0, 0, 2, 0], [2, 0, 0, 0], [0, 0, 2, 2]], "output": [[2, 2, 0, 1], [0, 2, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 2, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_red_pixels(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function returns a new grid after changing the color of some red pixels to blue.\n    If a red pixel has no red pixel up or down or left or right, then it is turned to blue.\n\n    Args:\n    input_grid (numpy.ndarray) : a two-dimensional numpy array containing the grid of pixels.\n\n    Returns:\n    numpy.ndarray : a new two-dimensional numpy array containing the updated grid.\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                if i == 0 or input_grid[i - 1][j] != red:\n                    if i == input_grid.shape[0] - 1 or input_grid[i + 1][j] != red:\n                        if j == 0 or input_grid[i][j - 1] != red:\n                            if j == input_grid.shape[1] - 1 or input_grid[i][j + 1] != red:\n                                input_grid[i][j] = blue\n    return input_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = change_red_pixels(input_grid)\n    return output_grid"},
{"name": "28e73c20.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 0, 3], [3, 0, 3, 3, 0, 3], [3, 0, 0, 0, 0, 3], [3, 3, 3, 3, 3, 3]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 3, 3, 0, 3], [3, 0, 0, 0, 0, 3, 0, 3], [3, 0, 3, 3, 0, 3, 0, 3], [3, 0, 3, 3, 3, 3, 0, 3], [3, 0, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 3, 3, 3, 3]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3], [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3], [3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 0, 3], [3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 3, 3, 3, 3, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 0, 0, 0, 3, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 0, 3, 3, 3, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 0, 0, 0, 0, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 3, 3, 3, 3, 3, 3, 0, 3, 0, 3], [3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3], [3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3], [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3], [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3], [3, 0, 3, 3, 3, 3, 3, 3, 3, 0, 3, 0, 3], [3, 0, 3, 0, 0, 0, 0, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 3, 3, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 0, 0, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 3, 3, 3, 3, 0, 3, 0, 3], [3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3], [3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3], [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 3, 3, 3, 3, 0, 3], [3, 0, 0, 0, 0, 0, 0, 3, 0, 3], [3, 0, 3, 3, 3, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 3, 0, 3, 0, 3], [3, 0, 3, 0, 0, 0, 0, 3, 0, 3], [3, 0, 3, 3, 3, 3, 3, 3, 0, 3], [3, 0, 0, 0, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3], [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3], [3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 0, 3], [3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 0, 3, 3, 3, 3, 0, 3, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 0, 3, 0, 3, 3, 0, 3, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 0, 3, 0, 0, 0, 0, 3, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 0, 3, 3, 3, 3, 3, 3, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 3], [3, 0, 3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3, 0, 3], [3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3], [3, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 3], [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_pixel_to_green(grid: np.ndarray, loc: Tuple[int, int]) -> np.ndarray:\n    row, col = loc\n    grid[row][col] = green\n    return grid\n\ndef follow_direction_if_not_green(grid: np.ndarray, loc: Tuple[int, int], dir: Tuple[int, int]) -> Tuple[np.ndarray, Tuple[int, int], Tuple[int, int]]:\n    while not is_next_pixel_valid(grid, loc, dir):\n        grid, loc = change_pixel_to_green_and_get_next_loc(grid, loc, dir)\n    return (grid, loc, dir)\n\ndef rotate_direction_clockwise(dir: Tuple[int, int]) -> Tuple[int, int]:\n    return (dir[1], -dir[0])\n\ndef change_pixel_to_green_and_get_next_loc(grid: np.ndarray, loc: Tuple[int, int], dir: Tuple[int, int]) -> Tuple[np.ndarray, Tuple[int, int]]:\n    row, col = loc\n    grid[row][col] = green\n    next_row, next_col = (row + dir[0], col + dir[1])\n    return (grid, (next_row, next_col))\n\ndef is_next_pixel_valid(grid: np.ndarray, loc: Tuple[int, int], dir: Tuple[int, int]) -> bool:\n    row, col = loc\n    next_row, next_col = (row + dir[0], col + dir[1])\n    if not (0 <= next_row < grid.shape[0] and 0 <= next_col < grid.shape[1]):\n        return True\n    if grid[next_row][next_col] == green:\n        return True\n    else:\n        next_row, next_col = (next_row + dir[0], next_col + dir[1])\n        if not (0 <= next_row < grid.shape[0] and 0 <= next_col < grid.shape[1]):\n            return False\n        if grid[next_row][next_col] == green:\n            return True\n    return False\n\ndef check_green_in_next_two_pixels(grid: np.ndarray, loc: Tuple[int, int], dir: Tuple[int, int]) -> bool:\n    row, col = loc\n    next_row, next_col = (row + dir[0], col + dir[1])\n    if not (0 <= next_row < grid.shape[0] and 0 <= next_col < grid.shape[1]):\n        return False\n    if grid[next_row][next_col] == green:\n        return True\n    else:\n        next_row, next_col = (next_row + dir[0], next_col + dir[1])\n        if not (0 <= next_row < grid.shape[0] and 0 <= next_col < grid.shape[1]):\n            return False\n        if grid[next_row][next_col] == green:\n            return True\n    return False\n\ndef get_right_direction() -> Tuple[int, int]:\n    return (0, 1)\n\ndef get_start_location() -> Tuple[int, int]:\n    return (0, 0)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    loc = get_start_location()\n    dir = get_right_direction()\n    out_grid = input_grid\n    while True:\n        if check_green_in_next_two_pixels(out_grid, loc, dir):\n            break\n        else:\n            while not is_next_pixel_valid(out_grid, loc, dir):\n                out_grid, loc = change_pixel_to_green_and_get_next_loc(out_grid, loc, dir)\n            dir = rotate_direction_clockwise(dir)\n    if follow_direction_if_not_green(out_grid, loc, dir):\n        out_grid = change_pixel_to_green(out_grid, loc)\n    return out_grid"},
{"name": "94f9d214.json", "data": {"train": [{"input": [[0, 0, 0, 0], [0, 3, 3, 0], [0, 0, 0, 0], [3, 0, 0, 3], [0, 0, 0, 1], [1, 0, 1, 1], [1, 1, 1, 1], [0, 1, 0, 1]], "output": [[2, 2, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 2, 0]]}, {"input": [[3, 3, 3, 3], [0, 3, 3, 0], [0, 0, 3, 3], [3, 0, 0, 0], [0, 0, 0, 1], [0, 0, 0, 1], [0, 1, 0, 0], [1, 0, 0, 1]], "output": [[0, 0, 0, 0], [2, 0, 0, 0], [2, 0, 0, 0], [0, 2, 2, 0]]}, {"input": [[0, 3, 3, 0], [0, 3, 0, 3], [0, 0, 3, 0], [3, 3, 3, 3], [1, 1, 1, 1], [1, 1, 0, 0], [1, 1, 0, 0], [0, 1, 1, 0]], "output": [[0, 0, 0, 0], [0, 0, 2, 0], [0, 0, 0, 2], [0, 0, 0, 0]]}, {"input": [[3, 3, 3, 3], [3, 0, 0, 0], [3, 0, 3, 3], [3, 3, 0, 3], [1, 1, 1, 0], [0, 1, 1, 1], [1, 0, 1, 1], [0, 1, 1, 1]], "output": [[0, 0, 0, 0], [0, 0, 0, 0], [0, 2, 0, 0], [0, 0, 0, 0]]}], "test": [{"input": [[0, 3, 0, 3], [3, 3, 3, 0], [0, 0, 0, 3], [3, 3, 3, 0], [0, 0, 1, 1], [0, 0, 1, 1], [0, 1, 0, 0], [1, 1, 0, 0]], "output": [[2, 0, 0, 0], [0, 0, 0, 0], [2, 0, 2, 0], [0, 0, 0, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef fill_intersection_with_red(output_grid: np.ndarray, intersection: List[Tuple[int, int]]) -> None:\n    for pixel in intersection:\n        output_grid[pixel[0]][pixel[1]] = red\n\ndef find_intersection(black_pixels_top: List[Tuple[int, int]], black_pixels_bottom: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    intersection = []\n    for pixel_top in black_pixels_top:\n        if pixel_top in black_pixels_bottom:\n            intersection.append(pixel_top)\n    return intersection\n\ndef find_black_pixels(grid: np.ndarray) -> List[Tuple[int, int]]:\n    black_pixels = []\n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if grid[i][j] == black:\n                black_pixels.append((i, j))\n    return black_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    top_grid = input_grid[:4, :]\n    bottom_grid = input_grid[4:, :]\n    black_pixels_top = find_black_pixels(top_grid)\n    black_pixels_bottom = find_black_pixels(bottom_grid)\n    output_grid = np.zeros([4, 4])\n    intersection = find_intersection(black_pixels_top, black_pixels_bottom)\n    fill_intersection_with_red(output_grid, intersection)\n    return output_grid"},
{"name": "4258a5f9.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 1, 5, 1, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 5, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 5, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0, 1, 5, 1], [0, 0, 1, 5, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 5, 1], [0, 0, 1, 1, 1, 0, 1, 1, 1], [0, 0, 1, 5, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 5, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 5, 1], [0, 0, 1, 1, 1, 0, 1, 1, 1], [0, 0, 1, 5, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 0], [1, 5, 1, 0, 1, 5, 1, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef exists_grey_square(grid: List[List[int]]) -> bool:\n    \"\"\"\n    Checks if there exists a square in the grid which color is grey.\n    \n    Args:\n    - grid: a 2D list of integers representing the grid\n    \n    Returns:\n    - a boolean value indicating whether there exists a grey square in the grid\n    \"\"\"\n    for row in grid:\n        for square in row:\n            if square == grey:\n                return True\n    return False\n\ndef transform_grid(input_grid):\n    output_grid = [[0 for i in range(9)] for j in range(9)]\n    for i in range(len(input_grid)):\n        for j in range(len(input_grid[i])):\n            if input_grid[i][j] == 5:\n                output_grid[i][j] = input_grid[i][j]\n            elif exists_grey_square(input_grid[max(i - 1, 0):min(i + 2, 9), max(0, j - 1):min(j + 2, 9)]):\n                output_grid[i][j] = 1\n            else:\n                output_grid[i][j] = input_grid[i][j]\n    return output_grid"},
{"name": "05269061.json", "data": {"train": [{"input": [[2, 8, 3, 0, 0, 0, 0], [8, 3, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], "output": [[2, 8, 3, 2, 8, 3, 2], [8, 3, 2, 8, 3, 2, 8], [3, 2, 8, 3, 2, 8, 3], [2, 8, 3, 2, 8, 3, 2], [8, 3, 2, 8, 3, 2, 8], [3, 2, 8, 3, 2, 8, 3], [2, 8, 3, 2, 8, 3, 2]]}, {"input": [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 2], [0, 0, 0, 0, 1, 2, 4], [0, 0, 0, 1, 2, 4, 0], [0, 0, 1, 2, 4, 0, 0]], "output": [[2, 4, 1, 2, 4, 1, 2], [4, 1, 2, 4, 1, 2, 4], [1, 2, 4, 1, 2, 4, 1], [2, 4, 1, 2, 4, 1, 2], [4, 1, 2, 4, 1, 2, 4], [1, 2, 4, 1, 2, 4, 1], [2, 4, 1, 2, 4, 1, 2]]}, {"input": [[0, 0, 0, 0, 8, 3, 0], [0, 0, 0, 8, 3, 0, 0], [0, 0, 8, 3, 0, 0, 0], [0, 8, 3, 0, 0, 0, 4], [8, 3, 0, 0, 0, 4, 0], [3, 0, 0, 0, 4, 0, 0], [0, 0, 0, 4, 0, 0, 0]], "output": [[4, 8, 3, 4, 8, 3, 4], [8, 3, 4, 8, 3, 4, 8], [3, 4, 8, 3, 4, 8, 3], [4, 8, 3, 4, 8, 3, 4], [8, 3, 4, 8, 3, 4, 8], [3, 4, 8, 3, 4, 8, 3], [4, 8, 3, 4, 8, 3, 4]]}], "test": [{"input": [[0, 1, 0, 0, 0, 0, 2], [1, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 4], [2, 0, 0, 0, 0, 4, 0]], "output": [[2, 1, 4, 2, 1, 4, 2], [1, 4, 2, 1, 4, 2, 1], [4, 2, 1, 4, 2, 1, 4], [2, 1, 4, 2, 1, 4, 2], [1, 4, 2, 1, 4, 2, 1], [4, 2, 1, 4, 2, 1, 4], [2, 1, 4, 2, 1, 4, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef get_color_coordinate(input_grid: np.ndarray, color: int) -> Tuple[int, int]:\n    \"\"\"\n    This function takes in a numpy array of shape (7, 7) and a color integer and returns the coordinate of the first occurrence of the color in the input.\n\n    Args:\n    input_grid: A numpy array of shape (7, 7) containing integers from 0 to 9.\n    color: An integer representing the color to search for.\n\n    Returns:\n    A tuple of two integers representing the coordinate of the first occurrence of the color in the input.\n    \"\"\"\n    for i in range(7):\n        for j in range(7):\n            if input_grid[i][j] == color:\n                return (i, j)\n    return (-1, -1)\n\ndef get_non_black_colors(input_grid: np.ndarray) -> Tuple[int, int, int]:\n    \"\"\"\n    This function takes in a numpy array of shape (7, 7) and returns a tuple of three non-black colors present in the input.\n\n    Args:\n    input_grid: A numpy array of shape (7, 7) containing integers from 0 to 9.\n\n    Returns:\n    A tuple of three integers representing the non-black colors present in the input.\n    \"\"\"\n    non_black_colors = set(np.unique(input_grid)) - {black}\n    return tuple(non_black_colors)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.zeros((7, 7), dtype=int)\n    color1, color2, color3 = get_non_black_colors(input_grid)\n    for color in (color1, color2, color3):\n        x, y = get_color_coordinate(input_grid, color)\n        if (x + y) % 3 == 0:\n            c1 = color\n        elif (x + y) % 3 == 1:\n            c2 = color\n        else:\n            c3 = color\n    for i in range(7):\n        for j in range(7):\n            if (i + j) % 3 == 0:\n                output_grid[i][j] = c1\n            elif (i + j) % 3 == 1:\n                output_grid[i][j] = c2\n            else:\n                output_grid[i][j] = c3\n    return output_grid"},
{"name": "e3497940.json", "data": {"train": [{"input": [[0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 4, 5, 0, 0, 0, 0], [0, 0, 0, 4, 5, 4, 4, 0, 0], [0, 0, 3, 3, 5, 0, 0, 0, 0], [0, 0, 0, 3, 5, 0, 0, 0, 0], [0, 0, 0, 3, 5, 3, 3, 3, 0], [0, 0, 0, 3, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0]], "output": [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 4], [0, 0, 4, 4], [0, 0, 3, 3], [0, 0, 0, 3], [0, 3, 3, 3], [0, 0, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 2, 5, 2, 6, 0, 0], [0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 2, 5, 2, 2, 2, 0], [0, 0, 6, 6, 5, 6, 0, 0, 0], [0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 2, 2, 0, 5, 2, 0, 0, 0], [0, 0, 0, 2, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0]], "output": [[0, 0, 0, 0], [0, 0, 0, 2], [0, 0, 6, 2], [0, 0, 0, 2], [0, 2, 2, 2], [0, 0, 6, 6], [0, 0, 0, 2], [0, 2, 2, 2], [0, 0, 0, 2], [0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 0, 0, 0], [0, 0, 0, 8, 5, 0, 0, 0, 0], [0, 0, 0, 8, 5, 0, 0, 0, 0], [0, 7, 8, 8, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 8, 8, 0, 0], [0, 0, 0, 8, 5, 0, 0, 0, 0], [0, 0, 0, 8, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 8, 7, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0]], "output": [[0, 0, 0, 0], [0, 0, 0, 7], [0, 0, 0, 8], [0, 0, 0, 8], [0, 7, 8, 8], [0, 0, 8, 8], [0, 0, 0, 8], [0, 0, 0, 8], [0, 0, 7, 8], [0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 1, 5, 0, 0, 0, 0], [0, 0, 0, 1, 5, 1, 0, 0, 0], [0, 1, 1, 1, 5, 1, 1, 1, 6], [0, 0, 0, 6, 5, 6, 6, 0, 0], [0, 0, 0, 0, 5, 1, 1, 1, 0], [0, 0, 0, 1, 5, 0, 0, 0, 0], [0, 0, 0, 1, 5, 1, 6, 0, 0], [0, 0, 0, 0, 5, 6, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0]], "output": [[0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 0, 1], [6, 1, 1, 1], [0, 0, 6, 6], [0, 1, 1, 1], [0, 0, 0, 1], [0, 0, 6, 1], [0, 0, 0, 6], [0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef put_right_part_over_black_pixels(flipped_right_part: np.ndarray, left_part: np.ndarray) -> np.ndarray:\n    black_pixels = left_part == black\n    left_part[black_pixels] = flipped_right_part[black_pixels]\n    return left_part\n\ndef flip_horizontally(input_grid: np.ndarray) -> np.ndarray:\n    return np.fliplr(input_grid)\n\ndef divide_with_grey_column(input_grid: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    grey_column = input_grid[:, input_grid.shape[1] // 2]\n    left_part = input_grid[:, :input_grid.shape[1] // 2]\n    right_part = input_grid[:, input_grid.shape[1] // 2 + 1:]\n    return (left_part, right_part)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    left_part, right_part = divide_with_grey_column(input_grid)\n    flipped_right_part = flip_horizontally(right_part)\n    left_part = put_right_part_over_black_pixels(flipped_right_part, left_part)\n    return left_part"},
{"name": "6d0aefbc.json", "data": {"train": [{"input": [[6, 6, 6], [1, 6, 1], [8, 8, 6]], "output": [[6, 6, 6, 6, 6, 6], [1, 6, 1, 1, 6, 1], [8, 8, 6, 6, 8, 8]]}, {"input": [[6, 8, 1], [6, 1, 1], [1, 1, 6]], "output": [[6, 8, 1, 1, 8, 6], [6, 1, 1, 1, 1, 6], [1, 1, 6, 6, 1, 1]]}, {"input": [[1, 1, 1], [8, 1, 6], [6, 8, 8]], "output": [[1, 1, 1, 1, 1, 1], [8, 1, 6, 6, 1, 8], [6, 8, 8, 8, 8, 6]]}, {"input": [[1, 1, 1], [1, 6, 6], [6, 6, 6]], "output": [[1, 1, 1, 1, 1, 1], [1, 6, 6, 6, 6, 1], [6, 6, 6, 6, 6, 6]]}], "test": [{"input": [[6, 8, 6], [8, 6, 8], [1, 6, 1]], "output": [[6, 8, 6, 6, 8, 6], [8, 6, 8, 8, 6, 8], [1, 6, 1, 1, 6, 1]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef assign_input_to_right_half(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    output_grid[:, 3:] = input_grid\n    return output_grid\n\ndef flip_left_to_right(input_grid: np.ndarray) -> np.ndarray:\n    return np.fliplr(input_grid)\n\ndef assign_input_to_left_half(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    output_grid[:, :3] = input_grid\n    return output_grid\n\ndef create_image_matrix() -> np.ndarray:\n    return np.zeros((3, 6))\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = create_image_matrix()\n    output_grid = assign_input_to_left_half(output_grid, input_grid)\n    input_grid = flip_left_to_right(input_grid)\n    output_grid = assign_input_to_right_half(output_grid, input_grid)\n    return output_grid"},
{"name": "e26a3af2.json", "data": {"train": [{"input": [[1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 8, 2], [9, 5, 1, 5, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [4, 1, 1, 2, 1, 8, 8, 5, 3, 3, 8, 3, 2, 8, 2, 2, 7], [1, 1, 1, 1, 1, 8, 8, 2, 3, 3, 3, 3, 2, 2, 2, 2, 2], [9, 1, 1, 1, 8, 8, 8, 8, 3, 3, 4, 3, 8, 2, 2, 2, 2], [4, 1, 2, 1, 1, 7, 8, 8, 3, 3, 3, 3, 2, 2, 6, 2, 9], [1, 1, 1, 1, 9, 8, 8, 8, 9, 3, 3, 3, 4, 2, 6, 2, 2], [1, 1, 1, 1, 1, 8, 5, 8, 3, 3, 3, 4, 2, 2, 2, 2, 3], [1, 1, 1, 9, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [6, 1, 1, 8, 1, 5, 8, 8, 4, 3, 3, 3, 6, 4, 2, 2, 7], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 6, 2, 2], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 7, 3, 2, 2, 2, 2, 2], [1, 2, 1, 4, 1, 8, 8, 8, 3, 3, 3, 3, 2, 9, 2, 1, 2]], "output": [[1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 8, 8, 8, 3, 3, 3, 3, 2, 2, 2, 2, 2]]}, {"input": [[2, 2, 2, 2, 2, 8, 8, 1, 8, 8, 8, 1, 1, 1], [2, 2, 8, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 9, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 9, 8, 6, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 5, 1, 1, 1], [2, 2, 2, 6, 2, 8, 8, 8, 8, 8, 5, 1, 1, 6], [2, 6, 4, 2, 2, 9, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 6, 8, 7, 8, 8, 8, 1, 1, 2], [2, 2, 2, 6, 2, 8, 3, 8, 5, 8, 8, 3, 1, 1], [2, 2, 2, 2, 5, 8, 2, 8, 5, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 1, 3], [2, 8, 2, 2, 2, 8, 8, 8, 8, 3, 8, 9, 1, 1]], "output": [[2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1], [2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 1, 1, 1]]}, {"input": [[3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 2, 3, 3, 2, 3, 3, 3, 3, 3], [3, 3, 3, 9, 3, 3, 3, 2, 3, 3, 3, 9, 3, 3], [3, 3, 4, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3], [7, 7, 7, 7, 7, 7, 8, 7, 7, 3, 3, 7, 7, 4], [9, 7, 7, 7, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 2], [7, 7, 7, 7, 7, 5, 7, 7, 7, 7, 7, 7, 5, 8], [7, 7, 7, 7, 7, 7, 3, 7, 7, 7, 7, 2, 7, 7], [7, 7, 7, 4, 6, 7, 7, 7, 7, 7, 9, 7, 7, 7], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 8, 8], [8, 8, 8, 4, 8, 8, 8, 7, 9, 8, 8, 8, 8, 8], [1, 1, 1, 5, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 1, 1, 1]], "output": [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]}], "test": [{"input": [[6, 1, 1, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 4, 1, 1, 9, 1, 1, 1, 1, 5, 1, 1, 1, 1, 1], [5, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [7, 2, 2, 2, 2, 6, 2, 9, 2, 2, 4, 2, 4, 2, 2], [2, 2, 9, 2, 1, 2, 2, 2, 3, 2, 2, 8, 2, 7, 2], [2, 5, 2, 2, 5, 6, 6, 2, 2, 2, 3, 2, 5, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 2, 8, 2, 2], [1, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 7, 8, 8, 8, 9], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 4, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 5, 8, 8, 8, 1, 8, 8], [4, 4, 4, 4, 4, 4, 7, 3, 4, 4, 4, 4, 4, 2, 4], [4, 4, 7, 4, 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4], [3, 3, 1, 9, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [8, 6, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]], "output": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef rotate_270(grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Rotate the input grid by 270 degrees.\n    :param grid: 2D numpy array representing the input grid\n    :return: 2D numpy array representing the rotated grid\n    \"\"\"\n    return np.rot90(grid, k=3)\n\ndef extend_column_to_grid(column: np.ndarray, n: int) -> np.ndarray:\n    \"\"\"\n    Extend a column to a grid with n columns.\n    :param column: 1D numpy array representing the column to be extended\n    :param n: integer representing the number of columns in the output grid\n    :return: 2D numpy array representing the output grid\n    \"\"\"\n    return np.tile(column, (n, 1)).T\n\ndef rotate_if_needed(input_grid: np.ndarray, colors: List[int]) -> Tuple[bool, np.ndarray]:\n    \"\"\"\n    If the most frequent color in each row occurs less than 50% of the time, rotate the input grid by 90 degrees.\n    :param input_grid: 2D numpy array representing the input grid\n    :param colors: List of most frequent colors in each row\n    :return: Tuple of boolean indicating whether the grid was rotated and the rotated grid\n    \"\"\"\n    threshold = input_grid.shape[1] // 2\n    has_rotate = False\n    for i, row in enumerate(input_grid):\n        if np.count_nonzero(row == colors[i]) < threshold:\n            input_grid = np.rot90(input_grid)\n            has_rotate = True\n            break\n    return (has_rotate, input_grid)\n\ndef find_most_frequent_color_in_row(grid: np.ndarray) -> List[int]:\n    \"\"\"\n    Find the color with the most occurrences in each row of the input grid.\n    :param grid: 2D numpy array representing the input grid\n    :return: List of integers representing the most frequent color in each row\n    \"\"\"\n    return [np.bincount(row).argmax() for row in grid]\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    colors = find_most_frequent_color_in_row(input_grid)\n    has_rotate, input_grid = rotate_if_needed(input_grid, colors)\n    colors = find_most_frequent_color_in_row(input_grid)\n    output_grid = extend_column_to_grid(np.array(colors), n=input_grid.shape[1])\n    if has_rotate:\n        output_grid = rotate_270(output_grid)\n    return output_grid"},
{"name": "5bd6f4ac.json", "data": {"train": [{"input": [[3, 0, 0, 7, 0, 0, 9, 7, 0], [8, 4, 0, 6, 6, 0, 4, 8, 4], [1, 7, 0, 0, 0, 0, 4, 0, 0], [1, 1, 0, 9, 1, 0, 7, 0, 0], [0, 0, 0, 0, 7, 7, 0, 0, 0], [8, 0, 0, 1, 7, 0, 8, 4, 0], [0, 7, 0, 9, 9, 2, 1, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 2, 4, 0, 8, 0, 0]], "output": [[9, 7, 0], [4, 8, 4], [4, 0, 0]]}, {"input": [[9, 0, 0, 0, 0, 0, 0, 6, 0], [0, 4, 0, 7, 0, 5, 0, 8, 1], [0, 2, 0, 0, 7, 1, 4, 4, 5], [0, 6, 0, 0, 4, 0, 0, 0, 0], [8, 3, 0, 4, 2, 0, 0, 9, 7], [0, 0, 2, 3, 0, 2, 0, 6, 7], [4, 0, 4, 0, 3, 4, 7, 0, 7], [7, 1, 0, 0, 0, 0, 3, 0, 0], [3, 2, 0, 0, 4, 0, 0, 0, 0]], "output": [[0, 6, 0], [0, 8, 1], [4, 4, 5]]}, {"input": [[2, 5, 0, 0, 6, 0, 0, 0, 0], [2, 5, 5, 7, 0, 0, 6, 0, 1], [0, 3, 0, 0, 0, 1, 9, 4, 0], [0, 7, 0, 6, 0, 0, 0, 0, 0], [0, 9, 0, 0, 0, 1, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 4], [0, 5, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0], [6, 0, 1], [9, 4, 0]]}, {"input": [[0, 5, 0, 0, 8, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0, 3], [0, 1, 0, 0, 0, 0, 3, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 4, 0, 0, 0, 0, 0], [3, 0, 7, 0, 0, 2, 0, 0, 6]], "output": [[0, 0, 4], [3, 0, 0], [0, 0, 3]]}], "test": [{"input": [[6, 9, 0, 0, 1, 0, 5, 8, 9], [2, 9, 0, 6, 0, 8, 0, 9, 0], [0, 0, 0, 0, 0, 9, 9, 2, 0], [9, 2, 6, 0, 0, 8, 0, 6, 8], [7, 7, 4, 0, 7, 0, 9, 0, 0], [0, 0, 7, 0, 0, 1, 5, 7, 4], [4, 1, 0, 0, 7, 5, 0, 0, 9], [9, 9, 0, 0, 0, 0, 1, 0, 0], [4, 9, 2, 0, 0, 0, 8, 4, 0]], "output": [[5, 8, 9], [0, 9, 0], [9, 2, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_upper_right_corner_pixels(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given an input grid, this function returns a 3x3 numpy array containing the nine pixels in the upper right corner.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A 3x3 numpy array containing the nine pixels in the upper right corner.\n    \"\"\"\n    return input_grid[:3, -3:]\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    out = np.zeros((3, 3), dtype=int)\n    out = find_upper_right_corner_pixels(input_grid)\n    return out"},
{"name": "ce9e57f2.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 2, 0, 0, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 2, 0, 0, 0], [0, 8, 0, 2, 0, 2, 0, 2, 0], [0, 8, 0, 8, 0, 8, 0, 2, 0], [0, 8, 0, 8, 0, 8, 0, 8, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 2, 0, 0, 0, 2, 0], [0, 2, 0, 2, 0, 0, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 2, 0, 0, 0, 2, 0], [0, 2, 0, 2, 0, 0, 0, 2, 0], [0, 8, 0, 2, 0, 2, 0, 8, 0], [0, 8, 0, 8, 0, 2, 0, 8, 0], [0, 8, 0, 8, 0, 8, 0, 8, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 2, 0, 8, 0], [0, 8, 0, 2, 0, 2, 0, 8, 0], [0, 8, 0, 2, 0, 8, 0, 8, 0], [0, 8, 0, 8, 0, 8, 0, 8, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 2, 0], [0, 2, 0, 2, 0, 0, 0, 2, 0], [0, 2, 0, 2, 0, 0, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0], [0, 8, 0, 2, 0, 0, 0, 2, 0], [0, 8, 0, 8, 0, 0, 0, 2, 0], [0, 8, 0, 8, 0, 0, 0, 2, 0], [0, 8, 0, 8, 0, 2, 0, 8, 0], [0, 8, 0, 8, 0, 8, 0, 8, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Traverse each column, count how many red pixels are in each column. Divide this number by 2 and denote it as cnt. Change the cnt pixels at the bottom of the column to teal. Return the changed grid.\n    \"\"\"\n    height, width = input_grid.shape\n    for j in range(width):\n        red_count = 0\n        for i in range(height):\n            if input_grid[i][j] == red:\n                red_count += 1\n        cnt = red_count // 2\n        for i in range(height - 1, height - 1 - cnt, -1):\n            input_grid[i][j] = teal\n    return input_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    ngrid = change_grid(input_grid)\n    return ngrid"},
{"name": "7447852a.json", "data": {"train": [{"input": [[2, 0, 0, 0, 2, 0, 0, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2], [0, 0, 2, 0, 0, 0, 2, 0, 0, 0]], "output": [[2, 0, 0, 0, 2, 4, 4, 4, 2, 0], [4, 2, 0, 2, 0, 2, 4, 2, 0, 2], [4, 4, 2, 0, 0, 0, 2, 0, 0, 0]]}, {"input": [[2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2]], "output": [[2, 0, 0, 0, 2, 4, 4, 4, 2, 0, 0, 0, 2, 0, 0], [4, 2, 0, 2, 0, 2, 4, 2, 0, 2, 0, 2, 4, 2, 0], [4, 4, 2, 0, 0, 0, 2, 0, 0, 0, 2, 4, 4, 4, 2]]}, {"input": [[2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2], [0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0]], "output": [[2, 0, 0, 0, 2, 4, 4, 4, 2, 0, 0, 0, 2, 0, 0, 0, 2, 4], [4, 2, 0, 2, 0, 2, 4, 2, 0, 2, 0, 2, 4, 2, 0, 2, 0, 2], [4, 4, 2, 0, 0, 0, 2, 0, 0, 0, 2, 4, 4, 4, 2, 0, 0, 0]]}], "test": [{"input": [[2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0], [0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0]], "output": [[2, 0, 0, 0, 2, 4, 4, 4, 2, 0, 0, 0, 2, 0, 0, 0, 2, 4, 4, 4, 2, 0, 0, 0, 2], [4, 2, 0, 2, 0, 2, 4, 2, 0, 2, 0, 2, 4, 2, 0, 2, 0, 2, 4, 2, 0, 2, 0, 2, 4], [4, 4, 2, 0, 0, 0, 2, 0, 0, 0, 2, 4, 4, 4, 2, 0, 0, 0, 2, 0, 0, 0, 2, 4, 4]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_last_three_black_with_yellow(arr: np.ndarray) -> np.ndarray:\n    for i in range(2, len(arr), 12):\n        arr[i + 9:i + 12] = yellow\n    return arr\n\ndef replace_black_with_yellow_in_first_two(arr: np.ndarray) -> np.ndarray:\n    for i in range(0, 2):\n        if arr[i] == black:\n            arr[i] = yellow\n    return arr\n\ndef replace_black_with_yellow_in_last_three(arr: np.ndarray) -> np.ndarray:\n    output_grid = replace_black_with_yellow_in_first_two(arr)\n    output_grid = replace_last_three_black_with_yellow(output_grid)\n    return output_grid\n\ndef replace_black_with_yellow_in_avg_six(arr: np.ndarray) -> np.ndarray:\n    for i in range(0, len(arr), 6):\n        arr[i:i + 1] = yellow\n    return arr\n\ndef replace_black_with_yellow(arr: np.ndarray) -> np.ndarray:\n    for i in range(5, len(arr), 12):\n        arr[i:i + 3] = yellow\n    return arr\n\ndef create_new_grid(input_grid: np.ndarray) -> np.ndarray:\n    return np.zeros_like(input_grid)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = create_new_grid(input_grid)\n    output_grid[0] = replace_black_with_yellow(input_grid[0])\n    output_grid[1] = replace_black_with_yellow_in_avg_six(input_grid[1])\n    output_grid[2] = replace_black_with_yellow_in_last_three(input_grid[2])\n    return output_grid"},
{"name": "28bf18c6.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 8, 0, 8, 8, 0], [0, 8, 0, 0, 8, 0], [8, 8, 8, 8, 8, 8]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0]], "output": [[0, 2, 0, 0, 2, 0], [2, 2, 2, 2, 2, 2], [2, 2, 0, 2, 2, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 1, 1, 0, 1, 1], [1, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 3, 0, 0, 3], [3, 3, 3, 3, 3, 3], [3, 0, 0, 3, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_smallest_rect(non_black_pixels: List[Tuple[int, int]], input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns the smallest rectangle which contains all of the non-black pixels in the input grid.\n    \n    Args:\n    non_black_pixels: A list of tuples representing the non-black pixels in the input grid.\n    Each tuple contains the row and column indices of a non-black pixel.\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A numpy array representing the smallest rectangle which contains all of the non-black pixels in the input grid.\n    \"\"\"\n    min_row = min([pixel[0] for pixel in non_black_pixels])\n    max_row = max([pixel[0] for pixel in non_black_pixels])\n    min_col = min([pixel[1] for pixel in non_black_pixels])\n    max_col = max([pixel[1] for pixel in non_black_pixels])\n    smallest_rect = input_grid[min_row:max_row + 1, min_col:max_col + 1]\n    return smallest_rect\n\ndef get_non_black_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Returns a list of non-black pixels in the input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of tuples representing the non-black pixels in the input grid.\n    Each tuple contains the row and column indices of a non-black pixel.\n    \"\"\"\n    non_black_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black:\n                non_black_pixels.append((i, j))\n    return non_black_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    non_black_pixels = get_non_black_pixels(input_grid)\n    smallest_rect = find_smallest_rect(non_black_pixels, input_grid)\n    output_grid = np.concatenate([smallest_rect, smallest_rect], axis=1)\n    return output_grid"},
{"name": "ae4f1146.json", "data": {"train": [{"input": [[8, 8, 8, 0, 0, 0, 0, 0, 0], [1, 8, 8, 0, 8, 1, 8, 0, 0], [8, 8, 8, 0, 1, 1, 8, 0, 0], [0, 0, 0, 0, 8, 8, 8, 0, 0], [0, 8, 8, 1, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 8, 1, 8], [0, 8, 1, 8, 0, 0, 1, 8, 1], [0, 0, 0, 0, 0, 0, 1, 8, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 1, 8], [1, 8, 1], [1, 8, 1]]}, {"input": [[0, 8, 8, 1, 0, 0, 0, 0, 0], [0, 8, 1, 8, 0, 8, 1, 8, 0], [0, 8, 8, 8, 0, 1, 8, 8, 0], [0, 0, 0, 0, 0, 8, 8, 1, 0], [0, 0, 8, 1, 8, 0, 0, 0, 0], [0, 0, 1, 1, 8, 0, 0, 0, 0], [0, 0, 8, 8, 1, 0, 8, 8, 8], [0, 0, 0, 0, 0, 0, 8, 8, 8], [0, 0, 0, 0, 0, 0, 1, 8, 8]], "output": [[8, 1, 8], [1, 1, 8], [8, 8, 1]]}, {"input": [[0, 0, 0, 0, 8, 8, 8, 0, 0], [8, 8, 8, 0, 8, 8, 8, 0, 0], [8, 8, 8, 0, 1, 8, 8, 0, 0], [8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 1, 8], [8, 1, 8, 0, 0, 0, 1, 1, 8], [8, 8, 1, 0, 0, 0, 1, 8, 1], [1, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 1, 8], [1, 1, 8], [1, 8, 1]]}, {"input": [[0, 0, 1, 1, 8, 0, 0, 0, 0], [0, 0, 8, 8, 1, 0, 8, 1, 1], [0, 0, 1, 1, 8, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 8, 1, 8], [8, 8, 8, 0, 0, 0, 0, 0, 0], [8, 8, 1, 0, 8, 1, 8, 0, 0], [1, 8, 8, 0, 1, 8, 8, 0, 0], [0, 0, 0, 0, 8, 8, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 1, 1], [1, 1, 1], [8, 1, 8]]}], "test": [{"input": [[8, 8, 8, 0, 0, 0, 8, 1, 8], [8, 8, 8, 0, 0, 0, 1, 8, 1], [1, 8, 8, 0, 0, 0, 8, 1, 8], [0, 0, 0, 8, 1, 8, 0, 0, 0], [0, 0, 0, 8, 8, 1, 0, 0, 0], [0, 0, 0, 1, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 8], [0, 0, 0, 0, 0, 0, 8, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 8]], "output": [[1, 1, 8], [8, 1, 1], [1, 1, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_3x3_pixels(input_grid: np.ndarray, loc: Tuple[int, int]) -> np.ndarray:\n    return input_grid[loc[0] - 1:loc[0] + 2, loc[1] - 1:loc[1] + 2]\n\ndef find_most_blue_pixels(input_grid: np.ndarray, locs: List[Tuple[int, int]], blue_counts: List[int]) -> Tuple[int, int]:\n    max_count = -1\n    max_loc = None\n    for i, loc in enumerate(locs):\n        if blue_counts[i] > max_count:\n            max_count = blue_counts[i]\n            max_loc = loc\n    return max_loc\n\ndef count_blue_pixels(input_grid: np.ndarray, locs: List[Tuple[int, int]]) -> List[int]:\n    blue_counts = []\n    for loc in locs:\n        i, j = loc\n        blue_counts.append(np.sum(input_grid[i - 1:i + 2, j - 1:j + 2] == blue))\n    return blue_counts\n\ndef find_non_black_3x3_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    locs = []\n    for i in range(input_grid.shape[0] - 2):\n        for j in range(input_grid.shape[1] - 2):\n            if np.all(input_grid[i:i + 3, j:j + 3] != black):\n                locs.append((i + 1, j + 1))\n    return locs\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    locs = find_non_black_3x3_pixels(input_grid)\n    n = count_blue_pixels(input_grid, locs)\n    loc = find_most_blue_pixels(input_grid, locs, n)\n    out_grid = find_3x3_pixels(input_grid, loc)\n    return out_grid"},
{"name": "aabf363d.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0], [0, 2, 2, 2, 2, 0, 0], [0, 0, 2, 2, 2, 0, 0], [0, 0, 0, 2, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0], [0, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 0, 0], [0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0], [0, 0, 3, 3, 3, 0, 0], [0, 3, 3, 3, 3, 0, 0], [0, 3, 3, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0], [6, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0], [0, 0, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 0, 0], [0, 6, 6, 0, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0], [0, 8, 8, 8, 8, 8, 0], [0, 0, 0, 8, 8, 0, 0], [0, 0, 8, 8, 0, 0, 0], [0, 0, 8, 8, 8, 0, 0], [2, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 0, 0, 0], [0, 2, 2, 2, 2, 2, 0], [0, 0, 0, 2, 2, 0, 0], [0, 0, 2, 2, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_bottom_left_color_with_black(input_grid: np.ndarray) -> np.ndarray:\n    rows, cols = input_grid.shape\n    input_grid[rows - 1, 0] = black\n    return input_grid\n\ndef replace_colors(input_grid: np.ndarray) -> np.ndarray:\n    rows, cols = input_grid.shape\n    bottom_left_color = input_grid[rows - 1, 0]\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i, j] != black:\n                input_grid[i, j] = bottom_left_color\n    return input_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    out = replace_colors(input_grid)\n    out = replace_bottom_left_color_with_black(out)\n    return out"},
{"name": "ea786f4a.json", "data": {"train": [{"input": [[1, 1, 1], [1, 0, 1], [1, 1, 1]], "output": [[0, 1, 0], [1, 0, 1], [0, 1, 0]]}, {"input": [[2, 2, 2, 2, 2], [2, 2, 2, 2, 2], [2, 2, 0, 2, 2], [2, 2, 2, 2, 2], [2, 2, 2, 2, 2]], "output": [[0, 2, 2, 2, 0], [2, 0, 2, 0, 2], [2, 2, 0, 2, 2], [2, 0, 2, 0, 2], [0, 2, 2, 2, 0]]}, {"input": [[3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 0, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3]], "output": [[0, 3, 3, 3, 3, 3, 0], [3, 0, 3, 3, 3, 0, 3], [3, 3, 0, 3, 0, 3, 3], [3, 3, 3, 0, 3, 3, 3], [3, 3, 0, 3, 0, 3, 3], [3, 0, 3, 3, 3, 0, 3], [0, 3, 3, 3, 3, 3, 0]]}], "test": [{"input": [[6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 0, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6]], "output": [[0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0], [6, 0, 6, 6, 6, 6, 6, 6, 6, 0, 6], [6, 6, 0, 6, 6, 6, 6, 6, 0, 6, 6], [6, 6, 6, 0, 6, 6, 6, 0, 6, 6, 6], [6, 6, 6, 6, 0, 6, 0, 6, 6, 6, 6], [6, 6, 6, 6, 6, 0, 6, 6, 6, 6, 6], [6, 6, 6, 6, 0, 6, 0, 6, 6, 6, 6], [6, 6, 6, 0, 6, 6, 6, 0, 6, 6, 6], [6, 6, 0, 6, 6, 6, 6, 6, 0, 6, 6], [6, 0, 6, 6, 6, 6, 6, 6, 6, 0, 6], [0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_diagonal_lines_black(input_grid: np.ndarray) -> np.ndarray:\n    output = np.copy(input_grid)\n    n = input_grid.shape[0]\n    for i in range(n):\n        output[i, i] = black\n        output[i, n - i - 1] = black\n    return output\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output = color_diagonal_lines_black(input_grid)\n    return output"},
{"name": "760b3cac.json", "data": {"train": [{"input": [[0, 0, 0, 8, 0, 8, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0]], "output": [[8, 0, 8, 8, 0, 8, 0, 0, 0], [8, 8, 0, 0, 8, 8, 0, 0, 0], [8, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 8, 0, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0]], "output": [[0, 0, 0, 8, 0, 8, 8, 0, 8], [0, 0, 0, 8, 8, 8, 8, 8, 8], [0, 0, 0, 8, 8, 0, 0, 8, 8], [0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0]], "output": [[0, 0, 8, 8, 0, 0, 0, 0, 0], [8, 8, 0, 0, 8, 8, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 8, 0, 8, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0]], "output": [[0, 0, 0, 8, 0, 8, 8, 0, 8], [0, 0, 0, 0, 8, 8, 8, 8, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef right_symmetric(blue_pixels: List[Tuple[int, int]], origin_area: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    for pixel in blue_pixels:\n        i, j = pixel\n        output_grid[i, 8 - j] = origin_area[i, j]\n    return output_grid\n\ndef left_symmetric(blue_pixels: List[Tuple[int, int]], origin_area: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    for pixel in blue_pixels:\n        i, j = pixel\n        output_grid[i, 2 - j] = origin_area[i, j]\n    return output_grid\n\ndef find_teal_pixels(origin_area: np.ndarray) -> List[Tuple[int, int]]:\n    teal_pixels = []\n    for i in range(3):\n        for j in range(3):\n            if origin_area[i, j] == teal:\n                teal_pixels.append((i, j))\n    return teal_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = input_grid.copy()\n    origin_area = input_grid[0:3, 3:6]\n    blue_pixels = find_teal_pixels(origin_area)\n    if input_grid[3:6, 3:6][0, 0] == yellow:\n        output_grid = left_symmetric(blue_pixels, origin_area, output_grid)\n    elif input_grid[3:6, 3:6][0, 2] == yellow:\n        output_grid = right_symmetric(blue_pixels, origin_area, output_grid)\n    return output_grid"},
{"name": "60b61512.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0], [4, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 0], [0, 0, 0, 0, 0, 4, 0, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0], [4, 7, 4, 0, 0, 0, 0, 0, 0], [7, 7, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 4, 7, 0], [0, 0, 0, 0, 0, 7, 4, 4, 0], [0, 0, 0, 0, 0, 4, 7, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0], [7, 4, 4, 0, 0, 0, 0, 0, 0], [4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 4, 4, 0], [0, 0, 0, 0, 0, 7, 4, 7, 0], [0, 0, 0, 0, 0, 7, 4, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 4, 0, 0, 0, 0], [0, 0, 4, 4, 7, 0, 0, 0, 0], [0, 0, 4, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 7, 7, 0], [0, 0, 0, 0, 0, 4, 4, 4, 0], [0, 0, 0, 0, 0, 7, 4, 7, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_pixels_to_orange(grid: np.ndarray, locs: List[Tuple[int, int]]) -> np.ndarray:\n    for loc in locs:\n        grid[loc] = orange\n    return grid\n\ndef find_black_pixels_with_two_non_black_neighbours(grid: np.ndarray) -> List[Tuple[int, int]]:\n    black_pixels = np.where(grid == black)\n    locs = []\n    for i in range(len(black_pixels[0])):\n        row, col = (black_pixels[0][i], black_pixels[1][i])\n        neighbours = [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]\n        non_black_neighbours = [n for n in neighbours if 0 <= n[0] < grid.shape[0] and 0 <= n[1] < grid.shape[1] and (grid[n] != black)]\n        if len(non_black_neighbours) >= 2:\n            locs.append((row, col))\n    return locs\n\ndef has_more_than_63_black_pixels(grid: np.ndarray) -> bool:\n    return np.count_nonzero(grid == black) > 63\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = input_grid\n    while has_more_than_63_black_pixels(output_grid):\n        locs = find_black_pixels_with_two_non_black_neighbours(output_grid)\n        output_grid = change_pixels_to_orange(output_grid, locs)\n    return output_grid"},
{"name": "de1cd16c.json", "data": {"train": [{"input": [[4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0], [4, 4, 4, 6, 4, 4, 4, 4, 0, 0, 6, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 6, 4, 4, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1], [8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1], [8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1], [8, 8, 8, 8, 8, 6, 8, 8, 1, 1, 1, 1, 1], [8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 6, 1], [8, 8, 6, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1], [8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1], [8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1], [8, 8, 8, 8, 8, 6, 8, 8, 1, 1, 1, 1, 1], [8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1]], "output": [[8]]}, {"input": [[3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1, 2, 2, 1, 2], [3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 2, 2, 1, 2, 2, 2, 2, 2], [3, 3, 1, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 1, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 8, 8, 8], [8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]], "output": [[2]]}, {"input": [[1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 4, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 4, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5], [1, 1, 4, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 4, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 4, 6, 6, 6, 6, 4, 6], [0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 4, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6]], "output": [[6]]}, {"input": [[1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 2, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [1, 1, 1, 1, 1, 1, 1, 4, 4, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4], [1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 2, 4, 4, 4, 4, 4, 4], [1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]], "output": [[4]]}], "test": [{"input": [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [2, 4, 2, 2, 2, 2, 2, 4, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [2, 2, 2, 2, 4, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [2, 2, 4, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [2, 2, 2, 2, 2, 2, 4, 2, 2, 8, 8, 8, 8, 8, 4, 8, 8, 8, 8], [2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 4, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 4, 8, 8, 8, 8], [1, 1, 1, 1, 4, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 4, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]], "output": [[2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef get_most_common_color(color_list: List[List[int]]) -> int:\n    color_counts = [0] * 10\n    for neighborhood in color_list:\n        for color in neighborhood:\n            color_counts[color] += 1\n    return color_counts.index(max(color_counts))\n\ndef collect_neighborhoods(input: List[Tuple[int, int]], positions: List[Tuple[int, int]]) -> List[List[int]]:\n    neighborhoods = []\n    for x, y in positions:\n        neighborhood = []\n        if x > 0:\n            neighborhood.append(input[x - 1][y])\n        if x < len(input) - 1:\n            neighborhood.append(input[x + 1][y])\n        if y > 0:\n            neighborhood.append(input[x][y - 1])\n        if y < len(input[0]) - 1:\n            neighborhood.append(input[x][y + 1])\n        neighborhoods.append(neighborhood)\n    return neighborhoods\n\ndef get_positions_of_color(input: List[List[int]], color: int) -> List[Tuple[int, int]]:\n    positions = []\n    for i in range(len(input)):\n        for j in range(len(input[0])):\n            if input[i][j] == color:\n                positions.append((i, j))\n    return positions\n\ndef get_color_with_fewest_locations(input: List[Tuple[int, int]]) -> int:\n    color_counts = [0] * 10\n    for i in input.reshape(-1):\n        color_counts[i] += 1\n    for i in range(len(color_counts)):\n        if color_counts[i] == 0:\n            color_counts[i] = 100000\n    return color_counts.index(min(color_counts))\n\ndef transform_grid(input):\n    color = get_color_with_fewest_locations(input)\n    positions = get_positions_of_color(input, color)\n    color_list = collect_neighborhoods(input, positions)\n    output = get_most_common_color(color_list)\n    return np.array([[output]], dtype=np.int32)"},
{"name": "445eab21.json", "data": {"train": [{"input": [[0, 7, 7, 7, 7, 0, 0, 0, 0, 0], [0, 7, 0, 0, 7, 0, 0, 0, 0, 0], [0, 7, 0, 0, 7, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 8], [8, 8]]}, {"input": [[6, 6, 6, 6, 6, 0, 0, 0, 0, 0], [6, 0, 0, 0, 6, 0, 0, 0, 0, 0], [6, 0, 0, 0, 6, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 7, 0, 0, 0, 0, 7, 0, 0], [0, 0, 7, 0, 0, 0, 0, 7, 0, 0], [0, 0, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[7, 7], [7, 7]]}, {"input": [[0, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2]], "output": [[4, 4], [4, 4]]}], "test": [{"input": [[3, 3, 3, 3, 3, 0, 9, 9, 9, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 0, 0, 0, 3, 0, 9, 0, 0, 9], [3, 3, 3, 3, 3, 0, 9, 0, 0, 9], [0, 0, 0, 0, 0, 0, 9, 9, 9, 9]], "output": [[3, 3], [3, 3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef calculate_area_size(x_min: int, x_max: int, y_min: int, y_max: int) -> int:\n    \"\"\"\n    Given the top-left and bottom-right coordinates of a rectangle, this function calculates the area size.\n\n    Args:\n    x_min: An integer representing the x-coordinate of the top-left corner of the rectangle.\n    x_max: An integer representing the x-coordinate of the bottom-right corner of the rectangle.\n    y_min: An integer representing the y-coordinate of the top-left corner of the rectangle.\n    y_max: An integer representing the y-coordinate of the bottom-right corner of the rectangle.\n\n    Returns:\n    An integer representing the area size of the rectangle.\n    \"\"\"\n    return (x_max - x_min + 1) * (y_max - y_min + 1)\n\ndef find_most_bottom_point(input_grid: np.ndarray, color: int) -> int:\n    for i in range(input_grid.shape[0] - 1, -1, -1):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == color:\n                return i\n    return -1\n\ndef find_most_top_point(input_grid: np.ndarray, color: int) -> int:\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == color:\n                return i\n    return -1\n\ndef find_most_right_point(input_grid: np.ndarray, color: int) -> int:\n    for j in range(input_grid.shape[1] - 1, -1, -1):\n        for i in range(input_grid.shape[0]):\n            if input_grid[i][j] == color:\n                return j\n    return -1\n\ndef find_most_left_point(input_grid: np.ndarray, color: int) -> int:\n    for j in range(input_grid.shape[1]):\n        for i in range(input_grid.shape[0]):\n            if input_grid[i][j] == color:\n                return j\n    return -1\n\ndef draw_largest_color_area(area_size_list: List[Tuple[int, int]]) -> np.ndarray:\n    sorted_list = sorted(area_size_list, key=lambda x: x[1], reverse=True)\n    largest_color = sorted_list[0][0]\n    output = np.full((2, 2), largest_color)\n    return output\n\ndef find_color_areas(input_grid: np.ndarray, color_list: List[int]) -> List[Tuple[int, int]]:\n    color_areas = []\n    for color in color_list:\n        x_min = find_most_left_point(input_grid, color)\n        x_max = find_most_right_point(input_grid, color)\n        y_min = find_most_top_point(input_grid, color)\n        y_max = find_most_bottom_point(input_grid, color)\n        area = calculate_area_size(x_min, x_max, y_min, y_max)\n        color_areas.append((color, area))\n    return color_areas\n\ndef find_not_black_colors(input_grid: np.ndarray) -> List[int]:\n    \"\"\"\n    Given an input grid, this function returns a list of all the non-black colors present in the grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A list of integers representing the non-black colors present in the grid.\n    \"\"\"\n    color_list = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black and input_grid[i][j] not in color_list:\n                color_list.append(input_grid[i][j])\n    return color_list\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    color_list = find_not_black_colors(input_grid)\n    area_size_list = find_color_areas(input_grid, color_list)\n    output = draw_largest_color_area(area_size_list)\n    return output"},
{"name": "82819916.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 2, 3, 3, 2, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 6, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 2, 3, 3, 2, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 4, 8, 8, 4, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 6, 1, 1, 6, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 1, 2, 1, 2, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 1, 2, 1, 2, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 1, 3, 1, 3, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 2, 8, 2, 8, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0], [1, 4, 1, 4, 4, 1, 4, 1], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [2, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [8, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [6, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0], [1, 4, 1, 4, 4, 1, 4, 1], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [2, 3, 2, 3, 3, 2, 3, 2], [0, 0, 0, 0, 0, 0, 0, 0], [8, 2, 8, 2, 2, 8, 2, 8], [0, 0, 0, 0, 0, 0, 0, 0], [6, 5, 6, 5, 5, 6, 5, 6], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 4, 4, 4, 3, 4, 3], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 4, 4, 4, 3, 4, 3], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 2, 2, 2, 8, 2, 8], [0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 1, 2, 1, 2, 1, 1, 2, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 1, 2, 1, 2, 1, 1, 2, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 3, 8, 3, 8, 3, 3, 8, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 4, 1, 4, 1, 4, 4, 1, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 8, 6, 8, 6, 8, 8, 6, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 6, 1, 6, 1, 6, 6, 1, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef fill_row_with_pattern(row: np.ndarray, pattern: List[int]) -> np.ndarray:\n    \"\"\"\n    Fills a row with a given color pattern\n    Args:\n        row: A numpy array representing the row to be filled\n        pattern: A list of integers representing the color pattern to be used for filling the row\n    Returns:\n        A numpy array representing the filled row\n    \"\"\"\n    filled_row = np.copy(row)\n    color1 = None\n    color2 = None\n    current_color = None\n    for i in range(len(pattern)):\n        if pattern[i] == '0':\n            if color1 == None:\n                color1 = filled_row[i]\n            filled_row[i] = color1\n        elif pattern[i] == '1':\n            if color2 == None:\n                color2 = filled_row[i]\n            filled_row[i] = color2\n    return filled_row\n\ndef the_row_is_incomplete(row: np.ndarray) -> bool:\n    \"\"\"\n    Checks if a row is incomplete, i.e., contains at least one black pixel\n    Args:\n        row: A numpy array representing the row to be checked\n    Returns:\n        A boolean value indicating whether the row is incomplete or not\n    \"\"\"\n    return np.any(row == black)\n\ndef get_color_pattern(row: np.ndarray) -> List[int]:\n    \"\"\"                                                                                                                                                                   \n    Finds the color pattern of a row that is filled in completely with colored pixels (not black)                                                                         \n    Args:                                                                                                                                                                 \n        row: A numpy array representing the row that is filled in completely with colored pixels (not black)                                                              \n    Returns:                                                                                                                                                              \n        A list of integers representing the color pattern of the row                                                                                                      \n    \"\"\"\n    pattern = []\n    color1 = None\n    color2 = None\n    current_color = None\n    for pixel in row:\n        if color1 == None:\n            color1 = pixel\n            pattern.append('0')\n        elif color2 == None and pixel != color1:\n            color2 = pixel\n            pattern.append('1')\n        elif pixel == color1:\n            pattern.append('0')\n        elif pixel == color2:\n            pattern.append('1')\n    return pattern\n\ndef find_complete_row(input_grid: np.ndarray) -> Tuple[np.ndarray, int]:\n    \"\"\"\n    Finds the row that is completely filled with colored pixels (not black)\n    Args:\n        input_grid: A numpy array representing the input grid\n    Returns:\n        A tuple containing the numpy array representing the row that is completely filled with colored pixels (not black) and its row id\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i] != black):\n            return (input_grid[i], i)\n    return (None, None)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                   \nIn the input, you should see... some lines filled in with colors                                                                                                          \nThe output grid size... is the same                                                                                                                                       \nTo make the output, For the line that is filled in completely with colored pixels (not black) keep these the same as input.                                               \nthere are two kinds of colors in this line: color1 and color2, you should get the color pattern of this line.                                                             \nFor any line with several color pixels filled in, use this pattern to finish the line across                                                                              \nAll other black squares remain black                                                                                                                                      \n    \"\"\"\n    output_grid = np.copy(input_grid)\n    compelete_row, row_id = find_complete_row(input_grid)\n    pattern = get_color_pattern(compelete_row)\n    for i in range(input_grid.shape[0]):\n        if the_row_is_incomplete(input_grid[i]) and i != row_id:\n            output_grid[i] = fill_row_with_pattern(input_grid[i], pattern)\n    return output_grid"},
{"name": "75b8110e.json", "data": {"train": [{"input": [[4, 4, 0, 0, 0, 0, 5, 0], [4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 5, 0], [0, 4, 0, 0, 5, 5, 0, 0], [0, 0, 6, 0, 0, 0, 9, 0], [6, 6, 6, 0, 0, 0, 0, 9], [6, 0, 6, 6, 9, 9, 0, 0], [0, 6, 6, 0, 9, 0, 0, 0]], "output": [[4, 4, 5, 0], [6, 6, 6, 9], [6, 9, 5, 6], [5, 5, 6, 0]]}, {"input": [[4, 0, 0, 4, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5], [4, 4, 0, 4, 0, 5, 0, 0], [4, 0, 4, 4, 0, 5, 5, 5], [0, 0, 0, 6, 0, 9, 0, 9], [0, 0, 6, 0, 0, 9, 0, 0], [6, 0, 0, 6, 0, 9, 0, 9], [0, 0, 6, 6, 0, 0, 0, 9]], "output": [[5, 5, 0, 6], [0, 9, 5, 5], [6, 5, 0, 6], [4, 5, 5, 5]]}, {"input": [[0, 0, 0, 4, 5, 0, 0, 0], [4, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 4, 0, 0, 5, 0], [0, 4, 0, 4, 0, 0, 5, 0], [6, 0, 0, 0, 0, 9, 9, 0], [6, 0, 0, 0, 0, 9, 0, 9], [6, 0, 6, 0, 9, 9, 9, 0], [6, 0, 6, 0, 0, 0, 0, 0]], "output": [[5, 9, 9, 4], [6, 5, 0, 9], [6, 9, 5, 4], [6, 4, 5, 4]]}, {"input": [[4, 0, 0, 4, 0, 5, 0, 5], [0, 0, 4, 0, 5, 0, 0, 5], [0, 0, 4, 4, 0, 0, 5, 5], [4, 0, 0, 0, 5, 0, 0, 5], [6, 6, 6, 0, 9, 0, 9, 9], [6, 6, 6, 0, 0, 9, 9, 9], [6, 0, 0, 6, 9, 9, 0, 9], [6, 6, 0, 6, 9, 0, 9, 9]], "output": [[6, 5, 6, 5], [5, 6, 6, 5], [6, 9, 5, 5], [5, 6, 9, 5]]}, {"input": [[0, 4, 4, 4, 0, 5, 5, 5], [0, 0, 4, 0, 5, 5, 0, 5], [0, 0, 0, 0, 5, 0, 0, 0], [4, 0, 0, 0, 5, 0, 0, 0], [6, 6, 0, 6, 0, 0, 9, 9], [0, 0, 0, 6, 9, 0, 9, 0], [0, 0, 0, 6, 9, 0, 9, 9], [6, 6, 0, 6, 0, 9, 0, 9]], "output": [[6, 5, 5, 5], [5, 5, 9, 5], [5, 0, 9, 6], [5, 6, 0, 6]]}], "test": [{"input": [[0, 4, 0, 4, 5, 0, 0, 0], [0, 4, 4, 4, 5, 0, 5, 5], [4, 4, 4, 0, 0, 5, 5, 5], [0, 0, 0, 0, 5, 0, 0, 0], [6, 0, 6, 6, 9, 9, 9, 0], [0, 0, 0, 6, 0, 9, 0, 0], [0, 6, 0, 0, 0, 0, 9, 9], [6, 0, 0, 0, 0, 9, 0, 0]], "output": [[5, 9, 6, 6], [5, 9, 5, 5], [4, 5, 5, 5], [5, 9, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_color_with_grey_4x4(out: np.ndarray, b: np.ndarray) -> np.array:\n    out[:4, :4][b[:4, :4] != black] = grey\n    return out\n\ndef replace_color_with_grey(out: np.ndarray, b: np.ndarray) -> np.array:\n    out = replace_color_with_grey_4x4(out, b)\n    return out\n\ndef replace_color_with_pink(out: np.ndarray, c: np.ndarray) -> np.ndarray:\n    out[:4, :4][c[:4, :4] == pink] = pink\n    return out\n\ndef replace_color_with_maroon(out: np.ndarray, d: np.ndarray) -> np.ndarray:\n    out[:4, :4][d[:4, :4] == maroon] = maroon\n    return out\n\ndef replace_color(out: np.ndarray, a: np.ndarray) -> np.ndarray:\n    out[:4, :4][a[:4, :4] == yellow] = yellow\n    return out\n\ndef build_black_matrix() -> np.ndarray:\n    return np.full((4, 4), black)\n\ndef divide_into_4(input_grid: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    a = input_grid[:4, :4]\n    b = input_grid[:4, 4:]\n    c = input_grid[4:, :4]\n    d = input_grid[4:, 4:]\n    return (a, b, c, d)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    a, b, c, d = divide_into_4(input_grid)\n    out = build_black_matrix()\n    out = replace_color(out, a)\n    out = replace_color_with_maroon(out, d)\n    out = replace_color_with_pink(out, c)\n    out = replace_color_with_grey(out, b)\n    return out"},
{"name": "137eaa0f.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[6, 6, 7], [0, 5, 7], [4, 4, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 7, 5, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 2, 2, 0, 0, 3, 3, 3, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[6, 2, 2], [7, 5, 7], [3, 3, 3]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 1, 1], [1, 5, 2], [9, 9, 2]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9, 5, 0, 0], [4, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0], [0, 5, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0]], "output": [[4, 9, 8], [9, 5, 4], [9, 2, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef add_grids_and_make_center_grey(grids: List[np.ndarray]) -> np.ndarray:\n    \"\"\"\n    Adds all the grids and makes the center pixel gray.\n\n    Args:\n    grids: A list of numpy arrays, each representing a 3x3 grid.\n\n    Returns:\n    A numpy array representing the output grid.\n    \"\"\"\n    output_grid = np.zeros_like(grids[0])\n    for grid in grids:\n        output_grid += grid\n    output_grid[1, 1] = grey\n    return output_grid\n\ndef get_centered_grids(input_grid: np.ndarray) -> List[np.ndarray]:\n    \"\"\"\n    Returns a list of 3x3 grids centered on gray pixels in the input grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A list of numpy arrays, each representing a 3x3 grid centered on a gray pixel.\n    \"\"\"\n    gray_pixels = np.where(input_grid == grey)\n    centered_grids = []\n    for i in range(len(gray_pixels[0])):\n        row, col = (gray_pixels[0][i], gray_pixels[1][i])\n        if row > 0 and row < input_grid.shape[0] - 1 and (col > 0) and (col < input_grid.shape[1] - 1):\n            centered_grids.append(input_grid[row - 1:row + 2, col - 1:col + 2])\n    return centered_grids\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    grids = get_centered_grids(input_grid)\n    output_grid = add_grids_and_make_center_grey(grids)\n    return output_grid"},
{"name": "694f12f3.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 4, 1, 1, 4, 0, 0, 0, 0, 0], [0, 4, 1, 1, 4, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 4, 2, 2, 2, 2, 4, 0], [0, 0, 0, 4, 2, 2, 2, 2, 4, 0], [0, 0, 0, 4, 4, 4, 4, 4, 4, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 4, 4, 4, 4, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 4, 2, 2, 2, 4, 0, 0, 0, 0], [0, 4, 2, 2, 2, 4, 0, 0, 0, 0], [0, 4, 2, 2, 2, 4, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 4, 1, 1, 4, 0], [0, 0, 0, 0, 0, 4, 4, 4, 4, 0]]}], "test": [{"input": [[4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4]], "output": [[4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [4, 2, 2, 2, 2, 4, 0, 0, 0, 0], [4, 2, 2, 2, 2, 4, 0, 0, 0, 0], [4, 2, 2, 2, 2, 4, 0, 0, 0, 0], [4, 2, 2, 2, 2, 4, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 4, 1, 1, 1, 1, 4], [0, 0, 0, 0, 4, 4, 4, 4, 4, 4]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_inside(input: np.ndarray, rectangle: Tuple[int, int, int, int], color: int) -> np.ndarray:\n    \"\"\"\n    This function takes a 2-dimensional numpy array as input, a tuple representing a rectangle in the input, and a color.\n    It colors the inside of the rectangle with the given color and returns the modified numpy array.\n    \"\"\"\n    x, y, w, h = rectangle\n    for i in range(x + 1, x + h - 1):\n        for j in range(y + 1, y + w - 1):\n            input[i][j] = color\n    return input\n\ndef get_max_min_area_rectangles(rectangles: List[Tuple[int, int, int, int]]) -> Tuple[Tuple[int, int, int, int], Tuple[int, int, int, int]]:\n    \"\"\"\n    This function takes a list of tuples, where each tuple represents a yellow rectangle in the input. The tuple contains\n    the coordinates of the top-left corner of the rectangle and its width and height. It returns a tuple of two tuples,\n    where the first tuple represents the rectangle with the maximum area and the second tuple represents the rectangle\n    with the minimum area.\n    \"\"\"\n    max_area = 0\n    min_area = float('inf')\n    max_rectangle = None\n    min_rectangle = None\n    for rectangle in rectangles:\n        area = rectangle[2] * rectangle[3]\n        if area > max_area:\n            max_area = area\n            max_rectangle = rectangle\n        if area < min_area:\n            min_area = area\n            min_rectangle = rectangle\n    return (max_rectangle, min_rectangle)\n\ndef black_rectangle(input: np.ndarray, rectangle: Tuple[int, int, int, int]) -> np.ndarray:\n    \"\"\"\n    This function takes a 2-dimensional numpy array as input and a tuple representing a rectangle in the input.\n    It colors the inside of the rectangle with black color and returns the modified numpy array.\n    \"\"\"\n    x, y, w, h = rectangle\n    for i in range(x, x + h):\n        for j in range(y, y + w):\n            input[i][j] = black\n    return input\n\ndef find_largest_yellow_rectangles(input: np.ndarray) -> List[Tuple[int, int, int, int]]:\n    \"\"\"\n    This function takes a 2-dimensional numpy array as input and returns a list of tuples, where each tuple represents a\n    yellow rectangle in the input. The tuple contains the coordinates of the top-left corner of the rectangle and its\n    width and height. If there are multiple rectangles with the same largest size, all of them should be included in the\n    output list.\n    \"\"\"\n    rectangles = []\n    for i in range(input.shape[0]):\n        for j in range(input.shape[1]):\n            if input[i][j] == yellow:\n                width = 1\n                height = 1\n                while i + height < input.shape[0] and input[i + height][j] == yellow:\n                    height += 1\n                while j + width < input.shape[1] and input[i][j + width] == yellow:\n                    width += 1\n                rectangles.append((i, j, width, height))\n    max_size = max([w * h for _, _, w, h in rectangles])\n    return [(i, j, w, h) for i, j, w, h in rectangles if w * h == max_size]\n\ndef transform_grid(input):\n    rectangles1 = find_largest_yellow_rectangles(input)\n    output = np.copy(input)\n    output = black_rectangle(output, rectangles1[0])\n    rectangles2 = find_largest_yellow_rectangles(output)\n    max_rectangle, min_rectangle = get_max_min_area_rectangles([rectangles1[0], rectangles2[0]])\n    output = np.copy(input)\n    output = color_inside(output, max_rectangle, red)\n    output = color_inside(output, min_rectangle, blue)\n    return output"},
{"name": "bb43febb.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 0, 5, 5, 5, 0], [5, 5, 5, 5, 5, 0, 5, 5, 5, 0], [5, 5, 5, 5, 5, 0, 5, 5, 5, 0], [5, 5, 5, 5, 5, 0, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 0, 0, 0, 0, 0], [5, 2, 2, 2, 5, 0, 5, 5, 5, 0], [5, 2, 2, 2, 5, 0, 5, 2, 5, 0], [5, 2, 2, 2, 5, 0, 5, 2, 5, 0], [5, 5, 5, 5, 5, 0, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 5, 2, 2, 2, 2, 5, 0, 0, 0], [0, 5, 2, 2, 2, 2, 5, 0, 0, 0], [0, 5, 2, 2, 2, 2, 5, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 5, 2, 2, 2, 5, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 0]]}], "test": [{"input": [[5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5]], "output": [[5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [5, 2, 2, 2, 2, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 2, 2, 2, 2, 2, 5], [0, 0, 0, 5, 2, 2, 2, 2, 2, 5], [0, 0, 0, 5, 2, 2, 2, 2, 2, 5], [0, 0, 0, 5, 2, 2, 2, 2, 2, 5], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_grey_rectangles_and_make_inside_red(input: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    This function takes a 2D list of integers as input and finds all the grey rectangles in it.\n    It then makes the inside of these rectangles red and returns the updated 2D list.\n    \n    Args:\n    - input: A 2D list of integers representing a grid of colors.\n    \n    Returns:\n    - A 2D list of integers representing the updated grid of colors.\n    \"\"\"\n    for i in range(len(input)):\n        for j in range(len(input[0])):\n            if input[i][j] == grey:\n                left = j\n                right = j\n                while left > 0 and input[i][left - 1] == grey:\n                    left -= 1\n                while right < len(input[0]) - 1 and input[i][right + 1] == grey:\n                    right += 1\n                top = i\n                bottom = i\n                while top > 0 and all((x == grey for x in input[top - 1][left:right + 1])):\n                    top -= 1\n                while bottom < len(input) - 1 and all((x == grey for x in input[bottom + 1][left:right + 1])):\n                    bottom += 1\n                for x in range(top + 1, bottom):\n                    for y in range(left + 1, right):\n                        input[x][y] = red\n    return input\n\ndef transform_grid(input):\n    return find_grey_rectangles_and_make_inside_red(input)"},
{"name": "6430c8c4.json", "data": {"train": [{"input": [[7, 7, 0, 7], [0, 7, 7, 0], [0, 7, 7, 7], [0, 7, 7, 0], [4, 4, 4, 4], [0, 0, 0, 0], [0, 2, 0, 2], [2, 2, 2, 0], [2, 0, 0, 2]], "output": [[0, 0, 3, 0], [3, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]}, {"input": [[0, 0, 7, 7], [0, 0, 7, 7], [0, 7, 7, 0], [7, 7, 0, 0], [4, 4, 4, 4], [2, 0, 2, 0], [0, 2, 0, 2], [0, 2, 2, 0], [0, 0, 2, 0]], "output": [[0, 3, 0, 0], [3, 0, 0, 0], [3, 0, 0, 3], [0, 0, 0, 3]]}, {"input": [[0, 0, 0, 7], [0, 7, 7, 7], [0, 7, 0, 0], [0, 7, 7, 7], [4, 4, 4, 4], [0, 0, 2, 0], [0, 2, 2, 2], [2, 2, 0, 0], [0, 2, 0, 2]], "output": [[3, 3, 0, 0], [3, 0, 0, 0], [0, 0, 3, 3], [3, 0, 0, 0]]}, {"input": [[7, 0, 7, 0], [0, 0, 7, 7], [7, 0, 7, 7], [7, 7, 0, 0], [4, 4, 4, 4], [0, 0, 2, 2], [0, 0, 0, 0], [2, 0, 0, 2], [0, 2, 0, 2]], "output": [[0, 3, 0, 0], [3, 3, 0, 0], [0, 3, 0, 0], [0, 0, 3, 0]]}], "test": [{"input": [[7, 7, 7, 7], [0, 7, 7, 7], [7, 0, 0, 0], [7, 0, 7, 0], [4, 4, 4, 4], [0, 2, 2, 2], [0, 0, 0, 0], [2, 0, 2, 2], [0, 2, 0, 0]], "output": [[0, 0, 0, 0], [3, 0, 0, 0], [0, 3, 0, 0], [0, 0, 0, 3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_green_with_black(input_grid: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function replaces any green pixel in the output grid with black if there is a red pixel in the corresponding position in the bottom 4x4 grid of the input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    output_grid: A numpy array representing the modified input grid.\n    \n    Returns:\n    A numpy array representing the final modified input grid.\n    \"\"\"\n    bottom_grid = input_grid[-4:, :]\n    for i in range(4):\n        for j in range(4):\n            if output_grid[i, j] == green and bottom_grid[i, j] == red:\n                output_grid[i, j] = black\n    return output_grid\n\ndef fill_colors(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function fills in the black pixels with green and changes all the orange pixels to black.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A numpy array representing the modified input grid.\n    \"\"\"\n    output_grid = input_grid.copy()\n    output_grid[output_grid == black] = green\n    output_grid[output_grid == orange] = black\n    return output_grid\n\ndef copy_top_4_rows(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function copies the top 4 rows of the input grid and returns it as a new numpy array.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A numpy array representing the top 4 rows of the input grid.\n    \"\"\"\n    return input_grid[:4, :]\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you should see...orange, yellow, and red pixels in different shapes.                                                                                  \n    The output grid size...is smaller. Make it 4x4.                                                                                                                     \n    To make the output, you have to...only use the 4x4 grid that is at the top of the input grid where only the orange pixels are. Fill in the black pixels with green. \n    \"\"\"\n    output_grid = copy_top_4_rows(input_grid)\n    output_grid = fill_colors(output_grid)\n    output_grid = replace_green_with_black(input_grid, output_grid)\n    return output_grid"},
{"name": "99fa7670.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 2], [0, 0, 0, 0, 0, 2], [0, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 3]]}, {"input": [[0, 0, 0], [0, 6, 0], [0, 0, 0]], "output": [[0, 0, 0], [0, 6, 6], [0, 0, 6]]}, {"input": [[0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 8], [0, 0, 0, 5, 5, 5], [0, 0, 0, 0, 0, 5]]}, {"input": [[0, 0, 0, 0, 0], [0, 0, 8, 0, 0], [0, 0, 0, 0, 0], [0, 7, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 6, 0, 0], [0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0], [0, 0, 8, 8, 8], [0, 0, 0, 0, 8], [0, 7, 7, 7, 7], [0, 0, 0, 0, 7], [0, 0, 6, 6, 6], [0, 0, 0, 0, 6]]}], "test": [{"input": [[0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 7, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_line_in_grid(grid: np.ndarray, line: np.ndarray, index: int) -> np.ndarray:\n    grid[index] = line\n    return grid\n\ndef replace_black_with_last_color(line: np.ndarray, last_color: int) -> np.ndarray:\n    output_line = np.zeros_like(line)\n    output_line[:-1] = line[:-1]\n    output_line[-1] = last_color\n    return output_line\n\ndef replace_element_behind_non_black(line: np.ndarray, pos: int, color: int) -> np.ndarray:\n    output_line = np.zeros_like(line)\n    output_line[:pos] = black\n    output_line[pos:] = color\n    return output_line\n\ndef find_non_black_element(line: np.ndarray) -> Tuple[Optional[int], Optional[int]]:\n    for i, color in enumerate(line):\n        if color != black:\n            return (i, color)\n    return (None, None)\n\ndef create_black_grid(input_grid: np.ndarray) -> np.ndarray:\n    return np.zeros_like(input_grid)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = create_black_grid(input_grid)\n    last_color = black\n    for index, line in enumerate(input_grid):\n        pos, color = find_non_black_element(line)\n        if pos != None:\n            output_line = replace_element_behind_non_black(line, pos, color)\n            last_color = color\n        else:\n            output_line = replace_black_with_last_color(line, last_color)\n        output_grid = replace_line_in_grid(output_grid, output_line, index)\n    return output_grid"},
{"name": "09629e4f.json", "data": {"train": [{"input": [[2, 0, 0, 5, 0, 6, 2, 5, 0, 0, 4], [0, 4, 3, 5, 4, 0, 8, 5, 3, 0, 6], [6, 0, 0, 5, 3, 0, 0, 5, 8, 0, 2], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [3, 8, 0, 5, 6, 2, 0, 5, 0, 4, 8], [0, 0, 4, 5, 0, 0, 4, 5, 6, 0, 0], [6, 2, 0, 5, 3, 8, 0, 5, 0, 3, 2], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 3, 6, 5, 0, 2, 0, 5, 0, 6, 0], [2, 0, 0, 5, 4, 0, 8, 5, 0, 0, 8], [8, 0, 4, 5, 6, 3, 0, 5, 2, 3, 4]], "output": [[2, 2, 2, 5, 0, 0, 0, 5, 0, 0, 0], [2, 2, 2, 5, 0, 0, 0, 5, 0, 0, 0], [2, 2, 2, 5, 0, 0, 0, 5, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 4, 4, 4, 5, 3, 3, 3], [0, 0, 0, 5, 4, 4, 4, 5, 3, 3, 3], [0, 0, 0, 5, 4, 4, 4, 5, 3, 3, 3], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [6, 6, 6, 5, 0, 0, 0, 5, 0, 0, 0], [6, 6, 6, 5, 0, 0, 0, 5, 0, 0, 0], [6, 6, 6, 5, 0, 0, 0, 5, 0, 0, 0]]}, {"input": [[2, 0, 3, 5, 4, 6, 0, 5, 0, 6, 0], [0, 0, 8, 5, 0, 0, 2, 5, 4, 0, 3], [4, 6, 0, 5, 3, 8, 0, 5, 2, 0, 8], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [4, 0, 8, 5, 0, 0, 2, 5, 0, 6, 4], [0, 0, 2, 5, 0, 3, 0, 5, 3, 0, 0], [3, 0, 6, 5, 4, 0, 6, 5, 8, 0, 2], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [3, 6, 0, 5, 0, 8, 4, 5, 2, 0, 0], [0, 8, 4, 5, 2, 0, 0, 5, 8, 0, 3], [2, 0, 0, 5, 0, 3, 6, 5, 6, 4, 0]], "output": [[0, 0, 0, 5, 0, 0, 0, 5, 2, 2, 2], [0, 0, 0, 5, 0, 0, 0, 5, 2, 2, 2], [0, 0, 0, 5, 0, 0, 0, 5, 2, 2, 2], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 3, 3, 3, 5, 0, 0, 0], [0, 0, 0, 5, 3, 3, 3, 5, 0, 0, 0], [0, 0, 0, 5, 3, 3, 3, 5, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [4, 4, 4, 5, 0, 0, 0, 5, 6, 6, 6], [4, 4, 4, 5, 0, 0, 0, 5, 6, 6, 6], [4, 4, 4, 5, 0, 0, 0, 5, 6, 6, 6]]}, {"input": [[0, 3, 0, 5, 0, 6, 3, 5, 0, 6, 2], [6, 0, 4, 5, 2, 8, 0, 5, 0, 0, 8], [0, 2, 8, 5, 0, 4, 0, 5, 3, 0, 4], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 2, 0, 5, 4, 0, 3, 5, 3, 4, 0], [4, 0, 8, 5, 2, 0, 6, 5, 0, 0, 2], [3, 6, 0, 5, 0, 8, 0, 5, 8, 6, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [6, 3, 0, 5, 0, 3, 0, 5, 0, 0, 3], [0, 0, 2, 5, 0, 6, 4, 5, 2, 8, 0], [8, 4, 0, 5, 2, 0, 0, 5, 4, 0, 6]], "output": [[0, 0, 0, 5, 3, 3, 3, 5, 0, 0, 0], [0, 0, 0, 5, 3, 3, 3, 5, 0, 0, 0], [0, 0, 0, 5, 3, 3, 3, 5, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 6, 6, 6, 5, 4, 4, 4], [0, 0, 0, 5, 6, 6, 6, 5, 4, 4, 4], [0, 0, 0, 5, 6, 6, 6, 5, 4, 4, 4], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [2, 2, 2, 5, 0, 0, 0, 5, 0, 0, 0], [2, 2, 2, 5, 0, 0, 0, 5, 0, 0, 0], [2, 2, 2, 5, 0, 0, 0, 5, 0, 0, 0]]}, {"input": [[3, 8, 4, 5, 4, 6, 0, 5, 2, 0, 8], [0, 0, 0, 5, 8, 0, 3, 5, 6, 0, 3], [6, 2, 0, 5, 0, 2, 0, 5, 4, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 4, 2, 5, 8, 0, 3, 5, 0, 4, 0], [0, 8, 6, 5, 0, 0, 4, 5, 0, 2, 6], [0, 3, 0, 5, 2, 6, 0, 5, 0, 3, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 6, 0, 5, 6, 2, 0, 5, 3, 6, 0], [3, 0, 8, 5, 0, 8, 3, 5, 0, 0, 4], [4, 2, 0, 5, 0, 0, 4, 5, 2, 0, 8]], "output": [[0, 0, 0, 5, 4, 4, 4, 5, 0, 0, 0], [0, 0, 0, 5, 4, 4, 4, 5, 0, 0, 0], [0, 0, 0, 5, 4, 4, 4, 5, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 2, 2, 2, 5, 6, 6, 6], [0, 0, 0, 5, 2, 2, 2, 5, 6, 6, 6], [0, 0, 0, 5, 2, 2, 2, 5, 6, 6, 6], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 3, 3, 3, 5, 0, 0, 0], [0, 0, 0, 5, 3, 3, 3, 5, 0, 0, 0], [0, 0, 0, 5, 3, 3, 3, 5, 0, 0, 0]]}], "test": [{"input": [[6, 4, 0, 5, 0, 3, 0, 5, 0, 4, 0], [0, 0, 3, 5, 2, 8, 6, 5, 8, 0, 2], [2, 0, 8, 5, 4, 0, 0, 5, 6, 3, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [2, 0, 0, 5, 0, 3, 0, 5, 3, 6, 2], [3, 4, 6, 5, 8, 4, 2, 5, 0, 0, 4], [0, 8, 0, 5, 0, 0, 6, 5, 8, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 2, 4, 5, 0, 6, 4, 5, 0, 2, 8], [0, 6, 3, 5, 0, 0, 3, 5, 4, 0, 6], [0, 0, 0, 5, 2, 0, 8, 5, 3, 0, 0]], "output": [[0, 0, 0, 5, 2, 2, 2, 5, 4, 4, 4], [0, 0, 0, 5, 2, 2, 2, 5, 4, 4, 4], [0, 0, 0, 5, 2, 2, 2, 5, 4, 4, 4], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 6, 6, 6, 5, 3, 3, 3], [0, 0, 0, 5, 6, 6, 6, 5, 3, 3, 3], [0, 0, 0, 5, 6, 6, 6, 5, 3, 3, 3], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef add_grey_lines(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.zeros((11, 11))\n    for i in range(11):\n        for j in range(11):\n            if i % 4 == 3 or j % 4 == 3:\n                output_grid[i][j] = grey\n            else:\n                output_grid[i][j] = input_grid[i - i // 4][j - j // 4]\n    return output_grid\n\ndef set_block_colors(output_grid: np.ndarray, output_block: np.ndarray) -> np.ndarray:\n    for i, element in enumerate(output_block.flatten()):\n        if element != black:\n            row = i // 3 * 3\n            col = i % 3 * 3\n            output_grid[row:row + 3, col:col + 3] = element\n    return output_grid\n\ndef find_block_with_4_non_black_elements(sub_blocks: List[np.ndarray]) -> np.ndarray:\n    for block in sub_blocks:\n        if np.count_nonzero(block != black) == 4:\n            return block\n    return np.zeros((3, 3))\n\ndef separate_sub_blocks(input_grid: np.ndarray) -> List[np.ndarray]:\n    sub_blocks = []\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            sub_blocks.append(input_grid[i:i + 3, j:j + 3])\n    return sub_blocks\n\ndef remove_rows_cols(input_grid: np.ndarray) -> np.ndarray:\n    return np.delete(np.delete(input_grid, [3, 7], axis=1), [3, 7], axis=0)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.zeros((9, 9))\n    remove_grey_input_grid = remove_rows_cols(input_grid)\n    sub_blocks = separate_sub_blocks(remove_grey_input_grid)\n    output_block = find_block_with_4_non_black_elements(sub_blocks)\n    output_grid = set_block_colors(output_grid, output_block)\n    output_grid = add_grey_lines(output_grid)\n    return output_grid"},
{"name": "d0f5fe59.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 0, 0, 0], [0, 8, 0, 0], [0, 0, 8, 0], [0, 0, 0, 8]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 0, 0], [0, 8, 0], [0, 0, 8]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 0], [0, 8]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 8, 8, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 0, 8, 8, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 8, 8, 8, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 0, 0, 0, 0], [0, 8, 0, 0, 0], [0, 0, 8, 0, 0], [0, 0, 0, 8, 0], [0, 0, 0, 0, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef make_teal_pixels_black(grid: np.ndarray, i: int, j: int) -> np.ndarray:\n    \"\"\"\n    This function takes a grid and the indices of a teal pixel and makes all the teal pixels in the same shape black.\n    \n    Parameters:\n    grid (np.ndarray): A numpy array representing the input grid\n    i (int): The row index of the teal pixel\n    j (int): The column index of the teal pixel\n    \n    Returns:\n    np.ndarray: A numpy array representing the output grid with all the teal pixels in the same shape as the input pixel black\n    \"\"\"\n    if i < 0 or j < 0 or i >= len(grid) or (j >= len(grid[0])) or (grid[i][j] != teal):\n        return grid\n    grid[i][j] = black\n    grid = make_teal_pixels_black(grid, i - 1, j)\n    grid = make_teal_pixels_black(grid, i + 1, j)\n    grid = make_teal_pixels_black(grid, i, j - 1)\n    grid = make_teal_pixels_black(grid, i, j + 1)\n    return grid\n\ndef create_teal_line(grid: np.ndarray, number_of_shapes: int) -> np.ndarray:\n    \"\"\"                                                                                                                                                                   \n    This function takes a grid and the number of shapes and creates a line from the top left corner to the base right corner with the same color as the shapes in the inpu\n                                                                                                                                                                          \n    Parameters:                                                                                                                                                           \n    grid (np.ndarray): A numpy array representing the input grid                                                                                                          \n    number_of_shapes (int): The number of shapes in the input grid                                                                                                        \n                                                                                                                                                                          \n    Returns:                                                                                                                                                              \n    np.ndarray: A numpy array representing the output grid with a line from the top left corner to the base right corner with the same color as the shapes in the input gr\n    \"\"\"\n    for i in range(number_of_shapes):\n        grid[i][i] = teal\n    return grid\n\ndef find_number_of_teal_shapes(input_grid: np.ndarray) -> int:\n    \"\"\"                                                                                                                                                                   \n    This function takes an input grid and returns the number of teal shapes in it.                                                                                        \n                                                                                                                                                                          \n    Parameters:                                                                                                                                                           \n    input_grid (np.ndarray): A numpy array representing the input grid                                                                                                    \n                                                                                                                                                                          \n    Returns:                                                                                                                                                              \n    int: The number of teal shapes in the input grid                                                                                                                      \n    \"\"\"\n    count = 0\n    for i in range(len(input_grid)):\n        for j in range(len(input_grid[i])):\n            if input_grid[i][j] == teal:\n                count += 1\n                input_grid = make_teal_pixels_black(input_grid, i, j)\n    return count\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                   \n    In the input, you should see a grid contains several seperate grid, you should find the number of teal shapes and create a grid with the same number of shapes        \n    The output grid size is the number of shapes the input grid has.                                                                                                      \n    To make the output, you have to take the same color as the shapes in the input grid and create a line from the top left corner to the base right corner               \n    \"\"\"\n    number_of_shapes = find_number_of_teal_shapes(input_grid)\n    output_grid = np.zeros((number_of_shapes, number_of_shapes))\n    output_grid = create_teal_line(output_grid, number_of_shapes)\n    return output_grid"},
{"name": "a85d4709.json", "data": {"train": [{"input": [[0, 0, 5], [0, 5, 0], [5, 0, 0]], "output": [[3, 3, 3], [4, 4, 4], [2, 2, 2]]}, {"input": [[0, 0, 5], [0, 0, 5], [0, 0, 5]], "output": [[3, 3, 3], [3, 3, 3], [3, 3, 3]]}, {"input": [[5, 0, 0], [0, 5, 0], [5, 0, 0]], "output": [[2, 2, 2], [4, 4, 4], [2, 2, 2]]}, {"input": [[0, 5, 0], [0, 0, 5], [0, 5, 0]], "output": [[4, 4, 4], [3, 3, 3], [4, 4, 4]]}], "test": [{"input": [[0, 0, 5], [5, 0, 0], [0, 5, 0]], "output": [[3, 3, 3], [2, 2, 2], [4, 4, 4]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef fill_row_with_color(i: int, color: int, output_grid: np.ndarray) -> np.ndarray:\n    output_grid[i] = color\n    return output_grid\n\ndef get_color(input_value: int) -> int:\n    if input_value == 0:\n        return red\n    elif input_value == 1:\n        return yellow\n    elif input_value == 2:\n        return green\n    else:\n        return black\n\ndef get_non_black_pixel_column(input_grid: np.ndarray) -> List[int]:\n    non_black_pixel_column = []\n    for row in input_grid:\n        non_black_pixel_column.append(np.where(row != black)[0][0])\n    return non_black_pixel_column\n\ndef create_output_grid(input_grid: np.ndarray) -> np.ndarray:\n    return np.zeros_like(input_grid)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = create_output_grid(input_grid)\n    tmp = get_non_black_pixel_column(input_grid)\n    for i in range(3):\n        color = get_color(tmp[i])\n        output_grid = fill_row_with_color(i, color, output_grid)\n    return output_grid"},
{"name": "bdad9b1f.json", "data": {"train": [{"input": [[0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 8, 0], [2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 8, 0], [2, 2, 2, 2, 4, 2], [0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 8, 0]]}, {"input": [[0, 8, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[0, 8, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0], [2, 4, 2, 2, 2, 2], [0, 8, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 8, 0, 0], [0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 8, 0, 0], [0, 0, 0, 8, 0, 0], [0, 0, 0, 8, 0, 0], [0, 0, 0, 8, 0, 0], [2, 2, 2, 4, 2, 2], [0, 0, 0, 8, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef paint_pixels(input_grid: np.ndarray, row_index: int, col_index: int) -> np.ndarray:\n    \"\"\"\n    This function takes an input grid, a row index, and a column index and paints the specified pixels with the given colors.\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    row_index: An integer representing the row index of the pixel to be painted yellow\n    col_index: An integer representing the column index of the pixel to be painted yellow\n    \n    Returns:\n    A numpy array representing the modified input grid with the specified pixels painted red, teal, and yellow.\n    \"\"\"\n    input_grid[row_index, :] = red\n    input_grid[:, col_index] = teal\n    input_grid[row_index, col_index] = yellow\n    return input_grid\n\ndef find_row_col_indices(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    This function takes an input grid and returns the row index and column index of the first occurrence of a row with two\n    red pixels and a column with two teal pixels respectively.\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    \n    Returns:\n    A tuple containing the row index and column index of the first occurrence of a row with two red pixels and a column \n    with two teal pixels respectively.\n    \"\"\"\n    row_index = -1\n    col_index = -1\n    for j in range(input_grid.shape[1]):\n        if np.count_nonzero(input_grid[:, j] == teal) == 2:\n            col_index = j\n            break\n    for i in range(input_grid.shape[0]):\n        if np.count_nonzero(input_grid[i, :] == red) == 2:\n            row_index = i\n            break\n    return (row_index, col_index)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    rowIndex, colIndex = find_row_col_indices(input_grid)\n    ans_grid = paint_pixels(input_grid, rowIndex, colIndex)\n    return ans_grid"},
{"name": "25d8a9c8.json", "data": {"train": [{"input": [[4, 4, 4], [2, 3, 2], [2, 3, 3]], "output": [[5, 5, 5], [0, 0, 0], [0, 0, 0]]}, {"input": [[7, 3, 3], [6, 6, 6], [3, 7, 7]], "output": [[0, 0, 0], [5, 5, 5], [0, 0, 0]]}, {"input": [[2, 9, 2], [4, 4, 4], [9, 9, 9]], "output": [[0, 0, 0], [5, 5, 5], [5, 5, 5]]}, {"input": [[2, 2, 4], [2, 2, 4], [1, 1, 1]], "output": [[0, 0, 0], [0, 0, 0], [5, 5, 5]]}], "test": [{"input": [[4, 4, 4], [3, 2, 3], [8, 8, 8]], "output": [[5, 5, 5], [0, 0, 0], [5, 5, 5]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef paint_rows(input_grid: np.ndarray) -> np.ndarray:\n    for row in input_grid:\n        if np.all(row == row[0]):\n            row.fill(grey)\n        else:\n            row.fill(black)\n    return input_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    paint_rows(input_grid)\n    return input_grid"},
{"name": "72322fa7.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 6, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 8, 6, 8, 0, 0, 0, 0, 8, 6, 8, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 8, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 2, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 2, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 2, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 2, 8, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 7, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 7, 3, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 4, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 2, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 3, 7, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 4, 2, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 2, 4, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef same_color_positions(grid1: np.ndarray, grid2: np.ndarray, color: int) -> bool:\n    return np.array_equal(np.where(grid1 == color), np.where(grid2 == color))\n\ndef find_all_colors(grid: np.ndarray) -> List[int]:\n    return [color for color in np.unique(grid) if color != black]\n\ndef find_different_color_neighbours(grid: np.ndarray, i: int, j: int) -> bool:\n    neighbours = grid[i - 1:i + 2, j - 1:j + 2]\n    unique, counts = np.unique(neighbours, return_counts=True)\n    for color, count in zip(unique, counts):\n        if color != black and color != grid[i][j] and (count >= 2):\n            return True\n    return False\n\ndef compare_grids(grid1, grid2):\n    colors = find_all_colors(grid2)\n    for color in colors:\n        if same_color_positions(grid1, grid2, color):\n            return True\n    return False\n\ndef find_patterns(grid: np.ndarray) -> List[np.ndarray]:\n    patterns = []\n    for i in range(1, grid.shape[0] - 1):\n        for j in range(1, grid.shape[1] - 1):\n            if grid[i][j] != black:\n                if find_different_color_neighbours(grid, i, j):\n                    patterns.append(grid[i - 1:i + 2, j - 1:j + 2])\n    return patterns\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    patterns = find_patterns(input_grid)\n    output_grid = input_grid.copy()\n    for i in range(1, input_grid.shape[0] - 1):\n        for j in range(1, input_grid.shape[1] - 1):\n            for pattern in patterns:\n                if compare_grids(output_grid[i - 1:i + 2, j - 1:j + 2], pattern):\n                    output_grid[i - 1:i + 2, j - 1:j + 2] = pattern\n                    break\n    return output_grid"},
{"name": "54d82841.json", "data": {"train": [{"input": [[0, 6, 6, 6, 0, 0, 0, 0], [0, 6, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 0, 6, 0, 6], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 6, 6, 6, 0, 0, 0, 0], [0, 6, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 0, 6, 0, 6], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 4, 0]]}, {"input": [[0, 3, 3, 3, 0], [0, 3, 0, 3, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], "output": [[0, 3, 3, 3, 0], [0, 3, 0, 3, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 4, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0], [0, 8, 0, 8, 6, 6, 6], [0, 0, 0, 0, 6, 0, 6], [0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0], [0, 8, 0, 8, 6, 6, 6], [0, 0, 0, 0, 6, 0, 6], [0, 0, 4, 0, 0, 4, 0]]}], "test": [{"input": [[0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 5, 0, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 8, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 5, 0, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 8, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 4, 0, 0, 4, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_bottom_pixel(p: List[Tuple[int, int]], input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes in a numpy array representing an image and a list of tuples representing the coordinates\n    of all black pixels that have at least 3 non-black neighbors. It colors the bottom pixel in the same column with \n    black pixel in yellow.\n    \n    Args:\n    - p: a list of tuples representing the coordinates of all black pixels that have at least 3 non-black neighbors.\n    - input_grid: a numpy array representing an image\n    \n    Returns:\n    - A numpy array representing the image with the bottom pixel in the same column with black pixel in yellow.\n    \"\"\"\n    for i, j in p:\n        input_grid[-1][j] = yellow\n    return input_grid\n\ndef find_black_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    This function takes in a numpy array representing an image and returns a list of tuples representing the coordinates\n    of all black pixels that have at least 3 non-black neighbors.\n    \n    Args:\n    - input_grid: a numpy array representing an image\n    \n    Returns:\n    - A list of tuples representing the coordinates of all black pixels that have at least 3 non-black neighbors.\n    \"\"\"\n    black_pixels = []\n    for i in range(1, input_grid.shape[0] - 1):\n        for j in range(1, input_grid.shape[1] - 1):\n            if input_grid[i][j] == black:\n                neighbors = [input_grid[i - 1][j], input_grid[i + 1][j], input_grid[i][j - 1], input_grid[i][j + 1]]\n                if neighbors.count(black) == 1:\n                    black_pixels.append((i, j))\n    return black_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    p = find_black_pixels(input_grid)\n    out = color_bottom_pixel(p, input_grid)\n    return out"},
{"name": "dbc1a6ce.json", "data": {"train": [{"input": [[0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 1], [0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 1, 8, 8, 8, 8, 8, 1, 0], [0, 8, 0, 8, 0, 0, 0, 0, 0], [0, 1, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 1, 8, 8, 8, 8, 1, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 8, 8, 8, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 1, 8, 8, 8, 8, 1], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 1, 8, 0, 0, 0, 8, 0], [0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 8, 0], [0, 0, 0, 0, 0, 0, 1, 8, 8, 8, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 8, 8, 8, 1, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 1, 8, 8, 8, 1, 0, 0, 0]]}, {"input": [[0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 1, 8, 8, 1, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 1, 8, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 1, 0, 0, 0], [8, 0, 1, 8, 8, 8, 8, 1, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 1, 8, 8, 1, 8, 8, 8, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 1, 0, 0, 8, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 8, 0, 0, 8, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 8, 0, 0, 8, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 8, 0, 0, 8, 0, 1, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 8, 0, 0, 1, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 1, 8, 8, 8, 8, 8, 8, 8, 1, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 8, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_pixels_in_same_col_to_teal(indices_of_blue_pixels: List[Tuple[int, int]], output_grid: np.ndarray, ibp1: int, ibp2: int) -> np.ndarray:\n    \"\"\"Colors the black pixels to teal between the two blue pixels in the same column.\"\"\"\n    col = indices_of_blue_pixels[ibp1][1]\n    start_row = indices_of_blue_pixels[ibp1][0]\n    end_row = indices_of_blue_pixels[ibp2][0]\n    if start_row > end_row:\n        start_row, end_row = (end_row, start_row)\n    for row in range(start_row + 1, end_row):\n        if output_grid[row][col] == black:\n            output_grid[row][col] = teal\n    return output_grid\n\ndef color_pixels_in_same_row_to_teal(indices_of_blue_pixels: List[Tuple[int, int]], output_grid: np.ndarray, ibp1: int, ibp2: int) -> np.ndarray:\n    \"\"\"Colors the black pixels to teal between the two blue pixels in the same row.\"\"\"\n    row = indices_of_blue_pixels[ibp1][0]\n    start_col = indices_of_blue_pixels[ibp1][1]\n    end_col = indices_of_blue_pixels[ibp2][1]\n    if start_col > end_col:\n        start_col, end_col = (end_col, start_col)\n    for col in range(start_col + 1, end_col):\n        if output_grid[row][col] == black:\n            output_grid[row][col] = teal\n    return output_grid\n\ndef find_blue_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"Returns a list of tuples containing the indices of blue pixels in the input grid.\"\"\"\n    blue_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == blue:\n                blue_pixels.append((i, j))\n    return blue_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you should see blue pixels on the black grid                                                                                                          \n    if two blue pixels are in same row or same col, color the black pixels to teal between the two blue pixels.                                                         \n    \"\"\"\n    output_grid = input_grid.copy()\n    indices_of_blue_pixels = find_blue_pixels(output_grid)\n    for ibp1 in range(len(indices_of_blue_pixels) - 1):\n        for ibp2 in range(ibp1, len(indices_of_blue_pixels)):\n            if indices_of_blue_pixels[ibp1][0] == indices_of_blue_pixels[ibp2][0]:\n                output_grid = color_pixels_in_same_row_to_teal(indices_of_blue_pixels, output_grid, ibp1, ibp2)\n            if indices_of_blue_pixels[ibp1][1] == indices_of_blue_pixels[ibp2][1]:\n                output_grid = color_pixels_in_same_col_to_teal(indices_of_blue_pixels, output_grid, ibp1, ibp2)\n    return output_grid"},
{"name": "3bdb4ada.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 7, 0, 7, 0, 7, 0, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 5, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_middle_rows(input_grid: np.ndarray) -> List[int]:\n    \"\"\"                                                                                                                                                                 \n    Given an input grid, find the middle row of each rectangle shape, in this row, its top and down line are not black.                                                 \n                                                                                                                                                                        \n    Args:                                                                                                                                                               \n    input_grid: A numpy array representing the input grid.                                                                                                              \n                                                                                                                                                                        \n    Returns:                                                                                                                                                            \n    A list of integers representing the row indices of the middle row of each rectangle shape.                                                                          \n    \"\"\"\n    middle_rows = []\n    for i in range(1, input_grid.shape[0] - 1):\n        for j in range(1, input_grid.shape[1] - 1):\n            if input_grid[i][j] != black and input_grid[i - 1][j] != black and (input_grid[i + 1][j] != black):\n                middle_rows.append(i)\n                break\n    return middle_rows\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    find the middle row of each rectangle shape, in this row, it's top and down line are not black.\n    in the row to modify, for the first pixel from left to right that is not black, make is unchange, color the second to black, then third unchange, forth color to black, etc.                                                   \n    \"\"\"\n    output_grid = input_grid.copy()\n    row_indices = find_middle_rows(output_grid)\n    for row in row_indices:\n        count = 0\n        for i in range(output_grid.shape[1]):\n            if output_grid[row][i] != black:\n                count += 1\n            if count % 2 == 0:\n                output_grid[row][i] = black\n    return output_grid"},
{"name": "f8b3ba0a.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 4, 4, 0, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 4, 4, 0, 1, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0, 1, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[4], [2], [3]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 0, 8, 8, 0, 8, 8, 0, 8, 8, 0, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 8, 8, 0, 2, 2, 0, 6, 6, 0, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 8, 8, 0, 1, 1, 0, 8, 8, 0, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 1, 1, 0, 8, 8, 0, 8, 8, 0, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 8, 8, 0, 6, 6, 0, 8, 8, 0, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 8, 8, 0, 8, 8, 0, 8, 8, 0, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[6], [1], [2]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 3, 3, 0, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 3, 3, 0, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 8, 8, 0, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 8, 8, 0, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 2, 2, 0, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 3, 3, 0, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[2], [8], [1]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 8, 8, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0, 1, 1, 0, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 8, 8, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 8, 8, 0, 1, 1, 0, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 8, 8, 0, 1, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8], [2], [4]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 4, 4, 0, 2, 2, 0, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 2, 2, 0, 4, 4, 0, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 2, 2, 0, 2, 2, 0, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 2, 2, 0, 1, 1, 0, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 0, 2, 2, 0, 2, 2, 0, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 1, 1, 0, 2, 2, 0, 4, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 2, 2, 0, 4, 4, 0, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[4], [1], [8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef build_matrix(a: int, b: int, c: int) -> np.ndarray:\n    return np.array([a, b, c]).reshape(3, 1)\n\ndef get_colors(input_grid: np.ndarray) -> Tuple[int, int, int]:\n    \"\"\"\n    This function takes an input grid and returns the third most, fourth most, and fifth most colors in sequence.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A tuple of three integers representing the third most, fourth most, and fifth most colors in sequence.\n    \"\"\"\n    color_counts = np.bincount(input_grid.flatten())\n    sorted_colors = np.argsort(-color_counts)\n    return (sorted_colors[2], sorted_colors[3], sorted_colors[4])\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    a, b, c = get_colors(input_grid)\n    out = build_matrix(a, b, c)\n    return out"},
{"name": "49d1d64f.json", "data": {"train": [{"input": [[1, 2], [3, 8]], "output": [[0, 1, 2, 0], [1, 1, 2, 2], [3, 3, 8, 8], [0, 3, 8, 0]]}, {"input": [[1, 8, 4], [8, 3, 8]], "output": [[0, 1, 8, 4, 0], [1, 1, 8, 4, 4], [8, 8, 3, 8, 8], [0, 8, 3, 8, 0]]}, {"input": [[2, 1, 4], [8, 0, 2], [3, 2, 8]], "output": [[0, 2, 1, 4, 0], [2, 2, 1, 4, 4], [8, 8, 0, 2, 2], [3, 3, 2, 8, 8], [0, 3, 2, 8, 0]]}], "test": [{"input": [[2, 8], [1, 4], [3, 4]], "output": [[0, 2, 8, 0], [2, 2, 8, 8], [1, 1, 4, 4], [3, 3, 4, 4], [0, 3, 4, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef border_pixels_to_adjacent_pixels(output_grid: np.ndarray, h: int, w: int) -> np.ndarray:\n    for j in range(1, w + 1):\n        output_grid[0][j] = output_grid[1][j]\n        output_grid[h + 1][j] = output_grid[h][j]\n    for i in range(1, h + 1):\n        output_grid[i][0] = output_grid[i][1]\n        output_grid[i][w + 1] = output_grid[i][w]\n    return output_grid\n\ndef overlay_input_grid(output_grid: np.ndarray, input_grid: np.ndarray, h: int, w: int) -> np.ndarray:\n    output_grid[1:h + 1, 1:w + 1] = input_grid[0:h, 0:w]\n    return output_grid\n\ndef create_black_image(h: int, w: int) -> np.ndarray:\n    output_grid = np.zeros((h + 2, w + 2), dtype=np.uint8)\n    return output_grid\n\ndef get_height_width(image: np.ndarray) -> Tuple[int, int]:\n    h, w = image.shape[:2]\n    return (h, w)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    h, w = get_height_width(input_grid)\n    output_grid = create_black_image(h, w)\n    output_grid = overlay_input_grid(output_grid, input_grid, h, w)\n    output_grid = border_pixels_to_adjacent_pixels(output_grid, h, w)\n    return output_grid"},
{"name": "d23f8c26.json", "data": {"train": [{"input": [[6, 4, 0], [0, 3, 9], [1, 0, 0]], "output": [[0, 4, 0], [0, 3, 0], [0, 0, 0]]}, {"input": [[8, 0, 3, 0, 0], [8, 6, 5, 6, 0], [3, 6, 3, 0, 0], [0, 0, 0, 5, 9], [5, 0, 9, 0, 0]], "output": [[0, 0, 3, 0, 0], [0, 0, 5, 0, 0], [0, 0, 3, 0, 0], [0, 0, 0, 0, 0], [0, 0, 9, 0, 0]]}, {"input": [[3, 0, 4, 0, 0], [3, 0, 4, 7, 0], [0, 6, 0, 0, 7], [0, 0, 8, 0, 0], [0, 8, 0, 2, 2]], "output": [[0, 0, 4, 0, 0], [0, 0, 4, 0, 0], [0, 0, 0, 0, 0], [0, 0, 8, 0, 0], [0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 3, 0, 0, 0, 7], [8, 1, 0, 8, 0, 0, 0], [0, 0, 3, 0, 8, 0, 3], [0, 7, 0, 1, 0, 7, 0], [0, 0, 0, 0, 0, 0, 0], [1, 0, 8, 6, 0, 0, 0], [0, 8, 0, 6, 0, 1, 0]], "output": [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_middle_column_black(input_grid: np.ndarray) -> np.ndarray:\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if j != input_grid.shape[1] // 2:\n                input_grid[i][j] = black\n    return input_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output = color_middle_column_black(input_grid)\n    return output"},
{"name": "b6afb2da.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 4, 4, 1, 0, 0, 0, 0, 0], [0, 4, 2, 2, 4, 0, 0, 0, 0, 0], [0, 4, 2, 2, 4, 0, 0, 0, 0, 0], [0, 1, 4, 4, 1, 0, 1, 4, 4, 1], [0, 0, 0, 0, 0, 0, 4, 2, 2, 4], [0, 0, 0, 0, 0, 0, 4, 2, 2, 4], [0, 0, 0, 0, 0, 0, 4, 2, 2, 4], [0, 0, 0, 0, 0, 0, 1, 4, 4, 1]]}, {"input": [[5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5]], "output": [[1, 4, 4, 4, 4, 1, 0, 0, 0, 0], [4, 2, 2, 2, 2, 4, 0, 0, 0, 0], [4, 2, 2, 2, 2, 4, 0, 0, 0, 0], [4, 2, 2, 2, 2, 4, 0, 0, 0, 0], [1, 4, 4, 4, 4, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 4, 4, 4, 4, 1], [0, 0, 0, 0, 4, 2, 2, 2, 2, 4], [0, 0, 0, 0, 4, 2, 2, 2, 2, 4], [0, 0, 0, 0, 1, 4, 4, 4, 4, 1]]}], "test": [{"input": [[0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 5, 5, 5, 5, 5]], "output": [[0, 1, 4, 4, 1, 0, 0, 0, 0, 0], [0, 4, 2, 2, 4, 0, 0, 0, 0, 0], [0, 4, 2, 2, 4, 0, 0, 0, 0, 0], [0, 4, 2, 2, 4, 0, 0, 0, 0, 0], [0, 4, 2, 2, 4, 0, 0, 0, 0, 0], [0, 1, 4, 4, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 4, 4, 4, 4, 1], [0, 0, 0, 0, 4, 2, 2, 2, 2, 4], [0, 0, 0, 0, 1, 4, 4, 4, 4, 1]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef paint_black_blue(copy_grid: np.ndarray, grid: np.ndarray) -> np.ndarray:\n    grey_pixels = np.where(copy_grid == grey)\n    for i in range(len(grey_pixels[0])):\n        x, y = (grey_pixels[0][i], grey_pixels[1][i])\n        neighbors = [copy_grid[x, y - 1], copy_grid[x, y + 1], copy_grid[x - 1, y], copy_grid[x + 1, y]]\n        if neighbors.count(black) >= 2:\n            grid[x, y] = blue\n    return grid\n\ndef paint_grey_red(copy_grid: np.ndarray, grid: np.ndarray) -> np.ndarray:\n    grey_pixels = np.where(copy_grid == grey)\n    for i in range(len(grey_pixels[0])):\n        x, y = (grey_pixels[0][i], grey_pixels[1][i])\n        if np.array_equal(copy_grid[x - 1:x + 2, y - 1:y + 2], np.array([[grey] * 3] * 3)):\n            grid[x, y] = red\n    return grid\n\ndef paint_grey_yellow(copy_grid: np.ndarray, grid: np.ndarray) -> np.ndarray:\n    grey_pixels = np.where(copy_grid == grey)\n    grid[grey_pixels] = yellow\n    return grid\n\ndef pad_grid(input_grid: np.ndarray) -> np.ndarray:\n    return np.pad(input_grid, pad_width=1, mode='constant', constant_values=black)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    grid = pad_grid(input_grid)\n    copy_grid = grid.copy()\n    grid = paint_grey_yellow(copy_grid, grid)\n    grid = paint_grey_red(copy_grid, grid)\n    grid = paint_black_blue(copy_grid, grid)\n    return grid[1:-1, 1:-1]"},
{"name": "6455b5f5.json", "data": {"train": [{"input": [[0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2], [0, 2, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 0, 0, 2, 0, 0, 0], [0, 2, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0], [0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2], [0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2], [0, 2, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 0, 0, 2, 0, 0, 0], [0, 2, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0], [0, 2, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2], [0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 8], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]}, {"input": [[0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1]]}, {"input": [[0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 2, 8, 8, 8, 2, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 2, 8, 8, 8, 2, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 2, 8, 8, 8, 2, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 2, 8, 8, 8, 2, 1, 1, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 2, 8, 8, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 8, 8, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 8, 8, 2, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0]], "output": [[0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 8, 8, 8], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 8, 8, 8], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0], [2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 2, 8, 2, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 8, 2, 0, 0, 0], [8, 8, 8, 2, 0, 0, 0, 0, 0, 0, 2, 8, 2, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_smallest_blocks_with_teal(output_grid: np.ndarray, smallest_blocks: List[Tuple[int, int, int, int]]) -> np.ndarray:\n    \"\"\"\n    Replaces the smallest blocks in the output grid with teal color.\n    \n    Args:\n    output_grid: A numpy array representing the output grid.\n    smallest_blocks: A list of tuples representing the smallest blocks. Each tuple contains the coordinates of the top-left and bottom-right corners of the block.\n    \n    Returns:\n    A numpy array representing the output grid with the smallest blocks replaced with teal color.\n    \"\"\"\n    for block in smallest_blocks:\n        output_grid[block[0]:block[2] + 1, block[1]:block[3] + 1] = teal\n    return output_grid\n\ndef replace_largest_blocks_with_blue(input_grid: np.ndarray, largest_blocks: List[Tuple[int, int, int, int]]) -> np.ndarray:\n    \"\"\"\n    Replaces the largest blocks in the input grid with blue color.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    largest_blocks: A list of tuples representing the largest blocks. Each tuple contains the coordinates of the top-left and bottom-right corners of the block.\n    \n    Returns:\n    A numpy array representing the output grid with the largest blocks replaced with blue color.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    for block in largest_blocks:\n        output_grid[block[0]:block[2] + 1, block[1]:block[3] + 1] = blue\n    return output_grid\n\ndef find_largest_and_smallest_blocks(black_blocks: List[Tuple[int, int, int, int]]) -> Tuple[List[Tuple[int, int, int, int]], List[Tuple[int, int, int, int]]]:\n    \"\"\"\n    Finds the largest and smallest blocks in the list of black blocks.\n    \n    Args:\n    black_blocks: A list of tuples representing the blocks of black elements. Each tuple contains the coordinates of the top-left and bottom-right corners of the block.\n    \n    Returns:\n    A tuple containing two lists of tuples. The first list contains the largest blocks and the second list contains the smallest blocks.\n    \"\"\"\n    largest_blocks = []\n    smallest_blocks = []\n    max_area = 0\n    min_area = float('inf')\n    for block in black_blocks:\n        area = (block[2] - block[0] + 1) * (block[3] - block[1] + 1)\n        if area > max_area:\n            max_area = area\n            largest_blocks = [block]\n        elif area == max_area:\n            largest_blocks.append(block)\n        if area < min_area:\n            min_area = area\n            smallest_blocks = [block]\n        elif area == min_area:\n            smallest_blocks.append(block)\n    return (largest_blocks, smallest_blocks)\n\ndef find_black_blocks(input_grid: np.ndarray) -> List[Tuple[int, int, int, int]]:\n    \"\"\"\n    Finds all the black blocks in the input grid separated by red lines.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of tuples representing the black blocks. Each tuple contains the coordinates of the top-left and bottom-right corners of the block.\n    \"\"\"\n    black_blocks = []\n    rows, cols = input_grid.shape\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] == black:\n                top, left = (i, j)\n                bottom, right = (i, j)\n                while bottom < rows - 1 and input_grid[bottom + 1][j] == black:\n                    bottom += 1\n                while right < cols - 1 and input_grid[i][right + 1] == black:\n                    right += 1\n                black_blocks.append((top, left, bottom, right))\n                for k in range(top, bottom + 1):\n                    for l in range(left, right + 1):\n                        input_grid[k][l] = red\n    return black_blocks\n\ndef identity(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns a numpy array identical to the input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A numpy array identical to the input grid.\n    \"\"\"\n    return np.copy(input_grid)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = identity(input_grid)\n    black_blocks = find_black_blocks(input_grid)\n    largest_blocks, smallest_blocks = find_largest_and_smallest_blocks(black_blocks)\n    output_grid = replace_largest_blocks_with_blue(output_grid, largest_blocks)\n    output_grid = replace_smallest_blocks_with_teal(output_grid, smallest_blocks)\n    return output_grid"},
{"name": "bbc9ae5d.json", "data": {"train": [{"input": [[1, 1, 0, 0, 0, 0]], "output": [[1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 0, 0]]}, {"input": [[2, 0, 0, 0, 0, 0, 0, 0]], "output": [[2, 0, 0, 0, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0]]}, {"input": [[5, 5, 5, 0, 0, 0, 0, 0, 0, 0]], "output": [[5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 0, 0, 0]]}, {"input": [[8, 8, 8, 8, 0, 0]], "output": [[8, 8, 8, 8, 0, 0], [8, 8, 8, 8, 8, 0], [8, 8, 8, 8, 8, 8]]}, {"input": [[7, 0, 0, 0, 0, 0]], "output": [[7, 0, 0, 0, 0, 0], [7, 7, 0, 0, 0, 0], [7, 7, 7, 0, 0, 0]]}], "test": [{"input": [[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_left_pixels_in_line_i_with_a(input_grid: np.ndarray, i: int, m: int, a: int) -> np.ndarray:\n    out = input_grid.copy()\n    out[i, :m] = a\n    return out\n\ndef replace_pixels_in_line_i_with_a(input_grid: np.ndarray, i: int, n: int, a: int) -> np.ndarray:\n    m = i + n\n    out = replace_left_pixels_in_line_i_with_a(input_grid, i, m, a)\n    return out\n\ndef get_height(input_grid: np.ndarray) -> int:\n    return input_grid.shape[0]\n\ndef count_pixels_of_color_a_in_first_row(input_grid: np.ndarray, a: int) -> int:\n    return np.count_nonzero(input_grid[0] == a)\n\ndef get_first_pixel_color(input_grid: np.ndarray) -> int:\n    return input_grid[0][0]\n\ndef copy_first_row_to_all_rows(input_grid: np.ndarray) -> np.ndarray:\n    return np.array([input_grid[0]] * input_grid.shape[0])\n\ndef expand_height(input_grid: np.ndarray, h: int) -> np.ndarray:\n    return np.pad(input_grid, ((0, h - input_grid.shape[0]), (0, 0)))\n\ndef get_half_width(input_grid: np.ndarray) -> int:\n    return input_grid.shape[1] // 2\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    h = get_half_width(input_grid)\n    out = expand_height(input_grid, h)\n    out = copy_first_row_to_all_rows(out)\n    a = get_first_pixel_color(out)\n    n = count_pixels_of_color_a_in_first_row(out, a)\n    h = get_height(out)\n    for i in range(1, h):\n        out = replace_pixels_in_line_i_with_a(out, i, n, a)\n    return out"},
{"name": "46442a0e.json", "data": {"train": [{"input": [[8, 6], [6, 8]], "output": [[8, 6, 6, 8], [6, 8, 8, 6], [6, 8, 8, 6], [8, 6, 6, 8]]}, {"input": [[7, 7, 8], [7, 7, 8], [8, 8, 8]], "output": [[7, 7, 8, 8, 7, 7], [7, 7, 8, 8, 7, 7], [8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8], [7, 7, 8, 8, 7, 7], [7, 7, 8, 8, 7, 7]]}, {"input": [[6, 9, 9], [6, 4, 4], [6, 4, 4]], "output": [[6, 9, 9, 6, 6, 6], [6, 4, 4, 4, 4, 9], [6, 4, 4, 4, 4, 9], [9, 4, 4, 4, 4, 6], [9, 4, 4, 4, 4, 6], [6, 6, 6, 9, 9, 6]]}], "test": [{"input": [[1, 4, 1], [4, 9, 4], [9, 1, 9]], "output": [[1, 4, 1, 9, 4, 1], [4, 9, 4, 1, 9, 4], [9, 1, 9, 9, 4, 1], [1, 4, 9, 9, 1, 9], [4, 9, 1, 4, 9, 4], [1, 4, 9, 1, 4, 1]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef put_input_grid_at_bottom_left(input_grid: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    output_grid[-input_grid.shape[0]:, :input_grid.shape[1]] = input_grid\n    return output_grid\n\ndef put_input_grid_at_bottom_right(input_grid: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    output_grid[-input_grid.shape[0]:, -input_grid.shape[1]:] = input_grid\n    return output_grid\n\ndef put_input_grid_at_top_right(input_grid: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    output_grid[:input_grid.shape[0], -input_grid.shape[1]:] = input_grid\n    return output_grid\n\ndef rotate_90_degrees_clockwise(input_grid: np.ndarray) -> np.ndarray:\n    return np.rot90(input_grid, k=-1)\n\ndef put_input_grid_at_top_left(input_grid: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    output_grid[:input_grid.shape[0], :input_grid.shape[1]] = input_grid\n    return output_grid\n\ndef get_empty_grid(input_grid: np.ndarray) -> np.ndarray:\n    return np.zeros((input_grid.shape[0] * 2, input_grid.shape[1] * 2))\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = get_empty_grid(input_grid)\n    output_grid = put_input_grid_at_top_left(input_grid, output_grid)\n    input_grid = rotate_90_degrees_clockwise(input_grid)\n    output_grid = put_input_grid_at_top_right(input_grid, output_grid)\n    input_grid = rotate_90_degrees_clockwise(input_grid)\n    output_grid = put_input_grid_at_bottom_right(input_grid, output_grid)\n    input_grid = rotate_90_degrees_clockwise(input_grid)\n    output_grid = put_input_grid_at_bottom_left(input_grid, output_grid)\n    return output_grid"},
{"name": "a699fb00.json", "data": {"train": [{"input": [[1, 0, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 0, 0]], "output": [[1, 2, 1, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 2, 1, 0], [0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 1, 2, 1, 2, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 2, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 2, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 2, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 2, 1, 0], [0, 1, 2, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 2, 1, 2, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 2, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 1, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 1, 2, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 2, 1, 2, 1, 2, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 2, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 2, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_black_pixels_red(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes in a numpy array representing an image grid and colors the black pixels red, whose left and right\n    neighbors are both blue. It returns the modified image grid as a numpy array.\n    \n    Args:\n    input_grid: A numpy array representing an image grid\n    \n    Returns:\n    A numpy array representing the modified image grid\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    for i in range(output_grid.shape[0]):\n        for j in range(output_grid.shape[1]):\n            if output_grid[i][j] == black:\n                if j > 0 and j < output_grid.shape[1] - 1 and (output_grid[i][j - 1] == blue) and (output_grid[i][j + 1] == blue):\n                    output_grid[i][j] = red\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = color_black_pixels_red(input_grid)\n    return output_grid"},
{"name": "1b60fb0c.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 1, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 2, 2, 0, 1, 1, 1, 1, 1, 0], [0, 2, 2, 2, 1, 1, 0, 1, 1, 0], [0, 2, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 2, 2, 0, 0, 1, 0, 0, 1, 1], [0, 2, 2, 0, 0, 1, 0, 0, 1, 1], [0, 2, 2, 2, 2, 1, 1, 1, 1, 1], [0, 2, 2, 0, 0, 1, 0, 0, 1, 1], [0, 2, 2, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 2, 0, 0, 1, 1, 1, 0, 0, 1], [0, 2, 0, 2, 0, 1, 0, 1, 0, 1], [0, 2, 2, 2, 2, 1, 1, 1, 1, 1], [0, 2, 0, 2, 0, 1, 0, 1, 0, 1], [0, 2, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [0, 2, 0, 0, 1, 0, 0, 0, 1, 0], [0, 2, 2, 0, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 1, 1, 0, 1, 1, 0], [0, 2, 0, 0, 0, 1, 0, 0, 1, 0], [0, 2, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef turn_black_to_red(grid: np.ndarray, point: Tuple[int, int]) -> np.ndarray:\n    x, y = point\n    if grid[x][y] == black:\n        grid[x][y] = red\n    return grid\n\ndef generate_blue_coordinates(grid: np.ndarray) -> List[Tuple[int, int]]:\n    rows, cols = grid.shape\n    blue_coordinates = []\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == blue:\n                blue_coordinates.append((i, j))\n    return blue_coordinates\n\ndef find_first_and_last_blue_points(grid: np.ndarray) -> Tuple[int, int, int, int]:\n    rows, cols = grid.shape\n    x1, y1, x2, y2 = (-1, -1, -1, -1)\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == blue:\n                if x1 == -1:\n                    x1, y1 = (i, j)\n                x2, y2 = (i, j)\n    return (x1, y1, x2, y2)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n    x1, y1, x2, y2 = find_first_and_last_blue_points(output_grid)\n    listb = generate_blue_coordinates(output_grid)\n    for x, y in listb:\n        x3, y3 = (x1 + x2 - x, y1 + y2 - y)\n        output_grid = turn_black_to_red(output_grid, (x3, y3))\n    return output_grid"},
{"name": "5614dbcf.json", "data": {"train": [{"input": [[3, 3, 3, 0, 0, 0, 8, 8, 8], [3, 3, 3, 0, 0, 0, 8, 5, 8], [3, 3, 3, 0, 0, 0, 8, 8, 8], [0, 0, 0, 7, 5, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 7, 0, 0, 0], [6, 6, 6, 0, 0, 5, 9, 9, 9], [6, 6, 6, 0, 0, 0, 9, 9, 9], [6, 5, 6, 0, 5, 0, 9, 9, 5]], "output": [[3, 0, 8], [0, 7, 0], [6, 0, 9]]}, {"input": [[0, 0, 0, 2, 2, 2, 0, 0, 0], [0, 5, 0, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 0, 0], [5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 7, 7, 7, 0, 0, 0], [0, 0, 0, 7, 7, 5, 0, 0, 0], [0, 0, 0, 7, 7, 7, 0, 0, 0]], "output": [[0, 2, 0], [0, 0, 0], [0, 7, 0]]}], "test": [{"input": [[4, 4, 4, 0, 0, 0, 0, 5, 0], [5, 4, 4, 0, 0, 0, 0, 0, 0], [4, 4, 4, 0, 5, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 0, 5, 0], [0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 5, 9, 9, 9, 0, 0, 0], [0, 0, 0, 9, 5, 9, 0, 0, 0], [0, 0, 0, 9, 9, 9, 0, 0, 0]], "output": [[4, 0, 0], [0, 3, 0], [0, 9, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef highest_frequency_number(grid: np.ndarray) -> int:\n    \"\"\"\n    Given a 3x3 grid of integers, returns the integer that appears most frequently in the grid.\n    \n    Args:\n    grid: A 3x3 numpy array of integers\n    \n    Returns:\n    The integer that appears most frequently in the grid.\n    \"\"\"\n    flat_grid = grid.flatten()\n    unique, counts = np.unique(flat_grid, return_counts=True)\n    return unique[np.argmax(counts)]\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = [[0] * 3 for _ in range(3)]\n    for i in range(3):\n        for j in range(3):\n            output_grid[i][j] = highest_frequency_number(input_grid[3 * i:3 * i + 3, 3 * j:3 * j + 3])\n    return output_grid"},
{"name": "3428a4f5.json", "data": {"train": [{"input": [[0, 0, 0, 2, 2], [0, 0, 2, 0, 2], [2, 0, 0, 2, 2], [2, 2, 0, 0, 2], [0, 0, 0, 0, 2], [0, 2, 0, 0, 0], [4, 4, 4, 4, 4], [2, 0, 0, 0, 0], [2, 2, 0, 0, 0], [2, 0, 2, 0, 0], [0, 0, 2, 0, 0], [0, 0, 0, 2, 2], [2, 0, 0, 2, 0]], "output": [[3, 0, 0, 3, 3], [3, 3, 3, 0, 3], [0, 0, 3, 3, 3], [3, 3, 3, 0, 3], [0, 0, 0, 3, 0], [3, 3, 0, 3, 0]]}, {"input": [[0, 2, 2, 2, 2], [0, 0, 0, 0, 2], [2, 0, 2, 2, 2], [0, 0, 2, 2, 0], [2, 2, 2, 2, 0], [2, 2, 0, 0, 2], [4, 4, 4, 4, 4], [0, 0, 0, 0, 0], [0, 0, 2, 0, 0], [2, 0, 0, 0, 2], [0, 0, 0, 2, 0], [0, 2, 0, 2, 0], [0, 2, 2, 2, 0]], "output": [[0, 3, 3, 3, 3], [0, 0, 3, 0, 3], [0, 0, 3, 3, 0], [0, 0, 3, 0, 0], [3, 0, 3, 0, 0], [3, 0, 3, 3, 3]]}, {"input": [[2, 2, 0, 2, 2], [2, 0, 2, 2, 2], [2, 0, 0, 0, 0], [0, 2, 0, 2, 0], [2, 2, 2, 0, 2], [2, 0, 2, 0, 0], [4, 4, 4, 4, 4], [2, 0, 0, 2, 2], [0, 0, 2, 0, 2], [2, 2, 0, 0, 0], [0, 0, 2, 0, 2], [0, 2, 0, 2, 2], [0, 2, 2, 0, 2]], "output": [[0, 3, 0, 0, 0], [3, 0, 0, 3, 0], [0, 3, 0, 0, 0], [0, 3, 3, 3, 3], [3, 0, 3, 3, 0], [3, 3, 0, 0, 3]]}, {"input": [[0, 2, 0, 2, 0], [2, 2, 0, 2, 2], [0, 2, 2, 2, 0], [0, 2, 2, 0, 0], [0, 2, 2, 2, 2], [2, 0, 2, 0, 2], [4, 4, 4, 4, 4], [2, 0, 2, 2, 2], [0, 2, 2, 0, 0], [2, 0, 2, 0, 2], [2, 0, 0, 0, 2], [2, 2, 0, 2, 0], [2, 0, 2, 2, 0]], "output": [[3, 3, 3, 0, 3], [3, 0, 3, 3, 3], [3, 3, 0, 3, 3], [3, 3, 3, 0, 3], [3, 0, 3, 0, 3], [0, 0, 0, 3, 3]]}], "test": [{"input": [[2, 0, 2, 2, 0], [2, 0, 0, 2, 2], [2, 2, 2, 0, 0], [2, 2, 2, 2, 2], [0, 2, 2, 0, 0], [2, 2, 2, 2, 2], [4, 4, 4, 4, 4], [0, 0, 0, 2, 2], [2, 0, 0, 0, 2], [2, 2, 2, 0, 2], [0, 2, 2, 0, 0], [2, 0, 2, 2, 0], [2, 0, 2, 2, 2]], "output": [[3, 0, 3, 0, 3], [0, 0, 0, 3, 0], [0, 0, 0, 0, 3], [3, 0, 0, 3, 3], [3, 3, 0, 3, 0], [0, 3, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef process_pixels(input_grid: np.ndarray, mindex: int, ngrid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Traverse all pixels whose row number is less than mindex in inputgrid, set the pixel coordinates as (x, y),\n    if the value of the pixel is the same as the value of (x + mindex + 1, y), then change the value of ngrid (x, y) to zero;\n    change to green if different.\n    Return the ngrid\n    \"\"\"\n    for i in range(mindex):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == input_grid[i + mindex + 1][j]:\n                ngrid[i][j] = 0\n            else:\n                ngrid[i][j] = green\n    return ngrid\n\ndef find_yellow_line_index(input_grid: np.ndarray) -> int:\n    \"\"\"\n    This function takes in a n*n grid with multiple color pixels and returns the index of the first yellow line found.\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        if np.array_equal(input_grid[i], np.array([yellow] * input_grid.shape[1])):\n            return i\n    return -1\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    mindex = find_yellow_line_index(input_grid)\n    ngrid = np.zeros((input_grid.shape[0] // 2, input_grid.shape[1]))\n    ans_grid = process_pixels(input_grid, mindex, ngrid)\n    return ans_grid"},
{"name": "8f2ea7aa.json", "data": {"train": [{"input": [[8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 8, 0, 8, 8, 0, 0, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 0], [8, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 8, 0, 0], [8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 0, 0, 7, 7], [0, 0, 0, 0, 0, 0, 7, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 7], [0, 0, 0, 0, 7, 7, 0, 7, 7], [0, 0, 0, 7, 0, 0, 7, 0, 0], [0, 0, 7, 0, 0, 0, 0, 0, 0], [0, 7, 7, 0, 0, 0, 0, 0, 0], [7, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 6, 0, 6, 0, 0, 0], [0, 0, 0, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 6, 0, 6, 0, 0, 0], [0, 0, 0, 6, 6, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 6, 0], [6, 0, 6, 0, 0, 0, 6, 0, 6], [6, 6, 0, 0, 0, 0, 6, 6, 0], [0, 6, 0, 0, 6, 0, 0, 0, 0], [6, 0, 6, 6, 0, 6, 0, 0, 0], [6, 6, 0, 6, 6, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 0], [2, 0, 0, 2, 0, 0, 0, 0, 0], [2, 2, 0, 2, 2, 0, 0, 0, 0], [0, 2, 2, 0, 2, 2, 0, 0, 0], [0, 0, 0, 2, 0, 0, 2, 0, 0], [0, 0, 0, 2, 2, 0, 2, 2, 0], [0, 0, 0, 0, 2, 2, 0, 2, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef map_3x3_to_9x9(input_square: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Maps the input 3x3 square to a 9x9 grid, where if a pixel in the input square is black, then the corresponding\n    pixels in the output grid are also black. Otherwise, the input square is copied to the corresponding location in\n    the output grid.\n\n    Args:\n    input_square: A numpy array of shape (3, 3) representing the input square.\n\n    Returns:\n    A numpy array of shape (9, 9) representing the output grid.\n    \"\"\"\n    output_grid = np.zeros((9, 9))\n    for i in range(3):\n        for j in range(3):\n            if input_square[i][j] != black:\n                output_grid[3 * i:3 * i + 3, 3 * j:3 * j + 3] = input_square\n    return output_grid\n\ndef has_color_pixel(square: np.ndarray) -> bool:\n    \"\"\"\n    Checks if the given square has at least one pixel of color other than black.\n\n    Args:\n    square: A numpy array of shape (3, 3) representing the input square.\n\n    Returns:\n    A boolean value indicating whether the square has at least one pixel of color other than black.\n    \"\"\"\n    return np.any(square != black)\n\ndef split_grid(input_grid: np.ndarray) -> List[np.ndarray]:\n    \"\"\"\n    Splits the input grid into 9 small squares of size 3x3.\n\n    Args:\n    input_grid: A numpy array of shape (9, 9) representing the input grid.\n\n    Returns:\n    A list of 9 numpy arrays, each of shape (3, 3), representing the small squares.\n    \"\"\"\n    squares = []\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            square = input_grid[i:i + 3, j:j + 3]\n            squares.append(square)\n    return squares\n\ndef transform_grid(input_grid: np.ndarray):\n    squares = split_grid(input_grid)\n    colorful_square = None\n    for square in squares:\n        if has_color_pixel(square):\n            colorful_square = square\n    output_grid = map_3x3_to_9x9(colorful_square)\n    return output_grid"},
{"name": "9ecd008a.json", "data": {"train": [{"input": [[2, 1, 3, 5, 1, 1, 1, 8, 8, 1, 1, 1, 5, 3, 1, 2], [1, 2, 5, 7, 1, 7, 8, 8, 8, 8, 7, 1, 7, 5, 2, 1], [3, 5, 4, 4, 1, 8, 2, 9, 9, 2, 8, 1, 4, 4, 5, 3], [5, 7, 4, 4, 8, 8, 9, 2, 2, 9, 8, 8, 4, 4, 7, 5], [1, 1, 1, 8, 4, 4, 1, 1, 1, 1, 4, 4, 8, 1, 1, 1], [1, 7, 8, 8, 0, 0, 0, 9, 9, 1, 7, 4, 8, 8, 7, 1], [1, 8, 2, 9, 0, 0, 0, 3, 3, 1, 1, 1, 9, 2, 8, 1], [8, 8, 9, 2, 0, 0, 0, 1, 1, 3, 9, 1, 2, 9, 8, 8], [8, 8, 9, 2, 1, 9, 3, 1, 1, 3, 9, 1, 2, 9, 8, 8], [1, 8, 2, 9, 1, 1, 1, 3, 3, 1, 1, 1, 9, 2, 8, 1], [1, 7, 8, 8, 4, 7, 1, 9, 9, 1, 7, 4, 8, 8, 7, 1], [1, 1, 1, 8, 4, 4, 1, 1, 1, 1, 4, 4, 8, 1, 1, 1], [5, 7, 4, 4, 8, 8, 9, 2, 2, 9, 8, 8, 4, 4, 7, 5], [3, 5, 4, 4, 1, 8, 2, 9, 9, 2, 8, 1, 4, 4, 5, 3], [1, 2, 5, 7, 1, 7, 8, 8, 8, 8, 7, 1, 7, 5, 2, 1], [2, 1, 3, 5, 1, 1, 1, 8, 8, 1, 1, 1, 5, 3, 1, 2]], "output": [[4, 7, 1], [1, 1, 1], [1, 9, 3]]}, {"input": [[3, 3, 3, 1, 7, 7, 6, 6, 6, 6, 7, 7, 1, 3, 3, 3], [3, 3, 1, 3, 7, 7, 6, 1, 1, 6, 7, 7, 3, 1, 3, 3], [3, 1, 8, 8, 6, 6, 9, 7, 7, 9, 6, 6, 8, 8, 1, 3], [1, 3, 8, 5, 6, 1, 7, 9, 9, 7, 1, 6, 5, 8, 3, 1], [7, 7, 6, 6, 3, 3, 5, 1, 1, 5, 3, 3, 6, 6, 7, 7], [7, 7, 6, 1, 3, 3, 1, 1, 1, 1, 3, 3, 1, 6, 7, 7], [6, 6, 9, 7, 5, 1, 6, 1, 1, 6, 1, 5, 7, 9, 6, 6], [6, 1, 7, 9, 1, 1, 1, 4, 4, 1, 1, 1, 9, 7, 1, 6], [6, 1, 7, 9, 0, 0, 0, 4, 4, 1, 1, 1, 9, 7, 1, 6], [6, 6, 9, 7, 0, 0, 0, 1, 1, 6, 1, 5, 7, 9, 6, 6], [7, 7, 6, 1, 0, 0, 0, 1, 1, 1, 3, 3, 1, 6, 7, 7], [7, 7, 6, 6, 3, 3, 5, 1, 1, 5, 3, 3, 6, 6, 7, 7], [1, 3, 8, 5, 6, 1, 7, 9, 9, 7, 1, 6, 5, 8, 3, 1], [3, 1, 8, 8, 6, 6, 9, 7, 7, 9, 6, 6, 8, 8, 1, 3], [3, 3, 1, 3, 7, 7, 6, 1, 1, 6, 7, 7, 3, 1, 3, 3], [3, 3, 3, 1, 7, 7, 6, 6, 6, 6, 7, 7, 1, 3, 3, 3]], "output": [[1, 1, 1], [5, 1, 6], [3, 3, 1]]}, {"input": [[9, 3, 5, 3, 3, 9, 5, 5, 5, 5, 9, 3, 3, 5, 3, 9], [3, 9, 3, 6, 9, 5, 5, 8, 8, 5, 5, 9, 6, 3, 9, 3], [5, 3, 3, 3, 5, 5, 6, 6, 6, 6, 5, 5, 3, 3, 3, 5], [3, 6, 3, 6, 5, 8, 6, 6, 6, 6, 8, 5, 6, 3, 6, 3], [3, 9, 5, 5, 5, 5, 2, 1, 1, 2, 5, 5, 5, 5, 9, 3], [9, 5, 5, 8, 5, 8, 1, 6, 6, 1, 8, 5, 8, 5, 5, 9], [5, 5, 6, 6, 2, 1, 9, 3, 3, 9, 1, 2, 6, 6, 5, 5], [5, 8, 6, 6, 1, 6, 3, 9, 9, 3, 0, 0, 0, 6, 8, 5], [5, 8, 6, 6, 1, 6, 3, 9, 9, 3, 0, 0, 0, 6, 8, 5], [5, 5, 6, 6, 2, 1, 9, 3, 3, 9, 0, 0, 0, 6, 5, 5], [9, 5, 5, 8, 5, 8, 1, 6, 6, 1, 8, 5, 8, 5, 5, 9], [3, 9, 5, 5, 5, 5, 2, 1, 1, 2, 5, 5, 5, 5, 9, 3], [3, 6, 3, 6, 5, 8, 6, 6, 6, 6, 8, 5, 6, 3, 6, 3], [5, 3, 3, 3, 5, 5, 6, 6, 6, 6, 5, 5, 3, 3, 3, 5], [3, 9, 3, 6, 9, 5, 5, 8, 8, 5, 5, 9, 6, 3, 9, 3], [9, 3, 5, 3, 3, 9, 5, 5, 5, 5, 9, 3, 3, 5, 3, 9]], "output": [[6, 1, 6], [6, 1, 6], [1, 2, 6]]}], "test": [{"input": [[4, 8, 9, 9, 6, 6, 5, 1, 1, 5, 6, 6, 9, 9, 8, 4], [8, 6, 9, 9, 6, 7, 1, 5, 5, 1, 7, 6, 9, 9, 6, 8], [9, 9, 5, 2, 5, 1, 5, 5, 5, 5, 1, 5, 2, 5, 9, 9], [9, 9, 2, 2, 1, 5, 5, 9, 9, 5, 5, 1, 2, 2, 9, 9], [6, 6, 5, 1, 1, 4, 5, 2, 2, 5, 4, 1, 1, 5, 6, 6], [6, 0, 0, 0, 4, 4, 2, 7, 7, 2, 4, 4, 5, 1, 7, 6], [5, 0, 0, 0, 5, 2, 9, 5, 5, 9, 2, 5, 5, 5, 1, 5], [1, 0, 0, 0, 2, 7, 5, 9, 9, 5, 7, 2, 9, 5, 5, 1], [1, 5, 5, 9, 2, 7, 5, 9, 9, 5, 7, 2, 9, 5, 5, 1], [5, 1, 5, 5, 5, 2, 9, 5, 5, 9, 2, 5, 5, 5, 1, 5], [6, 7, 1, 5, 4, 4, 2, 7, 7, 2, 4, 4, 5, 1, 7, 6], [6, 6, 5, 1, 1, 4, 5, 2, 2, 5, 4, 1, 1, 5, 6, 6], [9, 9, 2, 2, 1, 5, 5, 9, 9, 5, 5, 1, 2, 2, 9, 9], [9, 9, 5, 2, 5, 1, 5, 5, 5, 5, 1, 5, 2, 5, 9, 9], [8, 6, 9, 9, 6, 7, 1, 5, 5, 1, 7, 6, 9, 9, 6, 8], [4, 8, 9, 9, 6, 6, 5, 1, 1, 5, 6, 6, 9, 9, 8, 4]], "output": [[7, 1, 5], [1, 5, 5], [5, 5, 9]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef rotate_and_subgrid(input_grid: np.ndarray, tx: int, ty: int) -> np.ndarray:\n    \"\"\"\n    Rotate the input grid 90 degrees clockwise, and return the subgrid with (tx,ty) as the upper left corner and shape as (3,3)\n    \"\"\"\n    rotated_grid = np.rot90(input_grid)\n    subgrid = rotated_grid[tx:tx + 3, ty:ty + 3]\n    return subgrid\n\ndef find_first_black_pixel(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Traverse the input grid from top to bottom, from left to right, and return the coordinates of the first black pixel (tx, ty)\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == black:\n                return (i, j)\n    return (-1, -1)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    tx, ty = find_first_black_pixel(input_grid)\n    ans_grid = rotate_and_subgrid(input_grid, tx, ty)\n    return ans_grid"},
{"name": "c3f564a4.json", "data": {"train": [{"input": [[1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1], [2, 0, 0, 0, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2], [3, 0, 0, 0, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3], [4, 0, 0, 0, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4], [5, 0, 0, 0, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 0, 0, 5, 1], [2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 0, 0, 1, 2], [3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3], [4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4], [5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 0, 0, 0, 0, 4, 5], [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 0, 0, 0, 0, 5, 1], [2, 3, 4, 5, 1, 2, 0, 0, 0, 1, 0, 0, 0, 0, 1, 2], [3, 4, 5, 1, 2, 3, 0, 0, 0, 0, 3, 4, 5, 1, 2, 3], [4, 5, 1, 2, 3, 4, 0, 0, 0, 0, 4, 5, 1, 2, 3, 4], [5, 1, 2, 3, 4, 5, 0, 0, 0, 0, 5, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1]], "output": [[1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1], [2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2], [3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3], [4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4], [5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1], [2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2], [3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3], [4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4], [5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1], [2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2], [3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3], [4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4], [5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1]]}, {"input": [[1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4], [2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5], [3, 4, 5, 6, 1, 2, 0, 0, 5, 6, 1, 2, 3, 4, 5, 6], [4, 5, 6, 1, 2, 0, 0, 0, 6, 1, 2, 3, 4, 5, 6, 1], [5, 6, 1, 2, 3, 0, 0, 0, 1, 2, 3, 4, 5, 6, 1, 2], [6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3], [1, 2, 3, 4, 5, 6, 1, 2, 0, 0, 0, 6, 1, 2, 3, 4], [2, 3, 4, 5, 6, 1, 2, 3, 0, 0, 0, 0, 2, 3, 4, 5], [3, 4, 5, 6, 1, 2, 3, 4, 0, 0, 0, 0, 3, 4, 5, 6], [0, 0, 0, 0, 2, 3, 4, 5, 0, 0, 0, 0, 4, 5, 6, 1], [0, 0, 0, 0, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2], [0, 0, 0, 0, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3], [0, 0, 0, 0, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4], [2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5], [3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6], [4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1]], "output": [[1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4], [2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5], [3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6], [4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1], [5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2], [6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3], [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4], [2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5], [3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6], [4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1], [5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2], [6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3], [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4], [2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5], [3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6], [4, 5, 6, 1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6, 1]]}, {"input": [[1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2], [2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3], [3, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4], [4, 0, 0, 0, 0, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5], [5, 0, 0, 0, 0, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6], [6, 0, 0, 0, 0, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7], [7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1], [1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2], [2, 0, 0, 0, 0, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3], [3, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4], [4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 0, 0, 4, 5], [5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 0, 0, 5, 6], [6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 0, 0, 0, 0, 7], [7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 0, 0, 0, 0, 1], [1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 0, 0, 0, 0, 2], [2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3]], "output": [[1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2], [2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3], [3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4], [4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5], [5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6], [6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7], [7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1], [1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2], [2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3], [3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4], [4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5], [5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6], [6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7], [7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1], [1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2], [2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3]]}], "test": [{"input": [[1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 3, 4, 5, 6, 7, 8], [2, 3, 4, 5, 6, 7, 8, 0, 0, 0, 4, 5, 6, 7, 8, 1], [3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2], [4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3], [5, 6, 0, 0, 0, 0, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4], [6, 7, 0, 0, 0, 0, 0, 0, 0, 7, 8, 1, 2, 3, 4, 5], [7, 8, 0, 0, 0, 0, 0, 0, 0, 8, 1, 2, 3, 4, 5, 6], [8, 1, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7], [1, 2, 3, 4, 5, 0, 0, 0, 0, 2, 3, 4, 5, 6, 7, 8], [2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1], [3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2], [4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3], [5, 6, 7, 8, 1, 2, 3, 0, 0, 6, 7, 8, 1, 2, 3, 4], [6, 7, 8, 1, 2, 3, 4, 0, 0, 7, 8, 1, 2, 3, 4, 5], [7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6], [8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7]], "output": [[1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1], [3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2], [4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3], [5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4], [6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5], [7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6], [8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7], [1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8], [2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1], [3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2], [4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3], [5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4], [6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5], [7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6], [8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_black_pixel_with_neighbour_color(grid: np.ndarray, locs: Tuple) -> np.ndarray:\n    for i in range(len(locs[0])):\n        row, col = (locs[0][i], locs[1][i])\n        if row < grid.shape[0] - 1 and col > 0 and (grid[row + 1][col - 1] != black):\n            grid[row][col] = grid[row + 1][col - 1]\n        elif row > 0 and col < grid.shape[1] - 1 and (grid[row - 1][col + 1] != black):\n            grid[row][col] = grid[row - 1][col + 1]\n    return grid\n\ndef find_black_pixel_locations(grid: np.ndarray) -> Tuple:\n    return np.where(grid == black)\n\ndef has_black_pixel(grid: np.ndarray) -> bool:\n    return np.any(grid == black)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = input_grid\n    while has_black_pixel(output_grid):\n        locs = find_black_pixel_locations(output_grid)\n        output_grid = replace_black_pixel_with_neighbour_color(output_grid, locs)\n    return output_grid"},
{"name": "7b7f7511.json", "data": {"train": [{"input": [[1, 1, 3, 2, 1, 1, 3, 2], [1, 1, 3, 3, 1, 1, 3, 3], [3, 3, 1, 1, 3, 3, 1, 1], [2, 3, 1, 1, 2, 3, 1, 1]], "output": [[1, 1, 3, 2], [1, 1, 3, 3], [3, 3, 1, 1], [2, 3, 1, 1]]}, {"input": [[4, 4, 4, 4, 4, 4], [6, 4, 8, 6, 4, 8], [6, 6, 8, 6, 6, 8]], "output": [[4, 4, 4], [6, 4, 8], [6, 6, 8]]}, {"input": [[2, 3], [3, 2], [4, 4], [2, 3], [3, 2], [4, 4]], "output": [[2, 3], [3, 2], [4, 4]]}], "test": [{"input": [[5, 4, 5], [4, 5, 4], [6, 6, 4], [2, 6, 2], [5, 4, 5], [4, 5, 4], [6, 6, 4], [2, 6, 2]], "output": [[5, 4, 5], [4, 5, 4], [6, 6, 4], [2, 6, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef split_pattern(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    The input is composed of two same pattern. Try to split the input vertically or horizontally, \n    to see if the two parts are the same. If same, return one pattern.\n    \"\"\"\n    height, width = input_grid.shape\n    if np.array_equal(input_grid[:height // 2, :], input_grid[height // 2:, :]):\n        return input_grid[:height // 2, :]\n    elif np.array_equal(input_grid[:, :width // 2], input_grid[:, width // 2:]):\n        return input_grid[:, :width // 2]\n    else:\n        return input_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    pattern = split_pattern(input_grid)\n    return pattern"},
{"name": "1cf80156.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 2, 2, 2], [0, 0, 2, 0], [2, 2, 2, 0], [2, 0, 2, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[1, 0, 0], [1, 1, 0], [0, 1, 0], [1, 1, 1], [0, 0, 1]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 8, 0, 8, 0], [8, 8, 8, 8, 0], [0, 0, 0, 8, 8]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 6, 6, 6, 6], [0, 0, 6, 0, 0, 0], [6, 0, 6, 0, 0, 0], [6, 6, 6, 6, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_smallest_rect(non_black_pixels: Tuple[np.ndarray, np.ndarray], input_grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Given a numpy array _hole13 and a tuple of numpy arrays _hole15 containing the indices of non-black pixels,\n    this function returns the smallest rectangle that contains all the non-black pixels in the input grid.\n    \n    Args:\n    - non_black_pixels (Tuple[np.ndarray, np.ndarray]): A tuple of numpy arrays containing the row and column indices of non-black pixels.\n    - input_grid (np.ndarray): A numpy array representing the input grid.\n    \n    Returns:\n    - A tuple of integers (top, left, bottom, right) representing the smallest rectangle that contains all the non-black pixels in the input grid.\n    \"\"\"\n    top = np.min(non_black_pixels[0])\n    left = np.min(non_black_pixels[1])\n    bottom = np.max(non_black_pixels[0])\n    right = np.max(non_black_pixels[1])\n    return (top, left, bottom + 1, right + 1)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    non_black_pixels = np.where(input_grid != black)\n    smallest_rect = find_smallest_rect(non_black_pixels, input_grid)\n    output_grid = input_grid[smallest_rect[0]:smallest_rect[2], smallest_rect[1]:smallest_rect[3]]\n    return output_grid"},
{"name": "9dfd6313.json", "data": {"train": [{"input": [[5, 0, 0], [3, 5, 0], [0, 0, 5]], "output": [[5, 3, 0], [0, 5, 0], [0, 0, 5]]}, {"input": [[5, 0, 0, 0], [0, 5, 0, 0], [6, 0, 5, 0], [6, 0, 4, 5]], "output": [[5, 0, 6, 6], [0, 5, 0, 0], [0, 0, 5, 4], [0, 0, 0, 5]]}, {"input": [[5, 0, 0, 0, 0], [0, 5, 0, 0, 0], [8, 8, 5, 0, 0], [0, 2, 0, 5, 0], [0, 2, 0, 1, 5]], "output": [[5, 0, 8, 0, 0], [0, 5, 8, 2, 2], [0, 0, 5, 0, 0], [0, 0, 0, 5, 1], [0, 0, 0, 0, 5]]}], "test": [{"input": [[5, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0], [3, 3, 5, 0, 0, 0], [0, 0, 0, 5, 0, 0], [2, 0, 8, 8, 5, 0], [2, 0, 6, 0, 0, 5]], "output": [[5, 0, 3, 0, 2, 2], [0, 5, 3, 0, 0, 0], [0, 0, 5, 0, 8, 6], [0, 0, 0, 5, 8, 0], [0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 5]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef rotate_cw(input_grid: np.ndarray) -> np.ndarray:\n    return np.rot90(input_grid, k=-1)\n\ndef flip_ud(input_grid: np.ndarray) -> np.ndarray:\n    return np.flipud(input_grid)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    out_grid = flip_ud(input_grid)\n    out_grid = rotate_cw(out_grid)\n    return out_grid"},
{"name": "c444b776.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 7, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0, 4, 0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 3, 0, 0, 0, 4, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 7, 0, 0, 0, 0, 4, 0, 0, 0, 8, 7, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 3, 0, 4, 0, 0, 0, 0, 8, 0, 0, 3, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0, 4, 0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 4, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 3, 0, 0, 0, 4, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 7, 0, 0, 0, 0, 4, 0, 0, 0, 8, 7, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 3, 0, 4, 0, 0, 0, 0, 8, 0, 0, 3, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 4, 0, 7, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 2, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 2, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 2, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 3, 0, 0, 0, 0, 0, 2, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 2, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 6, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 2, 0, 4, 0, 2, 0, 0, 0, 0, 0, 2, 0, 4, 0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 3, 0, 0, 0, 0, 0, 2, 0, 4, 0, 3, 0, 0, 0, 0, 0, 2, 0, 4, 0, 3, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 4, 0, 0, 0, 0, 2, 0, 0, 0, 0, 4, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 4, 0, 0, 6, 0, 0, 0, 0, 0, 0, 4, 0, 0, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 2, 0, 4, 0, 2, 0, 0, 0, 0, 0, 2, 0, 4, 0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 3, 0, 0, 0, 0, 0, 2, 0, 4, 0, 3, 0, 0, 0, 0, 0, 2, 0, 4, 0, 3, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 4, 0, 0, 0, 0, 2, 0, 0, 0, 0, 4, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 4, 0, 0, 6, 0, 0, 0, 0, 0, 0, 4, 0, 0, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0, 4, 0, 0, 0, 0, 0, 0, 6, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef separate_input_into_parts(input: np.ndarray, x: int, y: int) -> List[np.ndarray]:\n    \"\"\"\n    Separates the input numpy array into x * y parts.\n    \n    Args:\n    input: A numpy array representing the input image.\n    x: An integer representing the number of parts in the horizontal direction.\n    y: An integer representing the number of parts in the vertical direction.\n    \n    Returns:\n    A list of numpy arrays representing the separated input.\n    \"\"\"\n    height, width = input.shape\n    part_height, part_width = (height // y, width // x)\n    parts = []\n    for i in range(y):\n        for j in range(x):\n            part = input[i * part_height:(i + 1) * part_height, j * part_width:(j + 1) * part_width]\n            parts.append(part)\n    return parts\n\ndef remove_yellow_rows_and_columns(input: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Removes all yellow rows and columns from the input numpy array.\n    \n    Args:\n    input: A numpy array representing the input image.\n    \n    Returns:\n    A numpy array representing the output image with yellow rows and columns removed.\n    \"\"\"\n    return input[~np.all(input == yellow, axis=1)][:, ~np.all(input == yellow, axis=0)]\n\ndef count_yellow_in_first_row(input: np.ndarray) -> int:\n    \"\"\"\n    Counts the number of yellow positions in the first row of the input numpy array.\n    \n    Args:\n    input: A numpy array representing the input image.\n    \n    Returns:\n    An integer representing the number of yellow positions in the first row.\n    \"\"\"\n    return np.count_nonzero(input[0, :] == yellow)\n\ndef count_yellow_in_first_column(input: np.ndarray) -> int:\n    \"\"\"\n    Counts the number of yellow positions in the first column of the input numpy array.\n    \n    Args:\n    input: A numpy array representing the input image.\n    \n    Returns:\n    An integer representing the number of yellow positions in the first column.\n    \"\"\"\n    return np.count_nonzero(input[:, 0] == yellow)\n\ndef repeat_pattern_and_add_dividing_lines(pattern: np.ndarray, a: int, b: int) -> np.ndarray:\n    \"\"\"\n    Repeats the pattern in a * b, and adds yellow dividing lines.\n    \n    Args:\n    pattern: A numpy array representing the pattern to be repeated.\n    a: An integer representing the number of times the pattern should be repeated in the vertical direction.\n    b: An integer representing the number of times the pattern should be repeated in the horizontal direction.\n    \n    Returns:\n    A numpy array representing the output image with repeated pattern and yellow dividing lines.\n    \"\"\"\n    repeated_pattern = np.tile(pattern, (a, b))\n    i, j = pattern.shape\n    for k in range(1, a):\n        repeated_pattern = np.insert(repeated_pattern, k * i + k - 1, yellow, axis=0)\n    for k in range(1, b):\n        repeated_pattern = np.insert(repeated_pattern, k * j + k - 1, yellow, axis=1)\n    return repeated_pattern\n\ndef find_different_color(inputs: List[np.ndarray]) -> np.ndarray:\n    \"\"\"\n    Finds the numpy array in the list of inputs that has different colors than the others.\n    \n    Args:\n    inputs: A list of numpy arrays representing the separated input.\n    \n    Returns:\n    A numpy array representing the pattern with different colors.\n    \"\"\"\n    for i in range(len(inputs)):\n        if np.unique(inputs[i]).size > 1:\n            return inputs[i]\n    return None\n\ndef separate_input(input):\n    x = count_yellow_in_first_column(input)\n    y = count_yellow_in_first_row(input)\n    input = remove_yellow_rows_and_columns(input)\n    inputs = separate_input_into_parts(input, y + 1, x + 1)\n    return inputs\n\ndef transform_grid(input):\n    inputs = separate_input(input)\n    pattern = find_different_color(inputs)\n    i_s, js = input.shape\n    i, j = pattern.shape\n    a = i_s // i\n    b = js // j\n    output = repeat_pattern_and_add_dividing_lines(pattern, a, b)\n    return output"},
{"name": "dc433765.json", "data": {"train": [{"input": [[3, 0, 0], [0, 0, 0], [0, 0, 4]], "output": [[0, 0, 0], [0, 3, 0], [0, 0, 4]]}, {"input": [[0, 0, 0], [3, 0, 4], [0, 0, 0], [0, 0, 0], [0, 0, 0]], "output": [[0, 0, 0], [0, 3, 4], [0, 0, 0], [0, 0, 0], [0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 3, 0, 0, 4], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 3, 0, 4], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 3], [0, 0, 0], [4, 0, 0]], "output": [[0, 0, 0], [0, 3, 0], [4, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef move_green_to_yellow(output_grid: np.ndarray, pos_green: Tuple[int, int], pos_yellow: Tuple[int, int]) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    This function takes an input grid, the position of the green pixel, and the position of the yellow pixel.                                                           \n    It moves the green pixel one block closer to the yellow pixel, no matter if it is horizontal, diagonal, or vertical.                                                \n    Move green to yellow, not yellow to green!                                                                                                                          \n                                                                                                                                                                        \n    Args:                                                                                                                                                               \n    output_grid: A numpy array representing the input grid.                                                                                                              \n    pos_green: A tuple (row, column) representing the position of the green pixel.                                                                                      \n    pos_yellow: A tuple (row, column) representing the position of the yellow pixel.                                                                                    \n                                                                                                                                                                        \n    Returns:                                                                                                                                                            \n    A numpy array representing the output grid with the green pixel moved one block closer to the yellow pixel.                                                         \n    \"\"\"\n    row_diff = pos_green[0] - pos_yellow[0]\n    col_diff = pos_green[1] - pos_yellow[1]\n    if row_diff == 0:\n        if col_diff > 0:\n            output_grid[pos_green[0], pos_green[1] - 1] = green\n        else:\n            output_grid[pos_green[0], pos_green[1] + 1] = green\n    elif col_diff == 0:\n        if row_diff > 0:\n            output_grid[pos_green[0] - 1, pos_green[1]] = green\n        else:\n            output_grid[pos_green[0] + 1, pos_green[1]] = green\n    elif row_diff > 0:\n        if col_diff > 0:\n            output_grid[pos_green[0] - 1, pos_green[1] - 1] = green\n        else:\n            output_grid[pos_green[0] - 1, pos_green[1] + 1] = green\n    elif col_diff > 0:\n        output_grid[pos_green[0] + 1, pos_green[1] - 1] = green\n    else:\n        output_grid[pos_green[0] + 1, pos_green[1] + 1] = green\n    output_grid[pos_green] = black\n    return output_grid\n\ndef get_yellow_position(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    This function takes an input grid and returns the position of the yellow pixel in the form of a tuple (row, column).\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A tuple (row, column) representing the position of the yellow pixel.\n    \"\"\"\n    return np.where(input_grid == yellow)\n\ndef get_green_position(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    This function takes an input grid and returns the position of the green pixel in the form of a tuple (row, column).\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A tuple (row, column) representing the position of the green pixel.\n    \"\"\"\n    return np.where(input_grid == green)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you can see a green pixel and a yellow pixel.\n    The output is the same size as the input.\n    To make the output, you have to...move the green square one block closer to the yellow square, no matter if it is horizontal, diagonal, or vertical.                                      \n    \"\"\"\n    output_grid = input_grid.copy()\n    pos_green = get_green_position(input_grid)\n    pos_yellow = get_yellow_position(input_grid)\n    output_grid = move_green_to_yellow(output_grid, pos_green, pos_yellow)\n    return output_grid"},
{"name": "5582e5ca.json", "data": {"train": [{"input": [[4, 4, 8], [6, 4, 3], [6, 3, 0]], "output": [[4, 4, 4], [4, 4, 4], [4, 4, 4]]}, {"input": [[6, 8, 9], [1, 8, 1], [9, 4, 9]], "output": [[9, 9, 9], [9, 9, 9], [9, 9, 9]]}, {"input": [[4, 6, 9], [6, 4, 1], [8, 8, 6]], "output": [[6, 6, 6], [6, 6, 6], [6, 6, 6]]}], "test": [{"input": [[8, 8, 6], [4, 6, 9], [8, 3, 0]], "output": [[8, 8, 8], [8, 8, 8], [8, 8, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef fill_grid_with_color(input_grid: np.ndarray, color: int) -> np.ndarray:\n    \"\"\"\n    This function takes an input grid and a color and returns a new grid with all blocks filled with the given color.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    color: An integer representing the color to fill the grid with.\n    \n    Returns:\n    A numpy array representing the output grid with all blocks filled with the given color.\n    \"\"\"\n    output_grid = np.full_like(input_grid, color)\n    return output_grid\n\ndef find_most_common_color(input_grid: np.ndarray) -> int:\n    \"\"\"\n    This function takes an input grid and returns the most common color in the grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    An integer representing the most common color in the grid.\n    \"\"\"\n    colors, counts = np.unique(input_grid, return_counts=True)\n    return colors[np.argmax(counts)]\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    color = find_most_common_color(input_grid)\n    output_grid = fill_grid_with_color(input_grid, color)\n    return output_grid"},
{"name": "1bfc4729.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 0, 0, 0, 0, 0, 0, 0, 0, 6], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [6, 0, 0, 0, 0, 0, 0, 0, 0, 6], [6, 0, 0, 0, 0, 0, 0, 0, 0, 6], [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 0, 0, 0, 0, 0, 0, 0, 0, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [4, 0, 0, 0, 0, 0, 0, 0, 0, 4], [4, 0, 0, 0, 0, 0, 0, 0, 0, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 0, 0, 0, 0, 0, 0, 0, 0, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 0, 0, 0, 0, 0, 0, 0, 0, 8], [8, 0, 0, 0, 0, 0, 0, 0, 0, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 0, 0, 0, 0, 0, 0, 0, 0, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef flip_and_concat(shape1: np.ndarray, shape2: np.ndarray) -> np.ndarray:\n    flipped_shape2 = np.flipud(shape2)\n    return np.concatenate((shape1, flipped_shape2), axis=0)\n\ndef draw_shape(color):\n    out = np.zeros((5, 10), dtype=int)\n    out[0, :] = color\n    out[2, :] = color\n    out[:, 0] = color\n    out[:, -1] = color\n    return out\n\ndef find_non_black_color(row: np.ndarray) -> int:\n    \"\"\"\n    This function takes a numpy array as input and returns the non-black color in the array.\n    \"\"\"\n    for color in row:\n        if color != black:\n            return color\n    return black\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    color1 = find_non_black_color(input_grid[2])\n    color2 = find_non_black_color(input_grid[7])\n    shape1 = draw_shape(color1)\n    shape2 = draw_shape(color2)\n    out = flip_and_concat(shape1, shape2)\n    return out"},
{"name": "a68b268e.json", "data": {"train": [{"input": [[0, 7, 7, 7, 1, 0, 4, 0, 4], [7, 7, 7, 0, 1, 4, 4, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 4], [7, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 6, 6, 6, 0], [0, 0, 8, 8, 1, 0, 0, 0, 0], [8, 0, 8, 0, 1, 6, 0, 0, 6], [0, 0, 0, 8, 1, 0, 0, 0, 0]], "output": [[6, 7, 7, 7], [7, 7, 7, 8], [8, 0, 8, 4], [7, 0, 0, 8]]}, {"input": [[7, 7, 7, 0, 1, 0, 4, 0, 0], [7, 0, 7, 0, 1, 4, 0, 4, 4], [0, 7, 0, 7, 1, 4, 0, 4, 4], [0, 0, 0, 7, 1, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 8, 0, 1, 6, 0, 0, 6], [0, 0, 0, 0, 1, 6, 0, 0, 0], [0, 0, 0, 0, 1, 6, 6, 0, 6], [8, 8, 8, 0, 1, 6, 0, 6, 6]], "output": [[7, 7, 7, 6], [7, 0, 7, 4], [4, 7, 4, 7], [8, 8, 8, 7]]}, {"input": [[0, 0, 7, 7, 1, 0, 4, 4, 0], [0, 0, 0, 7, 1, 0, 0, 4, 4], [7, 7, 7, 7, 1, 0, 0, 0, 4], [0, 7, 0, 0, 1, 0, 4, 4, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 8, 8, 1, 0, 6, 6, 6], [0, 0, 0, 0, 1, 0, 0, 6, 0], [0, 0, 0, 8, 1, 6, 0, 6, 0], [8, 0, 0, 0, 1, 6, 6, 0, 0]], "output": [[0, 4, 7, 7], [0, 0, 4, 7], [7, 7, 7, 7], [8, 7, 4, 0]]}, {"input": [[7, 7, 0, 0, 1, 4, 4, 0, 4], [7, 0, 7, 0, 1, 4, 0, 0, 0], [7, 0, 0, 7, 1, 4, 4, 4, 0], [7, 0, 7, 7, 1, 4, 0, 4, 4], [1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 8, 0, 1, 0, 0, 0, 0], [0, 0, 8, 0, 1, 6, 6, 0, 0], [0, 0, 8, 0, 1, 0, 6, 6, 6], [0, 8, 0, 8, 1, 0, 6, 6, 0]], "output": [[7, 7, 8, 4], [7, 6, 7, 0], [7, 4, 4, 7], [7, 8, 7, 7]]}, {"input": [[7, 7, 0, 0, 1, 0, 0, 0, 4], [7, 0, 0, 0, 1, 4, 4, 4, 4], [7, 0, 7, 0, 1, 4, 0, 0, 0], [0, 7, 7, 0, 1, 4, 4, 4, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1], [8, 0, 8, 0, 1, 6, 6, 6, 6], [0, 0, 8, 8, 1, 0, 0, 6, 0], [0, 0, 0, 0, 1, 0, 6, 0, 6], [8, 8, 8, 8, 1, 0, 0, 0, 6]], "output": [[7, 7, 8, 4], [7, 4, 4, 4], [7, 6, 7, 6], [4, 7, 7, 8]]}, {"input": [[7, 0, 0, 7, 1, 4, 4, 4, 0], [0, 7, 7, 7, 1, 4, 4, 0, 4], [7, 7, 7, 0, 1, 4, 4, 0, 4], [7, 7, 7, 0, 1, 0, 4, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1], [8, 8, 0, 8, 1, 6, 6, 6, 6], [0, 8, 8, 8, 1, 0, 0, 0, 6], [0, 8, 0, 8, 1, 0, 0, 6, 0], [8, 8, 0, 8, 1, 0, 6, 0, 0]], "output": [[7, 4, 4, 7], [4, 7, 7, 7], [7, 7, 7, 4], [7, 7, 7, 8]]}], "test": [{"input": [[7, 7, 7, 0, 1, 0, 0, 4, 0], [0, 7, 7, 0, 1, 4, 4, 0, 4], [7, 7, 7, 7, 1, 0, 4, 0, 4], [7, 0, 0, 0, 1, 4, 0, 4, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 8, 1, 0, 6, 0, 6], [8, 0, 0, 8, 1, 6, 0, 0, 6], [8, 0, 8, 0, 1, 6, 6, 6, 6], [0, 8, 0, 8, 1, 0, 6, 0, 0]], "output": [[7, 7, 7, 8], [4, 7, 7, 4], [7, 7, 7, 7], [7, 8, 4, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_output(output: np.ndarray, color_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Colors the output grid according to the color grid.\n\n    Args:\n    output: A 4x4 numpy array representing the output grid.\n    color_grid: A 4x4 numpy array representing the color grid.\n\n    Returns:\n    A 4x4 numpy array with colored cells.\n    \"\"\"\n    for i in range(4):\n        for j in range(4):\n            if color_grid[i][j] != black:\n                output[i][j] = color_grid[i][j]\n    return output\n\ndef separate_grids(input):\n    grids = []\n    for i in range(2):\n        for j in range(2):\n            grid = input[i * 5:(i + 1) * 5 - 1, j * 5:(j + 1) * 5 - 1]\n            grids.append(grid)\n    return grids\n\ndef transform_grid(input_grid):\n    grids = separate_grids(input_grid)\n    output = np.zeros((4, 4), dtype=np.int32)\n    for i in range(4):\n        output = color_output(output, grids[3 - i])\n    return output"},
{"name": "cbded52d.json", "data": {"train": [{"input": [[1, 4, 0, 1, 1, 0, 1, 4], [1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1], [2, 1, 0, 1, 1, 0, 2, 1], [0, 0, 0, 0, 0, 0, 0, 0], [1, 4, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1]], "output": [[1, 4, 0, 1, 4, 0, 1, 4], [1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [1, 4, 0, 1, 1, 0, 1, 1], [2, 1, 0, 2, 1, 0, 2, 1], [0, 0, 0, 0, 0, 0, 0, 0], [1, 4, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1]]}, {"input": [[1, 1, 0, 7, 1, 0, 1, 1], [1, 3, 0, 1, 1, 0, 1, 3], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 7, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 3]], "output": [[1, 1, 0, 7, 1, 0, 1, 1], [1, 3, 0, 1, 3, 0, 1, 3], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 7, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 3], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 7, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 3]]}, {"input": [[1, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1], [3, 1, 0, 1, 1, 0, 3, 1], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1]], "output": [[1, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1], [3, 1, 0, 3, 1, 0, 3, 1], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1]]}], "test": [{"input": [[1, 1, 0, 1, 1, 0, 1, 1], [1, 8, 0, 1, 1, 0, 1, 8], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [6, 1, 0, 1, 1, 0, 6, 1], [1, 1, 0, 1, 1, 0, 1, 8]], "output": [[1, 1, 0, 1, 1, 0, 1, 1], [1, 8, 0, 1, 8, 0, 1, 8], [0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 8], [0, 0, 0, 0, 0, 0, 0, 0], [6, 1, 0, 6, 1, 0, 6, 1], [1, 1, 0, 1, 1, 0, 1, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_color_at_locations(locations: List[Tuple[int, int]], color: int, grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Changes the color of the cells at the given locations in the grid to the given color.\n    Returns the updated grid.\n    \"\"\"\n    for row, col in locations:\n        grid[row][col] = color\n    return grid\n\ndef get_middle_locations(locations: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Returns a list of tuples representing the middle locations of the given locations.\n    Each tuple contains the row and column indices of the middle cell of a group of cells\n    that are either in the same row or the same column.\n    \"\"\"\n    middle_locations = []\n    for i in range(len(locations)):\n        row, col = locations[i]\n        same_row = [loc for loc in locations if loc[0] == row]\n        same_col = [loc for loc in locations if loc[1] == col]\n        if len(same_row) > 1:\n            same_row.sort(key=lambda loc: loc[1])\n            middle_col = (same_row[0][1] + same_row[-1][1]) // 2\n            middle_locations.append((row, middle_col))\n        elif len(same_col) > 1:\n            same_col.sort(key=lambda loc: loc[0])\n            middle_row = (same_col[0][0] + same_col[-1][0]) // 2\n            middle_locations.append((middle_row, col))\n    return middle_locations\n\ndef get_color_locations(color: int, grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Returns a list of tuples representing the locations of the given color in the grid.\n    Each tuple contains the row and column indices of a cell with the given color.\n    \"\"\"\n    return list(zip(*np.where(grid == color)))\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    out = input_grid\n    for color in range(2, 10):\n        loc1 = get_color_locations(color, out)\n        if loc1:\n            loc2 = get_middle_locations(loc1)\n            out = change_color_at_locations(loc2, color, out)\n    return out"},
{"name": "e8593010.json", "data": {"train": [{"input": [[5, 5, 5, 5, 0, 5, 5, 5, 0, 5], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5], [0, 5, 5, 5, 5, 5, 0, 0, 5, 0], [5, 5, 0, 5, 5, 5, 5, 0, 5, 0], [5, 5, 5, 5, 0, 0, 5, 5, 5, 5], [0, 5, 0, 5, 5, 5, 5, 0, 5, 0], [0, 5, 5, 5, 0, 0, 5, 5, 5, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 5, 0, 5, 0]], "output": [[5, 5, 5, 5, 3, 5, 5, 5, 3, 5], [1, 1, 5, 5, 5, 5, 5, 5, 5, 5], [1, 5, 5, 5, 5, 5, 1, 1, 5, 2], [5, 5, 3, 5, 5, 5, 5, 1, 5, 2], [5, 5, 5, 5, 2, 2, 5, 5, 5, 5], [2, 5, 3, 5, 5, 5, 5, 3, 5, 2], [2, 5, 5, 5, 2, 2, 5, 5, 5, 2], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 2], [3, 5, 5, 5, 5, 5, 5, 3, 5, 2]]}, {"input": [[5, 5, 5, 5, 5, 0, 0, 5, 5, 5], [0, 0, 5, 0, 5, 5, 5, 5, 5, 0], [5, 5, 5, 5, 5, 0, 5, 0, 0, 5], [5, 0, 5, 5, 5, 0, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 0, 5], [5, 5, 5, 5, 0, 5, 5, 5, 5, 5], [0, 0, 5, 5, 0, 5, 0, 0, 5, 0], [5, 5, 5, 5, 5, 5, 5, 0, 5, 5], [0, 5, 5, 5, 5, 5, 0, 5, 5, 0], [0, 0, 5, 5, 5, 5, 5, 5, 0, 5]], "output": [[5, 5, 5, 5, 5, 2, 2, 5, 5, 5], [2, 2, 5, 3, 5, 5, 5, 5, 5, 3], [5, 5, 5, 5, 5, 2, 5, 2, 2, 5], [5, 3, 5, 5, 5, 2, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 3, 5], [5, 5, 5, 5, 2, 5, 5, 5, 5, 5], [2, 2, 5, 5, 2, 5, 1, 1, 5, 3], [5, 5, 5, 5, 5, 5, 5, 1, 5, 5], [1, 5, 5, 5, 5, 5, 3, 5, 5, 3], [1, 1, 5, 5, 5, 5, 5, 5, 3, 5]]}, {"input": [[0, 0, 5, 5, 0, 5, 5, 5, 0, 5], [5, 5, 0, 0, 5, 5, 5, 5, 0, 5], [5, 0, 5, 0, 5, 0, 5, 5, 0, 5], [5, 0, 5, 5, 0, 5, 5, 5, 5, 5], [5, 5, 5, 0, 0, 5, 5, 0, 5, 0], [5, 5, 0, 5, 5, 5, 5, 0, 5, 0], [5, 5, 0, 5, 5, 0, 5, 5, 5, 5], [5, 5, 5, 0, 5, 5, 5, 5, 5, 5], [5, 0, 5, 5, 5, 0, 5, 0, 5, 5], [5, 5, 0, 5, 5, 5, 5, 5, 5, 5]], "output": [[2, 2, 5, 5, 3, 5, 5, 5, 1, 5], [5, 5, 1, 1, 5, 5, 5, 5, 1, 5], [5, 2, 5, 1, 5, 3, 5, 5, 1, 5], [5, 2, 5, 5, 1, 5, 5, 5, 5, 5], [5, 5, 5, 1, 1, 5, 5, 2, 5, 2], [5, 5, 2, 5, 5, 5, 5, 2, 5, 2], [5, 5, 2, 5, 5, 3, 5, 5, 5, 5], [5, 5, 5, 3, 5, 5, 5, 5, 5, 5], [5, 3, 5, 5, 5, 3, 5, 3, 5, 5], [5, 5, 3, 5, 5, 5, 5, 5, 5, 5]]}], "test": [{"input": [[0, 5, 5, 5, 5, 5, 0, 0, 5, 5], [5, 5, 5, 0, 5, 5, 0, 5, 0, 5], [5, 5, 0, 5, 5, 5, 5, 5, 0, 5], [5, 0, 0, 5, 5, 5, 5, 5, 5, 5], [0, 5, 5, 5, 5, 5, 0, 5, 5, 5], [0, 5, 5, 0, 5, 5, 0, 5, 0, 0], [5, 5, 0, 5, 5, 5, 5, 5, 0, 5], [5, 5, 0, 5, 5, 5, 5, 5, 5, 0], [0, 0, 5, 5, 5, 5, 0, 5, 5, 5], [5, 5, 5, 5, 0, 5, 0, 0, 5, 0]], "output": [[3, 5, 5, 5, 5, 5, 1, 1, 5, 5], [5, 5, 5, 3, 5, 5, 1, 5, 2, 5], [5, 5, 1, 5, 5, 5, 5, 5, 2, 5], [5, 1, 1, 5, 5, 5, 5, 5, 5, 5], [2, 5, 5, 5, 5, 5, 2, 5, 5, 5], [2, 5, 5, 3, 5, 5, 2, 5, 1, 1], [5, 5, 2, 5, 5, 5, 5, 5, 1, 5], [5, 5, 2, 5, 5, 5, 5, 5, 5, 3], [2, 2, 5, 5, 5, 5, 1, 5, 5, 5], [5, 5, 5, 5, 3, 5, 1, 1, 5, 3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef fill_single_black_area_blue(input_grid: np.ndarray, i: int, j: int) -> None:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to color the black area of the given point blue.                                                                   \n    \"\"\"\n    if input_grid[i][j] != yellow:\n        return\n    input_grid[i][j] = blue\n    if i > 0:\n        fill_single_black_area_blue(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        fill_single_black_area_blue(input_grid, i + 1, j)\n    if j > 0:\n        fill_single_black_area_blue(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        fill_single_black_area_blue(input_grid, i, j + 1)\n\ndef fill_single_black_area_red(input_grid: np.ndarray, i: int, j: int) -> None:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to color the black area of the given point blue.                                                                   \n    \"\"\"\n    if input_grid[i][j] != yellow:\n        return\n    input_grid[i][j] = red\n    if i > 0:\n        fill_single_black_area_red(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        fill_single_black_area_red(input_grid, i + 1, j)\n    if j > 0:\n        fill_single_black_area_red(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        fill_single_black_area_red(input_grid, i, j + 1)\n\ndef fill_single_black_area(input_grid: np.ndarray, i: int, j: int) -> None:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to color the black area of the given point blue.                                                                   \n    \"\"\"\n    if input_grid[i][j] != yellow:\n        return\n    input_grid[i][j] = green\n    if i > 0:\n        fill_single_black_area(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        fill_single_black_area(input_grid, i + 1, j)\n    if j > 0:\n        fill_single_black_area(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        fill_single_black_area(input_grid, i, j + 1)\n\ndef count_connected_black_points(input_grid: np.ndarray, i: int, j: int) -> int:\n    \"\"\"                                                                                                                                                  \n    This function takes in a numpy array and two integers i and j representing the indices of a point in the array.                                      \n    It performs a floodfill algorithm to count how many black points are connected to the given point.                                                   \n    It returns the count of connected black points.                                                                                                      \n    \"\"\"\n    if input_grid[i][j] != black:\n        return 0\n    count = 1\n    input_grid[i][j] = yellow\n    if i > 0:\n        count += count_connected_black_points(input_grid, i - 1, j)\n    if i < len(input_grid) - 1:\n        count += count_connected_black_points(input_grid, i + 1, j)\n    if j > 0:\n        count += count_connected_black_points(input_grid, i, j - 1)\n    if j < len(input_grid[0]) - 1:\n        count += count_connected_black_points(input_grid, i, j + 1)\n    return count\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    for i in range(len(input_grid)):\n        for j in range(len(input_grid[0])):\n            count = count_connected_black_points(input_grid, i, j)\n            if count == 1:\n                fill_single_black_area(input_grid, i, j)\n            elif count == 2:\n                fill_single_black_area_red(input_grid, i, j)\n            elif count == 3:\n                fill_single_black_area_blue(input_grid, i, j)\n    return input_grid"},
{"name": "f5b8619d.json", "data": {"train": [{"input": [[2, 0, 0], [0, 0, 0], [0, 0, 2]], "output": [[2, 0, 8, 2, 0, 8], [8, 0, 8, 8, 0, 8], [8, 0, 2, 8, 0, 2], [2, 0, 8, 2, 0, 8], [8, 0, 8, 8, 0, 8], [8, 0, 2, 8, 0, 2]]}, {"input": [[0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [5, 0, 0, 0, 0, 5], [0, 0, 0, 0, 0, 0]], "output": [[8, 5, 0, 0, 0, 8, 8, 5, 0, 0, 0, 8], [8, 8, 0, 0, 0, 8, 8, 8, 0, 0, 0, 8], [8, 8, 0, 0, 0, 8, 8, 8, 0, 0, 0, 8], [8, 8, 0, 0, 0, 8, 8, 8, 0, 0, 0, 8], [5, 8, 0, 0, 0, 5, 5, 8, 0, 0, 0, 5], [8, 8, 0, 0, 0, 8, 8, 8, 0, 0, 0, 8], [8, 5, 0, 0, 0, 8, 8, 5, 0, 0, 0, 8], [8, 8, 0, 0, 0, 8, 8, 8, 0, 0, 0, 8], [8, 8, 0, 0, 0, 8, 8, 8, 0, 0, 0, 8], [8, 8, 0, 0, 0, 8, 8, 8, 0, 0, 0, 8], [5, 8, 0, 0, 0, 5, 5, 8, 0, 0, 0, 5], [8, 8, 0, 0, 0, 8, 8, 8, 0, 0, 0, 8]]}, {"input": [[0, 4], [0, 0]], "output": [[0, 4, 0, 4], [0, 8, 0, 8], [0, 4, 0, 4], [0, 8, 0, 8]]}], "test": [{"input": [[0, 0, 3, 0], [0, 0, 0, 0], [0, 0, 0, 3], [3, 0, 0, 0]], "output": [[8, 0, 3, 8, 8, 0, 3, 8], [8, 0, 8, 8, 8, 0, 8, 8], [8, 0, 8, 3, 8, 0, 8, 3], [3, 0, 8, 8, 3, 0, 8, 8], [8, 0, 3, 8, 8, 0, 3, 8], [8, 0, 8, 8, 8, 0, 8, 8], [8, 0, 8, 3, 8, 0, 8, 3], [3, 0, 8, 8, 3, 0, 8, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_black_with_teal_in_index_column(index: List[int], grid: np.ndarray) -> np.ndarray:\n    for i in index:\n        for j in range(grid.shape[0]):\n            if grid[j][i] == black:\n                grid[j][i] = teal\n    return grid\n\ndef find_non_black_columns(grid: np.ndarray) -> List[int]:\n    non_black_columns = []\n    for i in range(grid.shape[1]):\n        if not np.all(grid[:, i] == black):\n            non_black_columns.append(i)\n    return non_black_columns\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.concatenate((input_grid, input_grid), axis=0)\n    output_grid = np.concatenate((output_grid, output_grid), axis=1)\n    index = find_non_black_columns(output_grid)\n    output_grid = replace_black_with_teal_in_index_column(index, output_grid)\n    return output_grid"},
{"name": "d2abd087.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 5, 5, 0, 0, 0, 5, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 0, 2, 2, 2, 0, 0], [0, 1, 1, 0, 0, 0, 2, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 5, 5, 0, 0, 0, 5, 5, 5, 0], [5, 5, 5, 5, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 5, 5, 0, 0, 5, 5, 0, 0, 0], [0, 5, 5, 0, 0, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 2, 2, 0, 0, 0, 1, 1, 1, 0], [2, 2, 2, 2, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 1, 1, 0, 0, 2, 2, 0, 0, 0], [0, 1, 1, 0, 0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[5, 5, 5, 0, 0, 0, 0, 5, 5, 5], [0, 5, 5, 0, 5, 5, 0, 5, 0, 0], [0, 0, 5, 0, 5, 5, 0, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 5], [0, 5, 5, 0, 0, 5, 5, 0, 0, 5], [0, 0, 0, 0, 0, 5, 5, 0, 0, 5], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0]], "output": [[1, 1, 1, 0, 0, 0, 0, 2, 2, 2], [0, 1, 1, 0, 1, 1, 0, 2, 0, 0], [0, 0, 1, 0, 1, 1, 0, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 1], [0, 1, 1, 0, 0, 2, 2, 0, 0, 1], [0, 0, 0, 0, 0, 2, 2, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 5, 5, 0, 0, 0, 5, 5, 0, 0], [0, 5, 5, 0, 0, 0, 5, 5, 0, 0], [5, 5, 5, 5, 0, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 0, 0, 0, 0, 5, 0, 0], [0, 5, 5, 5, 5, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 1, 1, 0, 0, 0, 2, 2, 0, 0], [0, 1, 1, 0, 0, 0, 2, 2, 0, 0], [1, 1, 1, 1, 0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 1, 0, 0], [0, 2, 2, 2, 2, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef dfs(grid: np.ndarray, visited: np.ndarray, i: int, j: int) -> np.ndarray:\n    \"\"\"\n    This function performs depth-first search to find all the grey pixels in a grey shape.\n    \"\"\"\n    if i < 0 or i >= grid.shape[0] or j < 0 or (j >= grid.shape[1]) or (visited[i][j] == 1) or (grid[i][j] != grey):\n        return np.zeros_like(grid)\n    visited[i][j] = 1\n    shape = np.zeros_like(grid)\n    shape[i][j] = 1\n    shape += dfs(grid, visited, i + 1, j)\n    shape += dfs(grid, visited, i - 1, j)\n    shape += dfs(grid, visited, i, j + 1)\n    shape += dfs(grid, visited, i, j - 1)\n    return shape\n\ndef color_grey_shape(grid: np.ndarray, grey_shape: np.ndarray, color: int) -> np.ndarray:\n    \"\"\"\n    This function takes a grid, a grey shape, and a color, and colors the pixels of the grid to give color where its value equals 1 in grey shape.\n    \"\"\"\n    grid[grey_shape == 1] = color\n    return grid\n\ndef count_pixels(gs: np.ndarray) -> int:\n    \"\"\"                                                                                                                                                                 \n    This function takes a grey shape and returns the number of grey pixels in it.                                                                                       \n    \"\"\"\n    return np.sum(gs)\n\ndef find_grey_shapes(grid: np.ndarray) -> List[np.ndarray]:\n    \"\"\"\n    This function takes an input grid and returns a list of the indices of the grey shapes, each grey shape contains some grey pixels.\n    \"\"\"\n    grey_shapes = []\n    visited = np.zeros_like(grid)\n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if grid[i][j] == grey and visited[i][j] == 0:\n                grey_shape = dfs(grid, visited, i, j)\n                grey_shapes.append(grey_shape)\n    return grey_shapes\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you should see a black grid, it has some grey shapes.\n    the output grid is the same size as the input grid.\n    To make the output, you should color the grey shapes to red that has six grey pixels, and color the grey shapes to blue that do not have six grep pixels.\n    \"\"\"\n    output_grid = input_grid.copy()\n    grey_shapes = find_grey_shapes(input_grid)\n    for gs in grey_shapes:\n        if count_pixels(gs) == 6:\n            output_grid = color_grey_shape(output_grid, gs, red)\n        else:\n            output_grid = color_grey_shape(output_grid, gs, blue)\n    return output_grid"},
{"name": "496994bd.json", "data": {"train": [{"input": [[2, 2, 2], [2, 2, 2], [3, 3, 3], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]], "output": [[2, 2, 2], [2, 2, 2], [3, 3, 3], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [3, 3, 3], [2, 2, 2], [2, 2, 2]]}, {"input": [[2, 2, 2, 2, 2], [8, 8, 8, 8, 8], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], "output": [[2, 2, 2, 2, 2], [8, 8, 8, 8, 8], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [8, 8, 8, 8, 8], [2, 2, 2, 2, 2]]}], "test": [{"input": [[3, 3, 3, 3, 3, 3], [5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[3, 3, 3, 3, 3, 3], [5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5], [3, 3, 3, 3, 3, 3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef mirror_non_zero_rows(input_grid: np.ndarray, non_zero_rows: List[int]) -> np.ndarray:\n    output = input_grid\n    output[::-1][non_zero_rows] = input_grid[non_zero_rows]\n    return output\n\ndef find_non_zero_rows(input_grid: np.ndarray) -> List[int]:\n    non_zero_rows = []\n    for i in range(input_grid.shape[0]):\n        if np.any(input_grid[i]):\n            non_zero_rows.append(i)\n    return non_zero_rows\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    non_zero_rows = find_non_zero_rows(input_grid)\n    output = mirror_non_zero_rows(input_grid, non_zero_rows)\n    return output"},
{"name": "c909285e.json", "data": {"train": [{"input": [[0, 0, 2, 4, 8, 5, 0, 4, 2, 8, 0, 5, 0, 0, 2, 4, 0, 5, 0, 4, 2, 0, 0, 5], [0, 0, 2, 4, 8, 5, 0, 4, 2, 8, 0, 5, 0, 0, 2, 4, 0, 5, 0, 4, 2, 0, 0, 5], [2, 2, 2, 4, 2, 5, 2, 4, 2, 2, 2, 5, 2, 2, 2, 4, 2, 5, 2, 4, 2, 2, 2, 5], [4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5], [8, 8, 2, 4, 8, 5, 8, 4, 2, 8, 8, 5, 8, 8, 2, 4, 8, 5, 8, 4, 2, 8, 8, 5], [5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 2, 4, 8, 3, 0, 4, 2, 8, 0, 3, 0, 0, 2, 4, 0, 5, 0, 4, 2, 0, 0, 5], [4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5], [2, 2, 2, 4, 2, 3, 2, 4, 2, 2, 2, 3, 2, 2, 2, 4, 2, 5, 2, 4, 2, 2, 2, 5], [8, 8, 2, 4, 8, 3, 8, 4, 2, 8, 8, 3, 8, 8, 2, 4, 8, 5, 8, 4, 2, 8, 8, 5], [0, 0, 2, 4, 8, 3, 0, 4, 2, 8, 0, 3, 0, 0, 2, 4, 0, 5, 0, 4, 2, 0, 0, 5], [5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 2, 4, 8, 5, 0, 4, 2, 8, 0, 5, 0, 0, 2, 4, 0, 5, 0, 4, 2, 0, 0, 5], [0, 0, 2, 4, 8, 5, 0, 4, 2, 8, 0, 5, 0, 0, 2, 4, 0, 5, 0, 4, 2, 0, 0, 5], [2, 2, 2, 4, 2, 5, 2, 4, 2, 2, 2, 5, 2, 2, 2, 4, 2, 5, 2, 4, 2, 2, 2, 5], [4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5], [0, 0, 2, 4, 8, 5, 0, 4, 2, 8, 0, 5, 0, 0, 2, 4, 0, 5, 0, 4, 2, 0, 0, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 2, 4, 8, 5, 0, 4, 2, 8, 0, 5, 0, 0, 2, 4, 0, 5, 0, 4, 2, 0, 0, 5], [4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5, 4, 4, 4, 4, 4, 5], [2, 2, 2, 4, 2, 5, 2, 4, 2, 2, 2, 5, 2, 2, 2, 4, 2, 5, 2, 4, 2, 2, 2, 5], [0, 0, 2, 4, 8, 5, 0, 4, 2, 8, 0, 5, 0, 0, 2, 4, 0, 5, 0, 4, 2, 0, 0, 5], [0, 0, 2, 4, 8, 5, 0, 4, 2, 8, 0, 5, 0, 0, 2, 4, 0, 5, 0, 4, 2, 0, 0, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]], "output": [[3, 3, 3, 3, 3, 3, 3], [3, 0, 4, 2, 8, 0, 3], [3, 4, 4, 4, 4, 4, 3], [3, 2, 4, 2, 2, 2, 3], [3, 8, 4, 2, 8, 8, 3], [3, 0, 4, 2, 8, 0, 3], [3, 3, 3, 3, 3, 3, 3]]}, {"input": [[0, 0, 8, 3, 1, 8, 0, 3, 8, 1, 0, 8, 0, 0, 8, 3, 0, 8, 0, 3, 8, 0, 0, 8, 1, 0], [0, 0, 8, 3, 1, 8, 0, 3, 8, 1, 0, 8, 0, 0, 8, 3, 0, 8, 0, 3, 8, 0, 0, 8, 1, 0], [8, 8, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [3, 3, 2, 3, 3, 8, 3, 3, 2, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3], [1, 1, 2, 3, 1, 8, 1, 3, 2, 1, 1, 8, 1, 1, 8, 3, 1, 8, 1, 3, 8, 1, 1, 8, 1, 1], [8, 8, 2, 8, 8, 8, 8, 8, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 2, 3, 1, 8, 0, 3, 2, 1, 0, 8, 0, 0, 8, 3, 0, 8, 0, 3, 8, 0, 0, 8, 1, 0], [3, 3, 2, 3, 3, 8, 3, 3, 2, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3], [8, 8, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 8, 3, 1, 8, 1, 3, 8, 1, 1, 8, 1, 1, 8, 3, 1, 8, 1, 3, 8, 1, 1, 8, 1, 1], [0, 0, 8, 3, 1, 8, 0, 3, 8, 1, 0, 8, 0, 0, 8, 3, 0, 8, 0, 3, 8, 0, 0, 8, 1, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 3, 1, 8, 0, 3, 8, 1, 0, 8, 0, 0, 8, 3, 0, 8, 0, 3, 8, 0, 0, 8, 1, 0], [0, 0, 8, 3, 1, 8, 0, 3, 8, 1, 0, 8, 0, 0, 8, 3, 0, 8, 0, 3, 8, 0, 0, 8, 1, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3], [0, 0, 8, 3, 1, 8, 0, 3, 8, 1, 0, 8, 0, 0, 8, 3, 0, 8, 0, 3, 8, 0, 0, 8, 1, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 3, 1, 8, 0, 3, 8, 1, 0, 8, 0, 0, 8, 3, 0, 8, 0, 3, 8, 0, 0, 8, 1, 0], [3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 3, 3], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 3, 1, 8, 0, 3, 8, 1, 0, 8, 0, 0, 8, 3, 0, 8, 0, 3, 8, 0, 0, 8, 1, 0], [0, 0, 8, 3, 1, 8, 0, 3, 8, 1, 0, 8, 0, 0, 8, 3, 0, 8, 0, 3, 8, 0, 0, 8, 1, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 8, 3, 1, 8, 1, 3, 8, 1, 1, 8, 1, 1, 8, 3, 1, 8, 1, 3, 8, 1, 1, 8, 1, 1], [0, 0, 8, 3, 1, 8, 0, 3, 8, 1, 0, 8, 0, 0, 8, 3, 0, 8, 0, 3, 8, 0, 0, 8, 1, 0]], "output": [[2, 2, 2, 2, 2, 2, 2], [2, 3, 3, 8, 3, 3, 2], [2, 3, 1, 8, 1, 3, 2], [2, 8, 8, 8, 8, 8, 2], [2, 3, 1, 8, 0, 3, 2], [2, 3, 3, 8, 3, 3, 2], [2, 2, 2, 2, 2, 2, 2]]}, {"input": [[0, 0, 3, 1, 8, 5, 0, 1, 3, 8, 0, 5, 0, 0, 3, 1, 0, 5, 0, 8, 3, 0, 0, 5, 8, 0, 3, 1], [0, 0, 3, 1, 8, 5, 0, 1, 3, 8, 0, 5, 0, 0, 3, 1, 0, 5, 0, 8, 3, 0, 0, 5, 8, 0, 3, 1], [3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3], [1, 1, 3, 1, 8, 5, 1, 1, 3, 8, 1, 5, 1, 1, 3, 1, 1, 5, 1, 8, 3, 1, 1, 5, 8, 1, 3, 1], [8, 8, 3, 8, 8, 5, 8, 8, 3, 8, 8, 5, 8, 8, 3, 8, 8, 5, 8, 8, 3, 8, 8, 5, 8, 8, 3, 8], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 3, 1, 8, 5, 0, 1, 3, 8, 0, 5, 0, 0, 3, 1, 0, 5, 0, 8, 3, 0, 0, 5, 8, 0, 3, 1], [1, 1, 3, 1, 8, 5, 1, 1, 3, 8, 1, 5, 1, 1, 3, 1, 1, 5, 1, 8, 3, 1, 1, 5, 8, 1, 3, 1], [3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3], [8, 8, 3, 8, 8, 5, 8, 8, 3, 8, 8, 5, 8, 8, 3, 8, 8, 5, 8, 8, 3, 8, 8, 5, 8, 8, 3, 8], [0, 0, 3, 1, 8, 5, 0, 1, 3, 8, 0, 5, 0, 0, 3, 1, 0, 5, 0, 8, 3, 0, 0, 5, 8, 0, 3, 1], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 3, 1, 8, 5, 0, 1, 3, 8, 0, 5, 0, 0, 3, 1, 0, 5, 0, 8, 3, 0, 0, 5, 8, 0, 3, 1], [0, 0, 3, 1, 8, 5, 0, 1, 3, 8, 0, 5, 0, 0, 3, 1, 0, 5, 0, 8, 3, 0, 0, 5, 8, 0, 3, 1], [3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3], [1, 1, 3, 1, 8, 5, 1, 1, 3, 8, 1, 5, 1, 1, 3, 1, 1, 5, 1, 8, 3, 1, 1, 5, 8, 1, 3, 1], [0, 0, 3, 1, 8, 5, 0, 1, 3, 8, 0, 5, 0, 0, 3, 1, 0, 5, 0, 8, 3, 0, 0, 5, 8, 0, 3, 1], [5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 3, 1, 8, 6, 0, 1, 3, 8, 0, 6, 0, 0, 3, 1, 0, 5, 0, 8, 3, 0, 0, 5, 8, 0, 3, 1], [8, 8, 3, 8, 8, 6, 8, 8, 3, 8, 8, 6, 8, 8, 3, 8, 8, 5, 8, 8, 3, 8, 8, 5, 8, 8, 3, 8], [3, 3, 3, 3, 3, 6, 3, 3, 3, 3, 3, 6, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3], [0, 0, 3, 1, 8, 6, 0, 1, 3, 8, 0, 6, 0, 0, 3, 1, 0, 5, 0, 8, 3, 0, 0, 5, 8, 0, 3, 1], [0, 0, 3, 1, 8, 6, 0, 1, 3, 8, 0, 6, 0, 0, 3, 1, 0, 5, 0, 8, 3, 0, 0, 5, 8, 0, 3, 1], [5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [8, 8, 3, 8, 8, 5, 8, 8, 3, 8, 8, 5, 8, 8, 3, 8, 8, 5, 8, 8, 3, 8, 8, 5, 8, 8, 3, 8], [0, 0, 3, 1, 8, 5, 0, 1, 3, 8, 0, 5, 0, 0, 3, 1, 0, 5, 0, 8, 3, 0, 0, 5, 8, 0, 3, 1], [3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 5, 3, 3, 3, 3], [1, 1, 3, 1, 8, 5, 1, 1, 3, 8, 1, 5, 1, 1, 3, 1, 1, 5, 1, 8, 3, 1, 1, 5, 8, 1, 3, 1]], "output": [[6, 6, 6, 6, 6, 6, 6], [6, 0, 1, 3, 8, 0, 6], [6, 8, 8, 3, 8, 8, 6], [6, 3, 3, 3, 3, 3, 6], [6, 0, 1, 3, 8, 0, 6], [6, 0, 1, 3, 8, 0, 6], [6, 6, 6, 6, 6, 6, 6]]}], "test": [{"input": [[0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [1, 1, 1, 2, 3, 4, 1, 2, 1, 3, 1, 4, 1, 1, 3, 2, 1, 4, 1, 3, 1, 1, 1, 4], [2, 2, 2, 2, 3, 4, 2, 2, 2, 3, 2, 4, 2, 2, 3, 2, 2, 4, 2, 3, 2, 2, 2, 4], [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [2, 2, 2, 2, 3, 4, 2, 2, 2, 3, 2, 4, 2, 2, 3, 2, 2, 4, 2, 3, 2, 2, 2, 4], [1, 1, 1, 2, 3, 4, 1, 2, 1, 3, 1, 4, 1, 1, 3, 2, 1, 4, 1, 3, 1, 1, 1, 4], [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 8, 8, 8, 8, 8, 8, 3, 3, 3, 4], [2, 2, 2, 2, 3, 4, 2, 2, 2, 3, 2, 4, 2, 2, 8, 2, 2, 4, 2, 8, 2, 2, 2, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 8, 2, 0, 4, 0, 8, 1, 0, 0, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 4, 4, 4, 4, 8, 4, 4, 4, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 8, 2, 0, 4, 0, 8, 1, 0, 0, 4], [3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 4, 3, 3, 8, 8, 8, 8, 8, 8, 3, 3, 3, 4], [1, 1, 1, 2, 3, 4, 1, 2, 1, 3, 1, 4, 1, 1, 3, 2, 1, 4, 1, 3, 1, 1, 1, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [0, 0, 1, 2, 3, 4, 0, 2, 1, 3, 0, 4, 0, 0, 3, 2, 0, 4, 0, 3, 1, 0, 0, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]], "output": [[8, 8, 8, 8, 8, 8], [8, 2, 2, 4, 2, 8], [8, 2, 0, 4, 0, 8], [8, 4, 4, 4, 4, 8], [8, 2, 0, 4, 0, 8], [8, 8, 8, 8, 8, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_bottom_right_index(input_grid: np.ndarray, color: int) -> Tuple[int, int]:\n    for i in range(input_grid.shape[0] - 1, -1, -1):\n        for j in range(input_grid.shape[1] - 1, -1, -1):\n            if input_grid[i][j] == color:\n                return (i, j)\n    return (-1, -1)\n\ndef find_top_left_index(input_grid: np.ndarray, color: int) -> Tuple[int, int]:\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == color:\n                return (i, j)\n    return (-1, -1)\n\ndef find_color_with_fewest_occurrences(input_grid: np.ndarray) -> int:\n    unique, counts = np.unique(input_grid, return_counts=True)\n    color_counts = dict(zip(unique, counts))\n    return min(color_counts, key=color_counts.get)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    edge_color = find_color_with_fewest_occurrences(input_grid)\n    xmin, ymin = find_top_left_index(input_grid, edge_color)\n    xmax, ymax = find_bottom_right_index(input_grid, edge_color)\n    output_grid = input_grid[xmin:xmax + 1, ymin:ymax + 1]\n    return output_grid"},
{"name": "6d75e8bb.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 0, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 2, 0, 0, 0, 0, 0], [0, 8, 2, 2, 2, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 0, 0, 0, 0, 0], [0, 8, 8, 2, 2, 0, 0, 0, 0, 0], [0, 8, 8, 8, 2, 0, 0, 0, 0, 0], [0, 8, 2, 2, 2, 0, 0, 0, 0, 0], [0, 8, 8, 8, 2, 0, 0, 0, 0, 0], [0, 8, 8, 8, 2, 0, 0, 0, 0, 0], [0, 8, 8, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 0], [0, 8, 0, 8, 8, 0, 8, 0], [0, 8, 0, 8, 0, 0, 8, 0], [0, 0, 0, 8, 0, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 0], [0, 8, 2, 8, 8, 2, 8, 0], [0, 8, 2, 8, 2, 2, 8, 0], [0, 2, 2, 8, 2, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 0, 8, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 0, 0], [0, 2, 2, 8, 2, 8, 0, 0], [0, 2, 8, 8, 8, 8, 0, 0], [0, 2, 2, 8, 8, 8, 0, 0], [0, 2, 2, 2, 8, 8, 0, 0], [0, 2, 2, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 8, 0, 8, 0, 0, 8, 0, 0, 0], [0, 0, 8, 8, 8, 0, 0, 8, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 8, 2, 2, 2, 8, 8, 2, 0, 0], [0, 0, 8, 2, 8, 2, 2, 8, 2, 0, 0], [0, 0, 8, 8, 8, 2, 2, 8, 2, 0, 0], [0, 0, 8, 8, 8, 8, 2, 8, 8, 0, 0], [0, 0, 8, 8, 8, 8, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef turn_black_to_red(upper: int, lower: int, left: int, right: int, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given an input grid, this function turns all black pixels in the given range into red.\n\n    Args:\n    upper: An integer representing the upper boundary of the range.\n    lower: An integer representing the lower boundary of the range.\n    left: An integer representing the left boundary of the range.\n    right: An integer representing the right boundary of the range.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the output grid with all black pixels in the given range turned into red.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    for i in range(upper, lower + 1):\n        for j in range(left, right + 1):\n            if input_grid[i][j] == black:\n                output_grid[i][j] = red\n    return output_grid\n\ndef find_boundaries(input_grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Given an input grid, this function returns the upper, lower, left and right boundaries of the non-black pixels.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A tuple containing the upper, lower, left and right boundaries of the non-black pixels.\n    \"\"\"\n    rows, cols = input_grid.shape\n    upper = rows\n    lower = 0\n    left = cols\n    right = 0\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] != black:\n                upper = min(upper, i)\n                lower = max(lower, i)\n                left = min(left, j)\n                right = max(right, j)\n    return (upper, lower, left, right)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    upper, lower, left, right = find_boundaries(input_grid)\n    output_grid = turn_black_to_red(upper, lower, left, right, input_grid)\n    return output_grid"},
{"name": "41e4d17e.json", "data": {"train": [{"input": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]], "output": [[8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 8, 6, 8, 1, 8, 8, 8, 8, 8, 8, 8], [6, 6, 6, 1, 6, 6, 6, 1, 6, 6, 6, 6, 6, 6, 6], [8, 8, 8, 1, 8, 6, 8, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8]]}, {"input": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]], "output": [[8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 6, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 6, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 6, 8, 8, 8, 8], [8, 8, 8, 1, 1, 1, 1, 1, 8, 8, 6, 8, 8, 8, 8], [8, 8, 8, 1, 8, 6, 8, 1, 8, 8, 6, 8, 8, 8, 8], [6, 6, 6, 1, 6, 6, 6, 1, 6, 6, 6, 6, 6, 6, 6], [8, 8, 8, 1, 8, 6, 8, 1, 8, 8, 6, 8, 8, 8, 8], [8, 8, 8, 1, 1, 1, 1, 1, 8, 8, 6, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 6, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 1, 1, 1, 1, 1, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 1, 8, 6, 8, 1, 8, 8], [6, 6, 6, 6, 6, 6, 6, 6, 1, 6, 6, 6, 1, 6, 6], [8, 8, 8, 8, 8, 6, 8, 8, 1, 8, 6, 8, 1, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 1, 1, 1, 1, 1, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 8, 8, 6, 8, 8, 8, 8]]}], "test": [{"input": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 1, 1, 1, 1, 1, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 1, 1, 1, 1, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]], "output": [[8, 8, 8, 8, 8, 6, 8, 8, 6, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 1, 1, 1, 1, 1, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 1, 8, 6, 8, 1, 8, 8, 8, 8], [6, 6, 6, 6, 6, 6, 1, 6, 6, 6, 1, 6, 6, 6, 6], [8, 8, 8, 8, 8, 6, 1, 8, 6, 8, 1, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 1, 1, 1, 1, 1, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 6, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 6, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 6, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 1, 1, 1, 1, 6, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 8, 6, 8, 1, 6, 8, 8, 8, 8, 8, 8], [6, 6, 6, 1, 6, 6, 6, 1, 6, 6, 6, 6, 6, 6, 6], [8, 8, 8, 1, 8, 6, 8, 1, 6, 8, 8, 8, 8, 8, 8], [8, 8, 8, 1, 1, 1, 1, 1, 6, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 6, 8, 8, 6, 8, 8, 8, 8, 8, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_non_blue_pixels_to_pink(input_grid: np.ndarray, centers: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"\n    Traverse the recorded center coordinates of the squares obtained in Step 1\n    (assuming the current coordinate is (i,j)).\n    Change the color of non-blue pixels in the same row and column as the current pixel to pink.\n    \"\"\"\n    output_grid = input_grid.copy()\n    for center in centers:\n        i, j = (center[0], center[1])\n        for x in range(input_grid.shape[0]):\n            if output_grid[x][j] != blue:\n                output_grid[x][j] = pink\n        for y in range(input_grid.shape[1]):\n            if output_grid[i][y] != blue:\n                output_grid[i][y] = pink\n    return output_grid\n\ndef find_blue_squares_centers(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Traverse the entire image. If the color of the pixel (at coordinate (i, j)) and the color of the pixel below (at coordinate (i+1, j)) and the pixel to the right (at coordinate (i, j+1)) of the current pixel (assumed to have coordinate (i,j)) are both blue, then record the coordinate (i+2, j+2) as the center coordinate of a square.\n    \"\"\"\n    centers = []\n    for i in range(input_grid.shape[0] - 1):\n        for j in range(input_grid.shape[1] - 1):\n            if input_grid[i][j] == blue and input_grid[i + 1][j] == blue and (input_grid[i][j + 1] == blue):\n                centers.append((i + 2, j + 2))\n    return centers\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    centers = find_blue_squares_centers(input_grid)\n    output_grid = change_non_blue_pixels_to_pink(input_grid, centers)\n    return output_grid"},
{"name": "b230c067.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 8, 8], [0, 8, 8, 8, 8, 0, 0, 8, 0, 8], [0, 8, 0, 0, 8, 0, 0, 8, 8, 8], [0, 8, 8, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 8, 0, 0, 8, 0], [0, 0, 0, 0, 0, 8, 8, 8, 8, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2], [0, 1, 1, 1, 1, 0, 0, 2, 0, 2], [0, 1, 0, 0, 1, 0, 0, 2, 2, 2], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 8, 8], [0, 8, 8, 8, 8, 0, 0, 0, 8, 8], [0, 0, 0, 8, 8, 0, 0, 0, 8, 8], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 2, 2, 2], [0, 1, 1, 1, 1, 0, 0, 0, 2, 2], [0, 0, 0, 1, 1, 0, 0, 0, 2, 2], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 8, 8, 8, 0], [0, 0, 8, 0, 0, 0, 0, 0, 8, 0], [0, 8, 0, 0, 0, 0, 0, 8, 0, 0], [0, 8, 8, 8, 0, 0, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 1, 1, 1, 0], [0, 0, 2, 0, 0, 0, 0, 0, 1, 0], [0, 2, 0, 0, 0, 0, 0, 1, 0, 0], [0, 2, 2, 2, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef dfs(input, i, j, visited, domain):\n    if i < 0 or i >= len(input) or j < 0 or (j >= len(input[0])) or ((i, j) in visited) or (input[i][j] != teal):\n        return\n    visited.add((i, j))\n    domain.append((i, j))\n    dfs(input, i + 1, j, visited, domain)\n    dfs(input, i - 1, j, visited, domain)\n    dfs(input, i, j + 1, visited, domain)\n    dfs(input, i, j - 1, visited, domain)\n    dfs(input, i + 1, j + 1, visited, domain)\n    dfs(input, i - 1, j - 1, visited, domain)\n    dfs(input, i + 1, j - 1, visited, domain)\n    dfs(input, i - 1, j + 1, visited, domain)\n\ndef color_positions(input: List[List[int]], positions: List[Tuple[int, int]], color: int) -> List[List[int]]:\n    \"\"\"\n    This function takes a 2D list of integers as input, a list of positions to be colored and a color integer.\n    It returns the input list with the specified positions colored with the specified color.\n    \"\"\"\n    for pos in positions:\n        input[pos[0]][pos[1]] = color\n    return input\n\ndef find_teal_domains(input: List[List[int]]) -> List[List[Tuple[int, int]]]:\n    \"\"\"\n    This function takes a 2D list of integers as input and returns a list of three teal eight-connected domains in the input.\n    \"\"\"\n    domains = []\n    visited = set()\n    for i in range(len(input)):\n        for j in range(len(input[0])):\n            if input[i][j] == teal and (i, j) not in visited:\n                domain = []\n                dfs(input, i, j, visited, domain)\n                domains.append(domain)\n    return domains\n\ndef transform_grid(input):\n    connected_domains = find_teal_domains(input)\n    connected_domains = sorted(connected_domains, key=lambda x: len(x))\n    for domain in connected_domains:\n        input = color_positions(input, domain, blue)\n    input = color_positions(input, connected_domains[0], red)\n    return input"},
{"name": "d10ecb37.json", "data": {"train": [{"input": [[4, 3, 6, 4, 0, 6], [6, 0, 0, 3, 3, 4], [6, 4, 4, 3, 3, 0], [0, 3, 6, 0, 4, 6], [0, 6, 3, 0, 4, 3], [3, 4, 4, 6, 6, 0]], "output": [[4, 3], [6, 0]]}, {"input": [[2, 4, 2, 2, 5, 2, 4, 5], [2, 5, 5, 4, 4, 2, 2, 2], [4, 5, 5, 2, 2, 2, 2, 4], [2, 2, 4, 2, 5, 4, 2, 5], [2, 4, 2, 2, 5, 2, 4, 5], [2, 5, 5, 4, 4, 2, 2, 2], [4, 5, 5, 2, 2, 2, 2, 4], [2, 2, 4, 2, 5, 4, 2, 5]], "output": [[2, 4], [2, 5]]}, {"input": [[3, 2, 1, 3, 4, 1], [1, 4, 4, 2, 2, 3], [1, 3, 3, 2, 2, 4], [4, 2, 1, 4, 3, 1], [4, 1, 2, 4, 3, 2], [2, 3, 3, 1, 1, 4], [2, 4, 4, 1, 1, 3], [3, 1, 2, 3, 4, 2], [3, 2, 1, 3, 4, 1], [1, 4, 4, 2, 2, 3], [1, 3, 3, 2, 2, 4], [4, 2, 1, 4, 3, 1]], "output": [[3, 2], [1, 4]]}], "test": [{"input": [[9, 6, 2, 9, 9, 2, 6, 9], [2, 9, 9, 6, 6, 9, 9, 2], [6, 9, 9, 2, 2, 9, 9, 6], [9, 2, 6, 9, 9, 6, 2, 9]], "output": [[9, 6], [2, 9]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef get_upper_left_2x2(input_grid: List[List[int]]) -> List[List[int]]:\n    return [row[:2] for row in input_grid[:2]]\n\ndef transform_grid(input_grid):\n    return get_upper_left_2x2(input_grid)"},
{"name": "a79310a0.json", "data": {"train": [{"input": [[8, 8, 0, 0, 0], [8, 8, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0], [2, 2, 0, 0, 0], [2, 2, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]}, {"input": [[0, 8, 0], [0, 0, 0], [0, 0, 0]], "output": [[0, 0, 0], [0, 2, 0], [0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0], [0, 8, 8, 8, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 2, 2, 2, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 8, 0, 0], [0, 8, 8, 0, 0], [0, 0, 8, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0], [0, 0, 2, 0, 0], [0, 2, 2, 0, 0], [0, 0, 2, 0, 0], [0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef make_teal_pixels_red(input_grid: np.ndarray) -> np.ndarray:\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == teal:\n                input_grid[i][j] = red\n    return input_grid\n\ndef move_non_black_pixels_to_next_row(input_grid: np.ndarray) -> np.ndarray:\n    for i in range(input_grid.shape[0] - 2, -1, -1):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black and input_grid[i + 1][j] == black:\n                input_grid[i + 1][j] = input_grid[i][j]\n                input_grid[i][j] = black\n    return input_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    input_grid = move_non_black_pixels_to_next_row(input_grid)\n    input_grid = make_teal_pixels_red(input_grid)\n    return input_grid"},
{"name": "67a3c6ac.json", "data": {"train": [{"input": [[6, 6, 6, 2], [6, 1, 6, 2], [7, 2, 7, 2], [1, 7, 2, 2]], "output": [[2, 6, 6, 6], [2, 6, 1, 6], [2, 7, 2, 7], [2, 2, 7, 1]]}, {"input": [[7, 7, 7, 6, 6, 6, 2], [6, 7, 1, 1, 7, 7, 1], [7, 7, 2, 1, 2, 6, 6], [2, 2, 7, 7, 7, 2, 2], [7, 2, 7, 1, 2, 7, 2], [6, 6, 6, 2, 2, 1, 1], [6, 2, 6, 6, 6, 6, 6]], "output": [[2, 6, 6, 6, 7, 7, 7], [1, 7, 7, 1, 1, 7, 6], [6, 6, 2, 1, 2, 7, 7], [2, 2, 7, 7, 7, 2, 2], [2, 7, 2, 1, 7, 2, 7], [1, 1, 2, 2, 6, 6, 6], [6, 6, 6, 6, 6, 2, 6]]}, {"input": [[1, 2, 7, 1, 1, 1], [2, 1, 7, 7, 2, 6], [2, 1, 2, 6, 2, 1], [1, 2, 1, 7, 6, 2], [2, 7, 1, 2, 7, 1], [2, 1, 6, 2, 7, 7]], "output": [[1, 1, 1, 7, 2, 1], [6, 2, 7, 7, 1, 2], [1, 2, 6, 2, 1, 2], [2, 6, 7, 1, 2, 1], [1, 7, 2, 1, 7, 2], [7, 7, 2, 6, 1, 2]]}], "test": [{"input": [[7, 6, 1], [6, 7, 6], [6, 2, 2]], "output": [[1, 6, 7], [6, 7, 6], [2, 2, 6]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef flip_left_right(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.fliplr(input_grid)\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = flip_left_right(input_grid)\n    return output_grid"},
{"name": "0962bcdd.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 2, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 2, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 7, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 2, 7, 2, 0, 0, 0, 0, 0, 0, 0, 0], [7, 7, 2, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 2, 7, 2, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 7, 0, 2, 0, 2, 0, 7, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 2, 7, 2, 0, 0], [0, 0, 0, 0, 0, 0, 7, 7, 2, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 2, 7, 2, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 7, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 6, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 8, 6, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 8, 0, 6, 0, 0, 0, 0, 0, 0], [0, 0, 6, 8, 6, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 6, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 6, 8, 6, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 8, 0, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 6, 0], [0, 0, 0, 0, 0, 0, 0, 6, 8, 6, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 6, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 6, 8, 6, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 8, 0, 6, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 4, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 4, 0, 3, 0, 4, 0], [0, 0, 0, 0, 0, 0, 0, 4, 3, 4, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 4, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 4, 3, 4, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 3, 0, 4, 0], [4, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 4, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 3, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef set_pixel_colors(input_grid: np.ndarray, i: int, j: int, c1: int, c2: int) -> np.ndarray:\n    input_grid[i - 1][j - 1] = c1\n    input_grid[i - 2][j - 2] = c1\n    input_grid[i - 1][j + 1] = c1\n    input_grid[i - 2][j + 2] = c1\n    input_grid[i + 1][j + 1] = c1\n    input_grid[i + 2][j + 2] = c1\n    input_grid[i + 1][j - 1] = c1\n    input_grid[i + 2][j - 2] = c1\n    input_grid[i - 2][j] = c2\n    input_grid[i + 2][j] = c2\n    input_grid[i][j - 2] = c2\n    input_grid[i][j + 2] = c2\n    return input_grid\n\ndef get_pixel_colors(input_grid: np.ndarray, i: int, j: int) -> Tuple[int, int]:\n    c1 = input_grid[i][j]\n    c2 = input_grid[i][j - 1]\n    return (c1, c2)\n\ndef find_center_points(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    centers = []\n    for i in range(1, input_grid.shape[0] - 1):\n        for j in range(1, input_grid.shape[1] - 1):\n            if input_grid[i][j] != black and input_grid[i - 1][j] != black and (input_grid[i + 1][j] != black) and (input_grid[i][j - 1] != black) and (input_grid[i][j + 1] != black):\n                centers.append((i, j))\n    return centers\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    centers = find_center_points(input_grid)\n    for center in centers:\n        i, j = center\n        c1, c2 = get_pixel_colors(input_grid, i, j)\n        input_grid = set_pixel_colors(input_grid, i, j, c1, c2)\n    return input_grid"},
{"name": "e9afcf9a.json", "data": {"train": [{"input": [[3, 3, 3, 3, 3, 3], [9, 9, 9, 9, 9, 9]], "output": [[3, 9, 3, 9, 3, 9], [9, 3, 9, 3, 9, 3]]}, {"input": [[4, 4, 4, 4, 4, 4], [8, 8, 8, 8, 8, 8]], "output": [[4, 8, 4, 8, 4, 8], [8, 4, 8, 4, 8, 4]]}], "test": [{"input": [[6, 6, 6, 6, 6, 6], [2, 2, 2, 2, 2, 2]], "output": [[6, 2, 6, 2, 6, 2], [2, 6, 2, 6, 2, 6]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef swap_top_bottom_pixels_in_odd_columns(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Swap the colors of the top and bottom pixels in every odd column (column number starting from 0).\n    \n    Args:\n    input_grid: 2D numpy array representing the input grid\n    \n    Returns:\n    2D numpy array representing the output grid with colors of top and bottom pixels swapped in odd columns\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n    for c in range(1, cols, 2):\n        for r in range(rows - 1):\n            output_grid[r][c], output_grid[r + 1][c] = (output_grid[r + 1][c], output_grid[r][c])\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = swap_top_bottom_pixels_in_odd_columns(input_grid)\n    return output_grid"},
{"name": "23581191.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 8, 0, 0, 0, 7, 0, 0], [0, 0, 8, 0, 0, 0, 7, 0, 0], [8, 8, 8, 8, 8, 8, 2, 8, 8], [0, 0, 8, 0, 0, 0, 7, 0, 0], [0, 0, 8, 0, 0, 0, 7, 0, 0], [0, 0, 8, 0, 0, 0, 7, 0, 0], [7, 7, 2, 7, 7, 7, 7, 7, 7], [0, 0, 8, 0, 0, 0, 7, 0, 0], [0, 0, 8, 0, 0, 0, 7, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 8, 0, 0, 7, 0, 0], [8, 8, 8, 8, 8, 8, 2, 8, 8], [0, 0, 0, 8, 0, 0, 7, 0, 0], [0, 0, 0, 8, 0, 0, 7, 0, 0], [0, 0, 0, 8, 0, 0, 7, 0, 0], [0, 0, 0, 8, 0, 0, 7, 0, 0], [0, 0, 0, 8, 0, 0, 7, 0, 0], [7, 7, 7, 2, 7, 7, 7, 7, 7], [0, 0, 0, 8, 0, 0, 7, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 7, 0, 0, 8, 0, 0, 0, 0], [8, 2, 8, 8, 8, 8, 8, 8, 8], [0, 7, 0, 0, 8, 0, 0, 0, 0], [0, 7, 0, 0, 8, 0, 0, 0, 0], [0, 7, 0, 0, 8, 0, 0, 0, 0], [0, 7, 0, 0, 8, 0, 0, 0, 0], [7, 7, 7, 7, 2, 7, 7, 7, 7], [0, 7, 0, 0, 8, 0, 0, 0, 0], [0, 7, 0, 0, 8, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef paint_red(input_grid: np.ndarray, x1: int, y1: int, x2: int, y2: int) -> np.ndarray:\n    input_grid[x1, y2] = red\n    input_grid[x2, y1] = red\n    return input_grid\n\ndef paint_orange(input_grid: np.ndarray) -> Tuple[np.ndarray, int, int]:\n    x2, y2 = (-1, -1)\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == orange:\n                if x2 == -1 and y2 == -1:\n                    x2, y2 = (i, j)\n                    input_grid[i, :] = orange\n                    input_grid[:, j] = orange\n    return (input_grid, x2, y2)\n\ndef paint_teal(input_grid: np.ndarray) -> Tuple[np.ndarray, int, int]:\n    x1, y1 = (-1, -1)\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == teal:\n                if x1 == -1 and y1 == -1:\n                    x1, y1 = (i, j)\n                    input_grid[i, :] = teal\n                    input_grid[:, j] = teal\n    return (input_grid, x1, y1)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    input_grid, x1, y1 = paint_teal(input_grid)\n    input_grid, x2, y2 = paint_orange(input_grid)\n    input_grid = paint_red(input_grid, x1, y1, x2, y2)\n    return input_grid"},
{"name": "32597951.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 8, 1, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 8, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 3, 3, 8, 3, 3, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 3, 8, 3, 3, 3, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 8, 1, 8, 8, 8, 8, 8, 8, 1, 0, 0, 1, 0, 1, 1, 0], [0, 8, 1, 8, 1, 1, 1, 8, 8, 0, 1, 1, 0, 0, 0, 0, 0], [0, 1, 1, 8, 1, 1, 8, 1, 8, 0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0], [0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1]], "output": [[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 8, 3, 8, 8, 8, 8, 8, 8, 1, 0, 0, 1, 0, 1, 1, 0], [0, 8, 3, 8, 3, 3, 3, 8, 8, 0, 1, 1, 0, 0, 0, 0, 0], [0, 3, 3, 8, 3, 3, 8, 3, 8, 0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0], [0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1]]}, {"input": [[0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 8, 1, 1, 8, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 8, 8, 1, 8, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 8, 1, 1, 8, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 8, 8, 1, 8, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 8, 1, 1, 8, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]], "output": [[0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 8, 3, 3, 8, 3, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 3, 8, 8, 3, 8, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 8, 3, 3, 8, 3, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 3, 8, 8, 3, 8, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 8, 3, 3, 8, 3, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]]}], "test": [{"input": [[1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 8, 1, 8, 8, 1, 8, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 8, 8, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 8, 8, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 8, 1, 8, 8, 1, 8, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]], "output": [[1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 8, 3, 8, 8, 3, 8, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 8, 8, 3, 8, 8, 3, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 3, 8, 8, 3, 8, 8, 1, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 8, 3, 8, 8, 3, 8, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef make_blue_pixels_green(up: int, down: int, left: int, right: int, input_grid: np.ndarray) -> np.ndarray:\n    output_grid = input_grid.copy()\n    output_grid[up:down + 1, left:right + 1][output_grid[up:down + 1, left:right + 1] == blue] = green\n    return output_grid\n\ndef find_teal_pixels(input_grid: np.ndarray) -> Tuple[int, int, int, int]:\n    teal_pixels = np.where(input_grid == teal)\n    up, left = np.min(teal_pixels, axis=1)\n    down, right = np.max(teal_pixels, axis=1)\n    return (up, down, left, right)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    up, down, left, right = find_teal_pixels(input_grid)\n    output_grid = make_blue_pixels_green(up, down, left, right, input_grid)\n    return output_grid"},
{"name": "56ff96f3.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7], [0, 0, 3, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0], [0, 3, 3, 0, 7, 7, 7, 7], [0, 3, 3, 0, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 8, 8, 0, 0, 0, 0, 0], [8, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 0, 0], [0, 6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef generate_rectangles(grid: np.ndarray, color: int) -> np.ndarray:\n    points = []\n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if grid[i][j] == color:\n                points.append((i, j))\n                if len(points) == 2:\n                    break\n        if len(points) == 2:\n            break\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x_min = min(x1, x2)\n    x_max = max(x1, x2)\n    y_min = min(y1, y2)\n    y_max = max(y1, y2)\n    for i in range(x_min, x_max + 1):\n        for j in range(y_min, y_max + 1):\n            grid[i][j] = color\n    return grid\n\ndef get_non_black_colors(grid: np.ndarray) -> List[int]:\n    colors = set()\n    for row in grid:\n        for cell in row:\n            if cell != black:\n                colors.add(cell)\n    return list(colors)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n    listc = get_non_black_colors(output_grid)\n    for color in listc:\n        output_grid = generate_rectangles(output_grid, color)\n    return output_grid"},
{"name": "3c9b0459.json", "data": {"train": [{"input": [[2, 2, 1], [2, 1, 2], [2, 8, 1]], "output": [[1, 8, 2], [2, 1, 2], [1, 2, 2]]}, {"input": [[9, 2, 4], [2, 4, 4], [2, 9, 2]], "output": [[2, 9, 2], [4, 4, 2], [4, 2, 9]]}, {"input": [[8, 8, 8], [5, 5, 8], [8, 5, 5]], "output": [[5, 5, 8], [8, 5, 5], [8, 8, 8]]}, {"input": [[3, 2, 9], [9, 9, 9], [2, 3, 3]], "output": [[3, 3, 2], [9, 9, 9], [9, 2, 3]]}], "test": [{"input": [[6, 4, 4], [6, 6, 4], [4, 6, 7]], "output": [[7, 6, 4], [4, 6, 6], [4, 4, 6]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef rotate_180(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.rot90(input_grid, 2)\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = rotate_180(input_grid)\n    return output_grid"},
{"name": "5521c0d9.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0], [0, 1, 1, 0, 2, 2, 2, 2, 0, 4, 4, 4, 4, 0, 0], [0, 1, 1, 0, 2, 2, 2, 2, 0, 4, 4, 4, 4, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 4, 4, 4, 4, 0, 0, 1, 1, 0, 0, 2, 2, 0, 0], [0, 4, 4, 4, 4, 0, 0, 1, 1, 0, 0, 2, 2, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 4, 0, 0], [0, 2, 2, 2, 2, 0, 0, 1, 0, 0, 0, 4, 4, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef turn_gray_squares_to_black(grid: np.ndarray) -> np.ndarray:\n    gray_indices = np.where(grid == grey)\n    gray_rows = gray_indices[0]\n    gray_columns = gray_indices[1]\n    for i in range(len(gray_rows)):\n        grid[gray_rows[i]][gray_columns[i]] = black\n    return grid\n\ndef move_blue_matrix_up(grid: np.ndarray, num_rows: int) -> np.ndarray:\n    blue_indices = np.where(grid == blue)\n    blue_rows = blue_indices[0]\n    blue_columns = blue_indices[1]\n    min_row = np.min(blue_rows)\n    max_row = np.max(blue_rows)\n    if min_row - num_rows >= 0:\n        for i in range(len(blue_rows)):\n            grid[blue_rows[i]][blue_columns[i]] = 0\n            grid[blue_rows[i] - num_rows][blue_columns[i]] = blue\n    else:\n        for i in range(len(blue_rows)):\n            grid[blue_rows[i]][blue_columns[i]] = 0\n            grid[blue_rows[i] + max_row - min_row + 1][blue_columns[i]] = blue\n    return grid\n\ndef move_yellow_matrix_up(grid: np.ndarray, num_rows: int) -> np.ndarray:\n    yellow_indices = np.where(grid == yellow)\n    yellow_rows = yellow_indices[0]\n    yellow_columns = yellow_indices[1]\n    min_row = np.min(yellow_rows)\n    max_row = np.max(yellow_rows)\n    if min_row - num_rows >= 0:\n        for i in range(len(yellow_rows)):\n            grid[yellow_rows[i]][yellow_columns[i]] = 0\n            grid[yellow_rows[i] - num_rows][yellow_columns[i]] = yellow\n    else:\n        for i in range(len(yellow_rows)):\n            grid[yellow_rows[i]][yellow_columns[i]] = 0\n            grid[yellow_rows[i] + max_row - min_row + 1][yellow_columns[i]] = yellow\n    return grid\n\ndef move_red_squares_up(grid: np.ndarray, num_rows: int) -> np.ndarray:\n    red_indices = np.where(grid == red)\n    red_rows = red_indices[0]\n    red_columns = red_indices[1]\n    for i in range(len(red_rows)):\n        if red_rows[i] - num_rows >= 0:\n            grid[red_rows[i]][red_columns[i]] = 0\n            grid[red_rows[i] - num_rows][red_columns[i]] = red\n    return grid\n\ndef find_blue_matrix_size(grid: np.ndarray) -> Tuple[int, int]:\n    blue_indices = np.where(grid == blue)\n    rows = np.unique(blue_indices[0]).size\n    columns = np.unique(blue_indices[1]).size\n    return (rows, columns)\n\ndef find_yellow_matrix_size(grid: np.ndarray) -> Tuple[int, int]:\n    yellow_indices = np.where(grid == yellow)\n    rows = np.unique(yellow_indices[0]).size\n    columns = np.unique(yellow_indices[1]).size\n    return (rows, columns)\n\ndef find_red_matrix_size(grid: np.ndarray) -> Tuple[int, int]:\n    red_indices = np.where(grid == red)\n    rows = np.unique(red_indices[0]).size\n    columns = np.unique(red_indices[1]).size\n    return (rows, columns)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n    red_row, red_column = find_red_matrix_size(output_grid)\n    yellow_row, yellow_column = find_yellow_matrix_size(output_grid)\n    blue_row, blue_column = find_blue_matrix_size(output_grid)\n    output_grid = move_red_squares_up(output_grid, red_row)\n    output_grid = move_yellow_matrix_up(output_grid, yellow_row)\n    output_grid = move_blue_matrix_up(output_grid, blue_row)\n    output_grid = turn_gray_squares_to_black(output_grid)\n    return output_grid"},
{"name": "3f7978a0.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 8, 0, 0, 8], [0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 5, 0, 8, 0, 5, 0, 8, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 0, 0, 0, 8], [5, 0, 0, 0, 5], [5, 0, 8, 0, 5], [5, 0, 0, 0, 5], [8, 0, 0, 0, 8]]}, {"input": [[0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8], [0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0], [8, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 5, 0, 0, 8, 8, 0, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 8, 0, 8, 0, 0, 0, 8, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 8, 8, 0]], "output": [[8, 0, 0, 0, 0, 0, 8], [5, 0, 0, 0, 0, 0, 5], [5, 0, 0, 8, 8, 0, 5], [5, 0, 0, 0, 0, 0, 5], [8, 0, 8, 0, 0, 0, 8]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0, 8, 0, 0, 0], [0, 0, 8, 5, 0, 8, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 5, 8, 0, 0, 0, 0], [0, 0, 8, 5, 0, 8, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 8, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0]], "output": [[8, 0, 0, 0, 8], [5, 0, 0, 0, 5], [5, 0, 8, 0, 5], [5, 0, 0, 0, 5], [5, 0, 8, 0, 5], [8, 0, 0, 0, 8]]}], "test": [{"input": [[8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 8, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 8], [5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 0, 0, 5, 0, 0, 8, 0, 0, 8, 0, 0, 0], [5, 0, 8, 5, 8, 0, 0, 0, 0, 0, 0, 0, 8], [5, 0, 0, 5, 0, 8, 0, 0, 0, 0, 0, 0, 0], [5, 8, 0, 5, 0, 0, 0, 0, 0, 0, 8, 0, 8], [5, 0, 0, 5, 0, 0, 0, 8, 0, 0, 0, 0, 0], [8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8]], "output": [[8, 0, 0, 8], [5, 8, 0, 5], [5, 0, 0, 5], [5, 0, 0, 5], [5, 0, 0, 5], [5, 0, 8, 5], [5, 0, 0, 5], [5, 8, 0, 5], [5, 0, 0, 5], [8, 0, 0, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_block(input_grid: np.ndarray, max_row: int, min_row: int, max_col: int, min_col: int) -> np.ndarray:\n    \"\"\"\n    Given an input grid and the maximum row, minimum row, maximum column, and minimum column of a block, \n    returns the block as a numpy ndarray.\n    \n    Args:\n    - input_grid: a numpy ndarray representing the input grid\n    - max_row: an integer representing the maximum row of the block\n    - min_row: an integer representing the minimum row of the block\n    - max_col: an integer representing the maximum column of the block\n    - min_col: an integer representing the minimum column of the block\n    \n    Returns:\n    - a numpy ndarray representing the block\n    \"\"\"\n    return input_grid[min_row:max_row + 1, min_col:max_col + 1]\n\ndef get_positions_bounds(positions: List[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Given a list of positions, returns the maximum row, minimum row, maximum column, and minimum column of the positions.\n    \n    Args:\n    - positions: a list of tuples representing positions\n    \n    Returns:\n    - a tuple of four integers representing the maximum row, minimum row, maximum column, and minimum column of the positions\n    \"\"\"\n    max_row = max(positions, key=lambda x: x[0])[0]\n    min_row = min(positions, key=lambda x: x[0])[0]\n    max_col = max(positions, key=lambda x: x[1])[1]\n    min_col = min(positions, key=lambda x: x[1])[1]\n    return (max_row, min_row, max_col, min_col)\n\ndef find_grey_positions(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given an input grid, returns a list of tuples representing the positions of grey elements in the grid.\n    \n    Args:\n    - input_grid: a numpy ndarray representing the input grid\n    \n    Returns:\n    - a list of tuples representing the positions of grey elements in the grid\n    \"\"\"\n    grey_positions = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == grey:\n                grey_positions.append((i, j))\n    return grey_positions\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    grey_positions = find_grey_positions(input_grid)\n    max_row, min_row, max_col, min_col = get_positions_bounds(grey_positions)\n    output_block = find_block(input_grid, max_row + 1, min_row - 1, max_col, min_col)\n    return output_block"},
{"name": "6f8cd79b.json", "data": {"train": [{"input": [[0, 0, 0], [0, 0, 0], [0, 0, 0]], "output": [[8, 8, 8], [8, 0, 8], [8, 8, 8]]}, {"input": [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]], "output": [[8, 8, 8], [8, 0, 8], [8, 0, 8], [8, 8, 8]]}, {"input": [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], "output": [[8, 8, 8, 8], [8, 0, 0, 8], [8, 0, 0, 8], [8, 0, 0, 8], [8, 8, 8, 8]]}, {"input": [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[8, 8, 8, 8, 8, 8], [8, 0, 0, 0, 0, 8], [8, 0, 0, 0, 0, 8], [8, 0, 0, 0, 0, 8], [8, 8, 8, 8, 8, 8]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[8, 8, 8, 8, 8, 8], [8, 0, 0, 0, 0, 8], [8, 0, 0, 0, 0, 8], [8, 0, 0, 0, 0, 8], [8, 0, 0, 0, 0, 8], [8, 0, 0, 0, 0, 8], [8, 8, 8, 8, 8, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef paint_border_teal(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Paints the pixels of all borders of the input grid as teal and returns the modified grid.\n    \"\"\"\n    input_grid[0, :] = teal\n    input_grid[-1, :] = teal\n    input_grid[:, 0] = teal\n    input_grid[:, -1] = teal\n    return input_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    ans_grid = paint_border_teal(input_grid)\n    return ans_grid"},
{"name": "9172f3a0.json", "data": {"train": [{"input": [[3, 3, 0], [7, 4, 0], [0, 0, 4]], "output": [[3, 3, 3, 3, 3, 3, 0, 0, 0], [3, 3, 3, 3, 3, 3, 0, 0, 0], [3, 3, 3, 3, 3, 3, 0, 0, 0], [7, 7, 7, 4, 4, 4, 0, 0, 0], [7, 7, 7, 4, 4, 4, 0, 0, 0], [7, 7, 7, 4, 4, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4], [0, 0, 0, 0, 0, 0, 4, 4, 4], [0, 0, 0, 0, 0, 0, 4, 4, 4]]}, {"input": [[3, 0, 2], [0, 2, 2], [0, 0, 3]], "output": [[3, 3, 3, 0, 0, 0, 2, 2, 2], [3, 3, 3, 0, 0, 0, 2, 2, 2], [3, 3, 3, 0, 0, 0, 2, 2, 2], [0, 0, 0, 2, 2, 2, 2, 2, 2], [0, 0, 0, 2, 2, 2, 2, 2, 2], [0, 0, 0, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 0, 0, 3, 3, 3], [0, 0, 0, 0, 0, 0, 3, 3, 3]]}], "test": [{"input": [[0, 1, 0], [0, 0, 6], [6, 1, 0]], "output": [[0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 0, 0, 6, 6, 6], [6, 6, 6, 1, 1, 1, 0, 0, 0], [6, 6, 6, 1, 1, 1, 0, 0, 0], [6, 6, 6, 1, 1, 1, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef merge_sub_grids(sub_grids: List[np.ndarray]) -> np.ndarray:\n    \"\"\"\n    Merges 9 3x3 numpy arrays to a 9x9 numpy array.\n\n    Args:\n    sub_grids: A list of 3x3 numpy arrays.\n\n    Returns:\n    A 9x9 numpy array.\n    \"\"\"\n    output_grid = np.zeros((9, 9))\n    for i in range(3):\n        for j in range(3):\n            output_grid[i * 3:i * 3 + 3, j * 3:j * 3 + 3] = sub_grids[i * 3 + j]\n    return output_grid\n\ndef convert_to_sub_grids(lst: List[int]) -> List[np.ndarray]:\n    \"\"\"\n    Converts each element in the list to a 3x3 numpy array, all of its elements equal to the corresponding element.\n\n    Args:\n    lst: A list of integers.\n\n    Returns:\n    A list of 3x3 numpy arrays.\n    \"\"\"\n    sub_grids = []\n    for num in lst:\n        sub_grid = np.full((3, 3), num)\n        sub_grids.append(sub_grid)\n    return sub_grids\n\ndef convert_and_flatten(input_grid: np.ndarray) -> List[int]:\n    \"\"\"\n    Converts the numpy array to a list and flattens it.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A flattened list representing the input grid.\n    \"\"\"\n    return input_grid.flatten().tolist()\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    list = convert_and_flatten(input_grid)\n    sub_grid_list = convert_to_sub_grids(list)\n    output_grid = merge_sub_grids(sub_grid_list)\n    return output_grid"},
{"name": "e76a88a6.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 2, 4, 4, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 2, 4, 4, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 2, 4, 4, 0], [0, 0, 0, 0, 0, 0, 4, 4, 4, 0], [0, 0, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 2, 4, 4, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 5, 5, 5, 5], [0, 6, 6, 6, 6, 0, 5, 5, 5, 5], [0, 8, 8, 6, 8, 0, 5, 5, 5, 5], [0, 6, 8, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 6, 6, 6, 6], [0, 6, 6, 6, 6, 0, 8, 8, 6, 8], [0, 8, 8, 6, 8, 0, 6, 8, 8, 8], [0, 6, 8, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 0, 0], [0, 0, 0, 0, 8, 8, 6, 8, 0, 0], [0, 0, 0, 0, 6, 8, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 1, 4, 4, 0, 0, 5, 5, 5, 0], [0, 1, 4, 1, 0, 0, 5, 5, 5, 0], [0, 1, 1, 1, 0, 0, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 0, 0, 5, 5, 5], [0, 0, 5, 5, 5, 0, 0, 5, 5, 5], [0, 0, 5, 5, 5, 0, 0, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5]], "output": [[0, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 1, 4, 4, 0, 0, 4, 4, 4, 0], [0, 1, 4, 1, 0, 0, 1, 4, 4, 0], [0, 1, 1, 1, 0, 0, 1, 4, 1, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 4, 4, 4, 0, 0, 0, 0, 0], [0, 0, 1, 4, 4, 0, 0, 4, 4, 4], [0, 0, 1, 4, 1, 0, 0, 1, 4, 4], [0, 0, 1, 1, 1, 0, 0, 1, 4, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_grey_area_with_non_grey_area(input_grid):\n    rows, cols = input_grid.shape\n    for i in range(rows - 1, -1, -1):\n        for j in range(cols - 1, -1, -1):\n            if input_grid[i][j] != black and input_grid[i][j] != grey:\n                non_grey_position = (i, j)\n                break\n        else:\n            continue\n        break\n    return non_grey_position\n\ndef find_first_non_black_or_grey_position(input_grid):\n    rows, cols = input_grid.shape\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] != black and input_grid[i][j] != grey:\n                return (i, j)\n    return None\n\ndef has_grey_color(input_grid):\n    rows, cols = input_grid.shape\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] == grey:\n                return True\n    return False\n\ndef find_grey_position(input_grid):\n    rows, cols = input_grid.shape\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] == grey:\n                return (i, j)\n    return None\n\ndef find_positions(input):\n    p1 = find_first_non_black_or_grey_position(input)\n    p2 = replace_grey_area_with_non_grey_area(input)\n    return [p1, p2]\n\ndef transform_grid(input_grid):\n    input = input_grid\n    positions = find_positions(input)\n    while True:\n        grey_position = find_grey_position(input)\n        x = positions[1][0] - positions[0][0] + 1\n        y = positions[1][1] - positions[0][1] + 1\n        input[grey_position[0]:grey_position[0] + x, grey_position[1]:grey_position[1] + y] = input[positions[0][0]:positions[1][0] + 1, positions[0][1]:positions[1][1] + 1]\n        if not has_grey_color(input):\n            break\n    return input"},
{"name": "b1948b0a.json", "data": {"train": [{"input": [[6, 6, 7, 6], [6, 6, 7, 7], [7, 7, 6, 7]], "output": [[2, 2, 7, 2], [2, 2, 7, 7], [7, 7, 2, 7]]}, {"input": [[7, 7, 7, 6], [6, 6, 7, 6], [7, 7, 6, 7], [7, 6, 7, 7], [7, 6, 7, 6], [6, 6, 6, 7]], "output": [[7, 7, 7, 2], [2, 2, 7, 2], [7, 7, 2, 7], [7, 2, 7, 7], [7, 2, 7, 2], [2, 2, 2, 7]]}, {"input": [[7, 7, 6, 6, 6, 6], [6, 7, 6, 7, 7, 7], [7, 6, 7, 7, 6, 7]], "output": [[7, 7, 2, 2, 2, 2], [2, 7, 2, 7, 7, 7], [7, 2, 7, 7, 2, 7]]}], "test": [{"input": [[6, 7, 7, 6], [6, 7, 6, 7], [7, 7, 7, 6], [7, 6, 7, 6]], "output": [[2, 7, 7, 2], [2, 7, 2, 7], [7, 7, 7, 2], [7, 2, 7, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_pink_to_red(output_grid: np.ndarray) -> np.ndarray:\n    output_grid[output_grid == pink] = red\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = input_grid.copy()\n    output_grid = change_pink_to_red(output_grid)\n    return output_grid"},
{"name": "d364b489.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 7, 1, 6, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 7, 1], [0, 0, 0, 2, 0, 0, 0, 0, 0, 8], [0, 0, 7, 1, 6, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 7, 1, 6, 0], [0, 2, 0, 0, 0, 0, 0, 8, 0, 0], [7, 1, 6, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]], "output": [[0, 0, 0, 0, 7, 1, 6, 0, 0, 0], [2, 0, 0, 0, 0, 8, 0, 0, 0, 0], [1, 6, 0, 0, 0, 0, 0, 0, 0, 2], [8, 0, 0, 0, 0, 0, 0, 0, 7, 1], [0, 0, 0, 0, 0, 2, 0, 0, 0, 8], [0, 0, 0, 0, 7, 1, 6, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 7, 1, 6, 0, 0, 0, 0, 0, 2], [0, 0, 8, 0, 0, 0, 0, 0, 7, 1]]}], "test": [{"input": [[0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]], "output": [[7, 1, 6, 0, 0, 0, 0, 0, 7, 1], [0, 8, 0, 0, 0, 0, 0, 2, 0, 8], [0, 0, 0, 2, 0, 0, 7, 1, 6, 0], [0, 0, 7, 1, 6, 0, 0, 8, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 2, 0, 0], [1, 6, 0, 0, 0, 0, 7, 1, 6, 0], [8, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 7, 1, 6, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef paint_colors(grid: np.ndarray, i: int, j: int) -> None:\n    if i > 0:\n        grid[i - 1][j] = red\n    if j > 0:\n        grid[i][j - 1] = orange\n    if j < grid.shape[1] - 1:\n        grid[i][j + 1] = pink\n    if i < grid.shape[0] - 1:\n        grid[i + 1][j] = teal\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == blue:\n                paint_colors(input_grid, i, j)\n    return input_grid"},
{"name": "e98196ab.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]], "output": [[0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 8, 0, 0, 0, 0, 0, 0, 0, 8, 1]]}, {"input": [[0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7], [7, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0], [0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 0, 0, 0, 0, 0, 7, 0, 0, 0, 7]], "output": [[0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 7], [7, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0], [0, 0, 7, 3, 7, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 3, 0, 0, 0, 0, 7, 0, 0, 0, 7]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0]], "output": [[2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2], [0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 1]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7], [0, 0, 7, 7, 0, 0, 0, 0, 7, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0], [0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [6, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6], [6, 0, 0, 0, 6, 0, 0, 0, 0, 0, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0], [6, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0]], "output": [[6, 0, 0, 0, 6, 0, 6, 0, 0, 0, 7], [0, 0, 7, 7, 0, 0, 0, 0, 7, 0, 6], [6, 0, 0, 0, 6, 0, 7, 0, 0, 0, 6], [0, 7, 0, 7, 0, 0, 0, 0, 0, 6, 7], [6, 0, 0, 6, 0, 0, 7, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef copy_non_grey_pixels(sub1: np.ndarray, sub2: np.ndarray, new: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Copies the non-grey pixels from sub2 to new at the same position.\n\n    Args:\n    sub1: A numpy array representing the first sub-grid.\n    sub2: A numpy array representing the second sub-grid.\n    new: A numpy array representing the new grid.\n\n    Returns:\n    A numpy array representing the updated new grid.\n    \"\"\"\n    height, width = sub1.shape\n    for i in range(height):\n        for j in range(width):\n            if sub2[i][j] != black and sub1[i][j] != grey:\n                new[i][j] = sub2[i][j]\n    return new\n\ndef create_new_grid(sub1: np.ndarray, sub2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Creates a new grid in the shape of sub1 using sub1 and sub2.\n\n    Args:\n    sub1: A numpy array representing the first sub-grid.\n    sub2: A numpy array representing the second sub-grid.\n\n    Returns:\n    A numpy array representing the new grid.\n    \"\"\"\n    height, width = sub1.shape\n    new = np.zeros((height, width), dtype=int)\n    for i in range(height):\n        for j in range(width):\n            if sub1[i][j] == grey:\n                new[i][j] = sub2[i][j]\n            else:\n                new[i][j] = sub1[i][j]\n    return new\n\ndef split_along_grey_line(input_grid: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Finds the grey line in the input grid and splits it into two sub-grids.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A tuple of two numpy arrays representing the two sub-grids.\n    \"\"\"\n    height, width = input_grid.shape\n    grey_line = None\n    for i in range(height):\n        if grey_line is not None:\n            break\n        for j in range(width):\n            if input_grid[i][j] == grey:\n                grey_line = i\n                break\n    sub1 = input_grid[:grey_line, :]\n    sub2 = input_grid[grey_line + 1:, :]\n    return (sub1, sub2)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    sub1, sub2 = split_along_grey_line(input_grid)\n    new = create_new_grid(sub1, sub2)\n    out = copy_non_grey_pixels(sub1, sub2, new)\n    return out"},
{"name": "1e32b0e9.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 2, 2, 2, 0, 8, 0, 0, 0, 0, 0, 8, 0, 2, 2, 2, 0], [0, 0, 2, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 2, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 2, 0, 2, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 2, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 2, 2, 2, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [0, 2, 2, 2, 0, 8, 0, 8, 8, 8, 0, 8, 0, 2, 2, 2, 0], [0, 0, 2, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 2, 0, 0, 8, 0, 0, 8, 0, 0], [0, 8, 8, 8, 0, 8, 0, 2, 8, 2, 0, 8, 0, 8, 8, 8, 0], [0, 0, 8, 0, 0, 8, 0, 0, 2, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [0, 2, 2, 2, 0, 8, 0, 8, 8, 8, 0, 8, 0, 8, 8, 8, 0], [0, 0, 2, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 1, 1, 0], [0, 1, 1, 1, 0, 2, 0, 1, 1, 0, 0, 2, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 1, 0, 1, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 1, 1, 0], [0, 1, 1, 1, 0, 2, 0, 1, 1, 2, 0, 2, 0, 2, 2, 2, 0], [0, 1, 1, 1, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 2, 2, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 2, 2, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 2, 2, 0], [0, 2, 2, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 1, 2, 0], [0, 2, 2, 2, 0, 2, 0, 2, 2, 2, 0, 2, 0, 2, 2, 2, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 2, 2, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 2, 2, 0], [0, 2, 2, 2, 0, 2, 0, 1, 2, 1, 0, 2, 0, 2, 2, 2, 0], [0, 2, 2, 2, 0, 2, 0, 2, 1, 2, 0, 2, 0, 2, 2, 2, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 3, 0, 3, 0, 1, 0, 3, 0, 0, 0, 1, 0, 0, 0, 3, 0], [0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 3, 0, 3, 0, 1, 0, 3, 0, 1, 0, 1, 0, 1, 0, 3, 0], [0, 0, 3, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 3, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 3, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 4, 4, 4, 0, 9, 0, 4, 4, 0, 0, 9, 0, 0, 0, 0, 0], [0, 4, 0, 4, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 4, 4, 4, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 4, 0, 4, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 9, 0, 4, 4, 0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 0, 4, 0, 4, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 4, 4, 4, 0, 9, 0, 4, 4, 9, 0, 9, 0, 9, 9, 9, 0], [0, 4, 0, 4, 0, 9, 0, 9, 0, 9, 0, 9, 0, 9, 0, 9, 0], [0, 4, 4, 4, 0, 9, 0, 9, 9, 9, 0, 9, 0, 9, 9, 9, 0], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 9, 4, 9, 0, 9, 0, 9, 9, 9, 0, 9, 0, 9, 9, 9, 0], [0, 4, 0, 4, 0, 9, 0, 9, 0, 9, 0, 9, 0, 9, 0, 9, 0], [0, 9, 4, 9, 0, 9, 0, 4, 4, 9, 0, 9, 0, 9, 9, 9, 0], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 9, 9, 9, 0, 9, 0, 9, 9, 9, 0, 9, 0, 9, 9, 9, 0], [0, 9, 0, 9, 0, 9, 0, 4, 0, 4, 0, 9, 0, 9, 0, 9, 0], [0, 9, 9, 9, 0, 9, 0, 9, 9, 9, 0, 9, 0, 9, 9, 9, 0], [0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_non_black_pixels(input_grid: np.ndarray, locations: List[Tuple[int, int]], color: int, pattern: List[Tuple[int, int]]) -> np.ndarray:\n    for loc in locations[1:]:\n        for i in range(loc[0], loc[0] + 5):\n            for j in range(loc[1], loc[1] + 5):\n                if (i - loc[0], j - loc[1]) in pattern and np.array_equal(input_grid[i][j], 0):\n                    input_grid[i][j] = color\n    return input_grid\n\ndef find_non_black_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    non_black_pixels = []\n    for i in range(5):\n        for j in range(5):\n            if not np.array_equal(input_grid[i][j], 0):\n                non_black_pixels.append((i, j))\n    return non_black_pixels\n\ndef get_grid_locations() -> List[Tuple[int, int]]:\n    locations = []\n    for i in range(3):\n        for j in range(3):\n            x = 0 + j * 6\n            y = 0 + i * 6\n            locations.append((x, y))\n    return locations\n\ndef get_color_at_x5(input_grid: np.ndarray) -> int:\n    return input_grid[5][0]\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    color = get_color_at_x5(input_grid)\n    locs = get_grid_locations()\n    pattern = find_non_black_pixels(input_grid)\n    output_grid = color_non_black_pixels(input_grid, locs, color, pattern)\n    return output_grid"},
{"name": "794b24be.json", "data": {"train": [{"input": [[0, 0, 0], [1, 0, 0], [0, 0, 0]], "output": [[2, 0, 0], [0, 0, 0], [0, 0, 0]]}, {"input": [[0, 1, 0], [1, 0, 0], [0, 0, 0]], "output": [[2, 2, 0], [0, 0, 0], [0, 0, 0]]}, {"input": [[0, 0, 1], [0, 0, 0], [1, 0, 0]], "output": [[2, 2, 0], [0, 0, 0], [0, 0, 0]]}, {"input": [[0, 1, 0], [0, 0, 1], [0, 0, 0]], "output": [[2, 2, 0], [0, 0, 0], [0, 0, 0]]}, {"input": [[0, 0, 1], [0, 0, 0], [0, 0, 0]], "output": [[2, 0, 0], [0, 0, 0], [0, 0, 0]]}, {"input": [[1, 1, 0], [0, 0, 0], [1, 0, 0]], "output": [[2, 2, 2], [0, 0, 0], [0, 0, 0]]}, {"input": [[0, 1, 0], [1, 1, 0], [0, 0, 0]], "output": [[2, 2, 2], [0, 0, 0], [0, 0, 0]]}, {"input": [[1, 1, 0], [0, 0, 0], [1, 0, 1]], "output": [[2, 2, 2], [0, 2, 0], [0, 0, 0]]}, {"input": [[0, 1, 0], [1, 1, 0], [1, 0, 0]], "output": [[2, 2, 2], [0, 2, 0], [0, 0, 0]]}, {"input": [[1, 0, 0], [0, 0, 1], [0, 1, 1]], "output": [[2, 2, 2], [0, 2, 0], [0, 0, 0]]}], "test": [{"input": [[0, 1, 0], [0, 0, 0], [0, 1, 0]], "output": [[2, 2, 0], [0, 0, 0], [0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef count_non_black_pixels(input_grid: np.ndarray) -> int:\n    return np.count_nonzero(input_grid != black)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    num_non_black = count_non_black_pixels(input_grid)\n    output_grid = np.zeros_like(input_grid)\n    if num_non_black <= 3:\n        output_grid[0, :num_non_black] = red\n    else:\n        output_grid[0, :] = red\n        output_grid[1, 1] = red\n    return output_grid"},
{"name": "9f236235.json", "data": {"train": [{"input": [[3, 3, 3, 3, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [3, 3, 3, 3, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [3, 3, 3, 3, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [3, 3, 3, 3, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 2, 3, 3, 3, 3, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 3, 3, 3, 3, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 3, 3, 3, 3, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 3, 3, 3, 3, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 3, 3, 3, 3, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [3, 3, 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 3, 2, 0, 0, 0, 0], [3, 3, 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 3, 2, 0, 0, 0, 0], [3, 3, 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 3, 2, 0, 0, 0, 0], [3, 3, 3, 3, 2, 3, 3, 3, 3, 2, 3, 3, 3, 3, 2, 0, 0, 0, 0]], "output": [[0, 0, 0, 3], [0, 0, 3, 0], [0, 3, 0, 0], [0, 3, 3, 3]]}, {"input": [[0, 0, 0, 0, 8, 2, 2, 2, 2, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 2, 2, 2, 2, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 2, 2, 2, 2, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 2, 2, 2, 2, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [2, 2, 2, 2, 8, 1, 1, 1, 1, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0], [2, 2, 2, 2, 8, 1, 1, 1, 1, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0], [2, 2, 2, 2, 8, 1, 1, 1, 1, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0], [2, 2, 2, 2, 8, 1, 1, 1, 1, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 1, 1, 1, 1, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 1, 1, 1, 1, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 1, 1, 1, 1, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 1, 1, 1, 1, 8, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 3, 3, 3, 3], [0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 3, 3, 3, 3], [0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 3, 3, 3, 3], [0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 8, 3, 3, 3, 3]], "output": [[0, 0, 2, 0], [0, 0, 1, 2], [0, 1, 0, 0], [3, 0, 0, 0]]}, {"input": [[0, 0, 0, 2, 8, 8, 8, 2, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 2, 0, 0, 0], [0, 0, 0, 2, 8, 8, 8, 2, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [8, 8, 8, 2, 8, 8, 8, 2, 0, 0, 0], [8, 8, 8, 2, 8, 8, 8, 2, 0, 0, 0], [8, 8, 8, 2, 8, 8, 8, 2, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 2, 0, 0, 0, 2, 4, 4, 4], [0, 0, 0, 2, 0, 0, 0, 2, 4, 4, 4], [0, 0, 0, 2, 0, 0, 0, 2, 4, 4, 4]], "output": [[0, 8, 0], [0, 8, 8], [4, 0, 0]]}], "test": [{"input": [[1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 3, 8, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 3, 8, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 3, 8, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 3, 8, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 8, 3, 3, 3, 3, 3, 8, 1, 1, 1, 1, 1, 8, 1, 1, 1, 1, 1], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [2, 2, 2, 2, 2, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 2, 2, 2, 2, 2], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 3, 3, 3, 3, 3, 8, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0]], "output": [[1, 1, 3, 1], [0, 0, 3, 0], [2, 0, 3, 2], [0, 0, 3, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef does_not_meet_other_color(row, len, color):\n    return row[len] == color\n\ndef flip_grid_left_right(grid: np.ndarray) -> np.ndarray:\n    return np.fliplr(grid)\n\ndef get_input_coordinate(i, j, len):\n    return (i * (len + 1), j * (len + 1))\n\ndef find_square_side_length(row):\n    len, color = (0, row[0])\n    while does_not_meet_other_color(row, len, color):\n        len += 1\n    return len\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    square_side_length = find_square_side_length(input_grid[0])\n    output_len = input_grid.shape[0] // square_side_length\n    output_grid = np.zeros((output_len, output_len), dtype=int)\n    for i in range(output_len):\n        for j in range(output_len):\n            x, y = get_input_coordinate(i, j, square_side_length)\n            output_grid[i][j] = input_grid[x][y]\n    return flip_grid_left_right(output_grid)"},
{"name": "dc1df850.json", "data": {"train": [{"input": [[2, 0, 0, 0, 0], [0, 0, 0, 2, 0], [0, 0, 0, 0, 0], [0, 6, 0, 0, 0], [0, 0, 0, 0, 0]], "output": [[2, 1, 1, 1, 1], [1, 1, 1, 2, 1], [0, 0, 1, 1, 1], [0, 6, 0, 0, 0], [0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 1, 2], [0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0], [0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 2, 1, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0], [0, 2, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], "output": [[1, 1, 1, 0, 0], [1, 2, 1, 0, 0], [1, 1, 1, 0, 0], [0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5]], "output": [[0, 1, 1, 1, 0, 0, 0, 0, 7, 0], [0, 1, 2, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 1, 2, 1, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 2, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_adjacent_black_grids(input_grid: np.ndarray, red_grids: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"\n    This function takes in a numpy array as input_grid and a list of tuples containing the positions of all the red grids in the input as red_grids.\n    It colors all black grids(diagonally adjacent included) that are adjacent to the red grids with blue.\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    red_grids: A list of tuples containing the positions of all the red grids in the input.\n    \n    Returns:\n    A numpy array with the black grids adjacent to the red grids colored blue.\n    \"\"\"\n    blue_grids = []\n    for r, c in red_grids:\n        for i in range(r - 1, r + 2):\n            for j in range(c - 1, c + 2):\n                if i >= 0 and j >= 0 and (i < input_grid.shape[0]) and (j < input_grid.shape[1]) and (input_grid[i][j] == black):\n                    input_grid[i][j] = blue\n                    blue_grids.append((i, j))\n    return input_grid\n\ndef find_red_grids(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    This function takes in a numpy array as input_grid and returns a list of tuples containing the positions of all the red grids in the input.\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    \n    Returns:\n    A list of tuples containing the positions of all the red grids in the input.\n    \"\"\"\n    red_grids = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                red_grids.append((i, j))\n    return red_grids\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    red_grids = find_red_grids(input_grid)\n    output = color_adjacent_black_grids(input_grid, red_grids)\n    return output"},
{"name": "db3e9e38.json", "data": {"train": [{"input": [[0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], "output": [[8, 7, 8, 7, 8, 7, 8], [0, 7, 8, 7, 8, 7, 0], [0, 0, 8, 7, 8, 0, 0], [0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[7, 8, 7, 8, 7, 8, 7, 0], [7, 8, 7, 8, 7, 8, 0, 0], [7, 8, 7, 8, 7, 0, 0, 0], [0, 8, 7, 8, 0, 0, 0, 0], [0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 7, 8, 7, 8, 7, 8, 7, 8], [8, 7, 8, 7, 8, 7, 8, 7, 8], [0, 7, 8, 7, 8, 7, 8, 7, 8], [0, 0, 8, 7, 8, 7, 8, 7, 8], [0, 0, 0, 7, 8, 7, 8, 7, 0], [0, 0, 0, 0, 8, 7, 8, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef get_num_orange_and_y_index(input_grid: np.ndarray) -> Tuple[int, int]:\n    num_orange = np.count_nonzero(input_grid == orange)\n    y_indices = np.where(input_grid == orange)[1]\n    y_index = np.mean(y_indices).astype(int)\n    return (num_orange, y_index)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    num_orange, y = get_num_orange_and_y_index(input_grid)\n    dist = 1\n    output_grid = input_grid.copy()\n    while dist < num_orange:\n        if dist % 2 == 1:\n            if y - dist >= 0:\n                output_grid[:num_orange - dist, y - dist] = teal\n            if y + dist < input_grid.shape[1]:\n                output_grid[:num_orange - dist, y + dist] = teal\n        else:\n            if y - dist >= 0:\n                output_grid[:num_orange - dist, y - dist] = orange\n            if y + dist < input_grid.shape[1]:\n                output_grid[:num_orange - dist, y + dist] = orange\n        dist += 1\n    return output_grid"},
{"name": "85c4e7cd.json", "data": {"train": [{"input": [[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4], [4, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4], [4, 2, 1, 3, 3, 3, 3, 3, 3, 1, 2, 4], [4, 2, 1, 3, 5, 5, 5, 5, 3, 1, 2, 4], [4, 2, 1, 3, 5, 8, 8, 5, 3, 1, 2, 4], [4, 2, 1, 3, 5, 8, 8, 5, 3, 1, 2, 4], [4, 2, 1, 3, 5, 5, 5, 5, 3, 1, 2, 4], [4, 2, 1, 3, 3, 3, 3, 3, 3, 1, 2, 4], [4, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4], [4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]], "output": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8], [8, 5, 3, 3, 3, 3, 3, 3, 3, 3, 5, 8], [8, 5, 3, 1, 1, 1, 1, 1, 1, 3, 5, 8], [8, 5, 3, 1, 2, 2, 2, 2, 1, 3, 5, 8], [8, 5, 3, 1, 2, 4, 4, 2, 1, 3, 5, 8], [8, 5, 3, 1, 2, 4, 4, 2, 1, 3, 5, 8], [8, 5, 3, 1, 2, 2, 2, 2, 1, 3, 5, 8], [8, 5, 3, 1, 1, 1, 1, 1, 1, 3, 5, 8], [8, 5, 3, 3, 3, 3, 3, 3, 3, 3, 5, 8], [8, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]}, {"input": [[2, 2, 2, 2, 2, 2], [2, 1, 1, 1, 1, 2], [2, 1, 6, 6, 1, 2], [2, 1, 6, 6, 1, 2], [2, 1, 1, 1, 1, 2], [2, 2, 2, 2, 2, 2]], "output": [[6, 6, 6, 6, 6, 6], [6, 1, 1, 1, 1, 6], [6, 1, 2, 2, 1, 6], [6, 1, 2, 2, 1, 6], [6, 1, 1, 1, 1, 6], [6, 6, 6, 6, 6, 6]]}, {"input": [[8, 8, 8, 8, 8, 8, 8, 8], [8, 1, 1, 1, 1, 1, 1, 8], [8, 1, 2, 2, 2, 2, 1, 8], [8, 1, 2, 4, 4, 2, 1, 8], [8, 1, 2, 4, 4, 2, 1, 8], [8, 1, 2, 2, 2, 2, 1, 8], [8, 1, 1, 1, 1, 1, 1, 8], [8, 8, 8, 8, 8, 8, 8, 8]], "output": [[4, 4, 4, 4, 4, 4, 4, 4], [4, 2, 2, 2, 2, 2, 2, 4], [4, 2, 1, 1, 1, 1, 2, 4], [4, 2, 1, 8, 8, 1, 2, 4], [4, 2, 1, 8, 8, 1, 2, 4], [4, 2, 1, 1, 1, 1, 2, 4], [4, 2, 2, 2, 2, 2, 2, 4], [4, 4, 4, 4, 4, 4, 4, 4]]}, {"input": [[7, 7, 7, 7, 7, 7, 7, 7, 7, 7], [7, 2, 2, 2, 2, 2, 2, 2, 2, 7], [7, 2, 4, 4, 4, 4, 4, 4, 2, 7], [7, 2, 4, 1, 1, 1, 1, 4, 2, 7], [7, 2, 4, 1, 3, 3, 1, 4, 2, 7], [7, 2, 4, 1, 3, 3, 1, 4, 2, 7], [7, 2, 4, 1, 1, 1, 1, 4, 2, 7], [7, 2, 4, 4, 4, 4, 4, 4, 2, 7], [7, 2, 2, 2, 2, 2, 2, 2, 2, 7], [7, 7, 7, 7, 7, 7, 7, 7, 7, 7]], "output": [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 1, 1, 1, 1, 1, 1, 1, 1, 3], [3, 1, 4, 4, 4, 4, 4, 4, 1, 3], [3, 1, 4, 2, 2, 2, 2, 4, 1, 3], [3, 1, 4, 2, 7, 7, 2, 4, 1, 3], [3, 1, 4, 2, 7, 7, 2, 4, 1, 3], [3, 1, 4, 2, 2, 2, 2, 4, 1, 3], [3, 1, 4, 4, 4, 4, 4, 4, 1, 3], [3, 1, 1, 1, 1, 1, 1, 1, 1, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3]]}], "test": [{"input": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8], [8, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 8], [8, 2, 4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 2, 8], [8, 2, 4, 3, 7, 7, 7, 7, 7, 7, 3, 4, 2, 8], [8, 2, 4, 3, 7, 6, 6, 6, 6, 7, 3, 4, 2, 8], [8, 2, 4, 3, 7, 6, 5, 5, 6, 7, 3, 4, 2, 8], [8, 2, 4, 3, 7, 6, 5, 5, 6, 7, 3, 4, 2, 8], [8, 2, 4, 3, 7, 6, 6, 6, 6, 7, 3, 4, 2, 8], [8, 2, 4, 3, 7, 7, 7, 7, 7, 7, 3, 4, 2, 8], [8, 2, 4, 3, 3, 3, 3, 3, 3, 3, 3, 4, 2, 8], [8, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 8], [8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]], "output": [[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5], [5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 5], [5, 6, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 6, 5], [5, 6, 7, 3, 4, 4, 4, 4, 4, 4, 3, 7, 6, 5], [5, 6, 7, 3, 4, 2, 2, 2, 2, 4, 3, 7, 6, 5], [5, 6, 7, 3, 4, 2, 8, 8, 2, 4, 3, 7, 6, 5], [5, 6, 7, 3, 4, 2, 8, 8, 2, 4, 3, 7, 6, 5], [5, 6, 7, 3, 4, 2, 2, 2, 2, 4, 3, 7, 6, 5], [5, 6, 7, 3, 4, 4, 4, 4, 4, 4, 3, 7, 6, 5], [5, 6, 7, 3, 3, 3, 3, 3, 3, 3, 3, 7, 6, 5], [5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 5], [5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef swap_colors_according_to_order(input_grid: np.ndarray, color_order: List[int]) -> np.ndarray:\n    \"\"\"\n    This function takes in a numpy array representing a grid of colors and a list of integers representing the order of\n    colors along the middle column of the grid. It returns a numpy array with the colors of the pixels swapped according\n    to the given order.\n    \n    Args:\n    - input_grid: a numpy array of shape (n, m) representing a grid of colors, where n is the number of rows and m is the\n    number of columns\n    - color_order: a list of integers representing the order of colors along the middle column of the grid\n    \n    Returns:\n    - A numpy array with the colors of the pixels swapped according to the given order.\n    \"\"\"\n    color_map = {color_order[i]: color_order[-i - 1] for i in range(len(color_order))}\n    output_grid = np.vectorize(color_map.get)(input_grid)\n    return output_grid\n\ndef record_middle_column_color_order(input_grid: np.ndarray) -> List[int]:\n    \"\"\"\n    This function takes in a numpy array representing a grid of colors and returns a list of integers representing the\n    order of colors along the middle column of the grid. If a color already exists, it is ignored.\n    \n    Args:\n    - input_grid: a numpy array of shape (n, m) representing a grid of colors, where n is the number of rows and m is the\n    number of columns\n    \n    Returns:\n    - A list of integers representing the order of colors along the middle column of the grid.\n    \"\"\"\n    middle_column = input_grid[:, input_grid.shape[1] // 2]\n    color_order = []\n    for color in middle_column:\n        if color not in color_order:\n            color_order.append(color)\n    return color_order\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    r = record_middle_column_color_order(input_grid)\n    out = swap_colors_according_to_order(input_grid, r)\n    return out"},
{"name": "7fe24cdd.json", "data": {"train": [{"input": [[8, 5, 0], [8, 5, 3], [0, 3, 2]], "output": [[8, 5, 0, 0, 8, 8], [8, 5, 3, 3, 5, 5], [0, 3, 2, 2, 3, 0], [0, 3, 2, 2, 3, 0], [5, 5, 3, 3, 5, 8], [8, 8, 0, 0, 5, 8]]}, {"input": [[3, 8, 2], [3, 2, 2], [8, 5, 2]], "output": [[3, 8, 2, 8, 3, 3], [3, 2, 2, 5, 2, 8], [8, 5, 2, 2, 2, 2], [2, 2, 2, 2, 5, 8], [8, 2, 5, 2, 2, 3], [3, 3, 8, 2, 8, 3]]}, {"input": [[0, 3, 0], [6, 6, 6], [0, 3, 0]], "output": [[0, 3, 0, 0, 6, 0], [6, 6, 6, 3, 6, 3], [0, 3, 0, 0, 6, 0], [0, 6, 0, 0, 3, 0], [3, 6, 3, 6, 6, 6], [0, 6, 0, 0, 3, 0]]}], "test": [{"input": [[2, 5, 0], [2, 5, 1], [3, 1, 1]], "output": [[2, 5, 0, 3, 2, 2], [2, 5, 1, 1, 5, 5], [3, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 3], [5, 5, 1, 1, 5, 2], [2, 2, 3, 0, 5, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef rotate_and_copy_bottom_right_to_bottom_left(input_grid: List[List[int]]) -> List[List[int]]:\n    bottom_right = [row[3:] for row in input_grid[3:]]\n    bottom_left = [[0 for i in range(3)] for j in range(3)]\n    for i in range(3):\n        for j in range(3):\n            bottom_left[i][j] = bottom_right[2 - j][i]\n    for i in range(3):\n        for j in range(3):\n            input_grid[i + 3][j] = bottom_left[i][j]\n    return input_grid\n\ndef rotate_and_copy_top_right_to_bottom_right(input_grid: List[List[int]]) -> List[List[int]]:\n    top_right = [row[3:] for row in input_grid[:3]]\n    bottom_right = [[0 for i in range(3)] for j in range(3)]\n    for i in range(3):\n        for j in range(3):\n            bottom_right[i][j] = top_right[2 - j][i]\n    for i in range(3):\n        for j in range(3):\n            input_grid[i + 3][j + 3] = bottom_right[i][j]\n    return input_grid\n\ndef rotate_and_copy_top_left_to_top_right(input_grid: List[List[int]]) -> List[List[int]]:\n    top_left = [row[:3] for row in input_grid[:3]]\n    top_right = [[0 for i in range(3)] for j in range(3)]\n    for i in range(3):\n        for j in range(3):\n            top_right[i][j] = top_left[2 - j][i]\n    for i in range(3):\n        for j in range(3):\n            input_grid[i][j + 3] = top_right[i][j]\n    return input_grid\n\ndef copy_to_top_left(input_grid: np.ndarray, output_grid: List[List[int]]) -> List[List[int]]:\n    for i in range(3):\n        for j in range(3):\n            output_grid[i][j] = input_grid[i][j]\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = [[0 for i in range(6)] for j in range(6)]\n    output_grid = copy_to_top_left(input_grid, output_grid)\n    output_grid = rotate_and_copy_top_left_to_top_right(output_grid)\n    output_grid = rotate_and_copy_top_right_to_bottom_right(output_grid)\n    output_grid = rotate_and_copy_bottom_right_to_bottom_left(output_grid)\n    return output_grid"},
{"name": "c9e6f938.json", "data": {"train": [{"input": [[0, 7, 0], [0, 0, 7], [0, 7, 7]], "output": [[0, 7, 0, 0, 7, 0], [0, 0, 7, 7, 0, 0], [0, 7, 7, 7, 7, 0]]}, {"input": [[0, 0, 0], [0, 7, 7], [0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0], [0, 7, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0], [7, 0, 0], [0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0], [7, 0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[7, 7, 0], [0, 7, 0], [0, 0, 7]], "output": [[7, 7, 0, 0, 7, 7], [0, 7, 0, 0, 7, 0], [0, 0, 7, 7, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef symmetrical_right_edge_axis(grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a 3x3 grid, this function returns a 3x6 grid after being symmetrical along the right edge axis.\n\n    Args:\n    grid: A 3x3 numpy array.\n\n    Returns:\n    A 3x6 numpy array after being symmetrical along the right edge axis.\n    \"\"\"\n    output_grid = np.concatenate((grid, np.fliplr(grid)), axis=1)\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = symmetrical_right_edge_axis(input_grid)\n    return output_grid"},
{"name": "a65b410d.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], "output": [[3, 3, 3, 3, 3, 0, 0], [3, 3, 3, 3, 0, 0, 0], [3, 3, 3, 0, 0, 0, 0], [2, 2, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3, 3, 3, 3, 3, 3, 0, 0, 0], [3, 3, 3, 3, 3, 0, 0, 0, 0], [3, 3, 3, 3, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3, 3, 3, 3, 3, 3, 0, 0, 0], [3, 3, 3, 3, 3, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3, 3, 3, 3, 3, 3, 3, 0, 0], [3, 3, 3, 3, 3, 3, 0, 0, 0], [2, 2, 2, 2, 2, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_rows_below_red(r: int, l: int, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Colors the rows below the red horizontal line in blue, with the length of line in the row next to r and below r\n    being 1 less than l, and the length in each row below being 1 less than the row above it. \n    Stops when the length equals to 0.\n\n    Args:\n    - r: an integer representing the index of the red horizontal line\n    - l: an integer representing the length of the red horizontal line\n    - input_grid: a 2D numpy array representing the input grid\n\n    Returns:\n    - a 2D numpy array representing the updated grid\n    \"\"\"\n    length = l - 1\n    for i in range(r + 1, input_grid.shape[0]):\n        if length == 0:\n            break\n        input_grid[i, :length] = blue\n        length -= 1\n    return input_grid\n\ndef color_rows_above_red(r: int, l: int, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Colors the rows above the red horizontal line in green, with the length of line in the row next to r and above r\n    being 1 more than l, and the length in each row above being 1 more than the row below it.\n\n    Args:\n    - r: an integer representing the index of the red horizontal line\n    - l: an integer representing the length of the red horizontal line\n    - input_grid: a 2D numpy array representing the input grid\n\n    Returns:\n    - a 2D numpy array representing the updated grid\n    \"\"\"\n    for i in range(r - 1, -1, -1):\n        input_grid[i, :l + 1] = green\n        l += 1\n    return input_grid\n\ndef find_red_horizontal_line(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Finds the index and length of a red horizontal line in the input grid.\n\n    Args:\n    - input_grid: a 2D numpy array representing the input grid\n\n    Returns:\n    - a tuple of two integers representing the index and length of the red horizontal line\n    \"\"\"\n    red_line = np.where(input_grid == red)[0]\n    index = red_line[0]\n    length = len(red_line)\n    return (index, length)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    r, l = find_red_horizontal_line(input_grid)\n    above = color_rows_above_red(r, l, input_grid)\n    out = color_rows_below_red(r, l, above)\n    return out"},
{"name": "46f33fce.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 3]], "output": [[2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 2]], "output": [[1, 1, 1, 1, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 4]], "output": [[3, 3, 3, 3, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4], [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4], [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4], [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef enlarge_image(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Enlarges the input grid proportionally to twice its original size (both width and height are doubled).\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the enlarged input grid.\n    \"\"\"\n    return np.kron(input_grid, np.ones((2, 2), dtype=input_grid.dtype))\n\ndef fill_adjacent_pixels_with_color(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Traverse the input grid, and if a non-black colored pixel is encountered, fill the adjacent pixels with the same color.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the modified input grid.\n    \"\"\"\n    for i in range(1, input_grid.shape[0]):\n        for j in range(1, input_grid.shape[1]):\n            if input_grid[i][j] != black:\n                color = input_grid[i][j]\n                input_grid[i - 1][j] = color\n                input_grid[i][j - 1] = color\n                input_grid[i - 1][j - 1] = color\n    return input_grid\n\ndef count_colors(input_grid: np.ndarray) -> int:\n    \"\"\"\n    Counts the total number of different colors (excluding black) in the input grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    An integer representing the total number of different colors (excluding black) in the input grid.\n    \"\"\"\n    unique_colors = set()\n    for row in input_grid:\n        for pixel in row:\n            if pixel != black:\n                unique_colors.add(pixel)\n    return len(unique_colors)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    n = count_colors(input_grid)\n    input_grid = fill_adjacent_pixels_with_color(input_grid)\n    input_grid = enlarge_image(input_grid)\n    return input_grid"},
{"name": "f25ffba3.json", "data": {"train": [{"input": [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 9], [0, 0, 3, 9], [0, 0, 3, 9], [2, 0, 3, 9], [2, 4, 3, 9]], "output": [[2, 4, 3, 9], [2, 0, 3, 9], [0, 0, 3, 9], [0, 0, 3, 9], [0, 0, 0, 9], [0, 0, 0, 9], [0, 0, 3, 9], [0, 0, 3, 9], [2, 0, 3, 9], [2, 4, 3, 9]]}, {"input": [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 2], [0, 0, 0, 2], [0, 8, 0, 2], [0, 3, 8, 2], [3, 3, 8, 2]], "output": [[3, 3, 8, 2], [0, 3, 8, 2], [0, 8, 0, 2], [0, 0, 0, 2], [0, 0, 0, 2], [0, 0, 0, 2], [0, 0, 0, 2], [0, 8, 0, 2], [0, 3, 8, 2], [3, 3, 8, 2]]}], "test": [{"input": [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 1, 0, 0], [7, 1, 0, 0], [7, 1, 3, 0], [7, 1, 3, 3], [7, 1, 4, 4]], "output": [[7, 1, 4, 4], [7, 1, 3, 3], [7, 1, 3, 0], [7, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [7, 1, 0, 0], [7, 1, 3, 0], [7, 1, 3, 3], [7, 1, 4, 4]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef flip_rows(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n    output_grid[:5, :] = input_grid[-5:, :][::-1, :]\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = flip_rows(input_grid)\n    return output_grid"},
{"name": "67a423a3.json", "data": {"train": [{"input": [[0, 3, 0, 0], [2, 2, 2, 2], [0, 3, 0, 0], [0, 3, 0, 0]], "output": [[4, 4, 4, 0], [4, 2, 4, 2], [4, 4, 4, 0], [0, 3, 0, 0]]}, {"input": [[0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0], [8, 8, 8, 8, 6, 8, 8, 8], [0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0]], "output": [[0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 4, 4, 4, 0, 0], [8, 8, 8, 4, 6, 4, 8, 8], [0, 0, 0, 4, 4, 4, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0]]}, {"input": [[0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0], [9, 9, 1, 9, 9, 9], [0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0]], "output": [[0, 0, 1, 0, 0, 0], [0, 4, 4, 4, 0, 0], [9, 4, 1, 4, 9, 9], [0, 4, 4, 4, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0], [3, 3, 3, 3, 3, 3, 3, 4, 5, 4, 3, 3], [0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_non_black_pixel_in_first_row(input_grid: np.ndarray) -> int:\n    for i in range(input_grid.shape[1]):\n        if input_grid[0][i] != black:\n            return i\n    return -1\n\ndef find_non_black_pixel_in_first_column(input_grid: np.ndarray) -> int:\n    for i in range(input_grid.shape[0]):\n        if input_grid[i][0] != black:\n            return i\n    return -1\n\ndef color_adjacent_pixels_yellow(input_grid: np.ndarray, x: int, y: int) -> np.ndarray:\n    for i in range(max(0, x - 1), min(input_grid.shape[0], x + 2)):\n        for j in range(max(0, y - 1), min(input_grid.shape[1], y + 2)):\n            if i != x or j != y:\n                input_grid[i][j] = yellow\n    return input_grid\n\ndef find_intersection(input_grid: np.ndarray) -> Tuple[int, int]:\n    x = find_non_black_pixel_in_first_column(input_grid)\n    y = find_non_black_pixel_in_first_row(input_grid)\n    return (x, y)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    x, y = find_intersection(input_grid)\n    output = color_adjacent_pixels_yellow(input_grid, x, y)\n    return output"},
{"name": "bd4472b8.json", "data": {"train": [{"input": [[2, 1, 4], [5, 5, 5], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]], "output": [[2, 1, 4], [5, 5, 5], [2, 2, 2], [1, 1, 1], [4, 4, 4], [2, 2, 2], [1, 1, 1], [4, 4, 4]]}, {"input": [[3, 2, 1, 4], [5, 5, 5, 5], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], "output": [[3, 2, 1, 4], [5, 5, 5, 5], [3, 3, 3, 3], [2, 2, 2, 2], [1, 1, 1, 1], [4, 4, 4, 4], [3, 3, 3, 3], [2, 2, 2, 2], [1, 1, 1, 1], [4, 4, 4, 4]]}, {"input": [[8, 3], [5, 5], [0, 0], [0, 0], [0, 0], [0, 0]], "output": [[8, 3], [5, 5], [8, 8], [3, 3], [8, 8], [3, 3]]}], "test": [{"input": [[1, 2, 3, 4, 8], [5, 5, 5, 5, 5], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], "output": [[1, 2, 3, 4, 8], [5, 5, 5, 5, 5], [1, 1, 1, 1, 1], [2, 2, 2, 2, 2], [3, 3, 3, 3, 3], [4, 4, 4, 4, 4], [8, 8, 8, 8, 8], [1, 1, 1, 1, 1], [2, 2, 2, 2, 2], [3, 3, 3, 3, 3], [4, 4, 4, 4, 4], [8, 8, 8, 8, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_lines(input, colors):\n    for i in range(len(colors)):\n        input[i + 2] = colors[i]\n    return input\n\ndef concatenate_arrays(arr1: List[int], arr2: List[int]) -> List[int]:\n    return np.concatenate((arr1, arr2))\n\ndef transform_grid(input):\n    colors = input[0]\n    colors = concatenate_arrays(colors, colors)\n    output = color_lines(input, colors)\n    return output"},
{"name": "67385a82.json", "data": {"train": [{"input": [[3, 3, 0], [0, 3, 0], [3, 0, 3]], "output": [[8, 8, 0], [0, 8, 0], [3, 0, 3]]}, {"input": [[0, 3, 0, 0, 0, 3], [0, 3, 3, 3, 0, 0], [0, 0, 0, 0, 3, 0], [0, 3, 0, 0, 0, 0]], "output": [[0, 8, 0, 0, 0, 3], [0, 8, 8, 8, 0, 0], [0, 0, 0, 0, 3, 0], [0, 3, 0, 0, 0, 0]]}, {"input": [[3, 3, 0, 3], [3, 3, 0, 0], [3, 0, 0, 3], [0, 0, 3, 3]], "output": [[8, 8, 0, 3], [8, 8, 0, 0], [8, 0, 0, 8], [0, 0, 8, 8]]}, {"input": [[3, 3, 0, 0, 0, 0], [0, 3, 0, 0, 3, 0], [3, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0], [0, 3, 3, 0, 0, 3]], "output": [[8, 8, 0, 0, 0, 0], [0, 8, 0, 0, 3, 0], [3, 0, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0], [0, 8, 8, 0, 0, 3]]}], "test": [{"input": [[3, 0, 3, 0, 3], [3, 3, 3, 0, 0], [0, 0, 0, 0, 3], [0, 3, 3, 0, 0], [0, 3, 3, 0, 0]], "output": [[8, 0, 8, 0, 3], [8, 8, 8, 0, 0], [0, 0, 0, 0, 3], [0, 8, 8, 0, 0], [0, 8, 8, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_green_pixel_to_teal(grid: np.ndarray, i: int, j: int) -> np.ndarray:\n    \"\"\"\n    Color the green pixel to teal.\n    \n    Args:\n    - grid (np.ndarray): the input grid\n    - i (int): the row index of the pixel\n    - j (int): the column index of the pixel\n    \n    Returns:\n    - np.ndarray: the updated grid with the green pixel colored to teal\n    \"\"\"\n    grid[i][j] = teal\n    return grid\n\ndef is_green_with_adjacent_green_pixel(pixel: int, i: int, j: int, grid: np.ndarray) -> bool:\n    \"\"\"\n    Check if a pixel is green and has another green pixel on top or down or left on right.\n    \n    Args:\n    - pixel (int): the value of the pixel to check\n    - i (int): the row index of the pixel\n    - j (int): the column index of the pixel\n    - grid (np.ndarray): the input grid\n    \n    Returns:\n    - bool: True if the pixel is green and has another green pixel on top or down or left on right, False otherwise\n    \"\"\"\n    if pixel == green:\n        if i > 0 and grid[i - 1][j] == green:\n            return True\n        if i < grid.shape[0] - 1 and grid[i + 1][j] == green:\n            return True\n        if j > 0 and grid[i][j - 1] == green:\n            return True\n        if j < grid.shape[1] - 1 and grid[i][j + 1] == green:\n            return True\n    return False\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you can see some green pixels in the grid,                                                                                                            \n    The output is the same size as the input.                                                                                                                           \n    To make the output, if a green pixel has another green pixel on top or down or left on right, color the pixel to teal.                                              \n    \"\"\"\n    output_grid = input_grid.copy()\n    for i in range(output_grid.shape[0]):\n        for j in range(output_grid.shape[1]):\n            if is_green_with_adjacent_green_pixel(output_grid[i][j], i, j, input_grid):\n                output_grid = color_green_pixel_to_teal(output_grid, i, j)\n    return output_grid"},
{"name": "253bf280.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 3, 3, 3, 3, 3, 3, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 3, 3, 3, 3, 3, 3, 3, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 3, 3, 3, 3, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0], [0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 0, 0], [0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0], [0, 8, 0], [0, 0, 0]], "output": [[0, 0, 0], [0, 8, 0], [0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0]], "output": [[0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0], [0, 0, 0, 3, 0, 0], [0, 8, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0], [0, 0, 0, 8, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 8, 3, 3, 3, 8], [0, 8, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 3, 3, 3, 3, 3, 3, 3, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 3, 3, 3, 3, 3, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_pixels_to_green_between_teal_pixels_in_same_column(input_grid: np.ndarray, teal_pixels: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"\n    Given an input grid and a list of tuples representing the (row, column) indices of all teal pixels in the grid,\n    changes the pixels to green between each pair of teal pixels which are in the same column.\n\n    Args:\n    - input_grid (np.ndarray): A 2D numpy array representing the input grid.\n    - teal_pixels (List[Tuple[int, int]]): A list of tuples representing the (row, column) indices of all teal pixels in the grid.\n\n    Returns:\n    - np.ndarray: A 2D numpy array representing the output grid with pixels changed to green between each pair of teal pixels which are in the same column.\n    \"\"\"\n    for i in range(len(teal_pixels)):\n        for j in range(i + 1, len(teal_pixels)):\n            if teal_pixels[i][1] == teal_pixels[j][1]:\n                start_row = teal_pixels[i][0]\n                end_row = teal_pixels[j][0]\n                if start_row > end_row:\n                    start_row, end_row = (end_row, start_row)\n                for k in range(start_row + 1, end_row):\n                    input_grid[k][teal_pixels[i][1]] = green\n    return input_grid\n\ndef change_pixels_to_green_between_teal_pixels(input_grid: np.ndarray, teal_pixels: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"\n    Given an input grid and a list of tuples representing the (row, column) indices of all teal pixels in the grid,\n    changes the pixels to green between each pair of teal pixels which are in the same row.\n    \n    Args:\n    - input_grid (np.ndarray): A 2D numpy array representing the input grid.\n    - teal_pixels (List[Tuple[int, int]]): A list of tuples representing the (row, column) indices of all teal pixels in the grid.\n    \n    Returns:\n    - np.ndarray: A 2D numpy array representing the output grid with pixels changed to green between each pair of teal pixels which are in the same row.\n    \"\"\"\n    for i in range(len(teal_pixels)):\n        for j in range(i + 1, len(teal_pixels)):\n            if teal_pixels[i][0] == teal_pixels[j][0]:\n                start_col = teal_pixels[i][1]\n                end_col = teal_pixels[j][1]\n                if start_col > end_col:\n                    start_col, end_col = (end_col, start_col)\n                for k in range(start_col + 1, end_col):\n                    input_grid[teal_pixels[i][0]][k] = green\n    return input_grid\n\ndef find_teal_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given an input grid, returns a list of tuples representing the (row, column) indices of all teal pixels in the grid.\n    \n    Args:\n    - input_grid (np.ndarray): A 2D numpy array representing the input grid.\n    \n    Returns:\n    - List[Tuple[int, int]]: A list of tuples representing the (row, column) indices of all teal pixels in the grid.\n    \"\"\"\n    teal_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == teal:\n                teal_pixels.append((i, j))\n    return teal_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    locs = find_teal_pixels(input_grid)\n    out_grid = change_pixels_to_green_between_teal_pixels(input_grid, locs)\n    out_grid = change_pixels_to_green_between_teal_pixels_in_same_column(out_grid, locs)\n    return out_grid"},
{"name": "f8ff0b80.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 3, 3, 3, 0, 0, 0, 8, 8, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3], [2], [8]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 2, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[1], [7], [2]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 2, 0, 0, 0, 1, 0, 0, 0], [0, 2, 2, 2, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[4], [2], [1]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 6, 0, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0]], "output": [[6], [1], [3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef sort_colors_by_frequency(input: np.ndarray, colors: Set[int]) -> List[int]:\n    \"\"\"\n    This function takes an input numpy array and a set of colors and returns a list of colors sorted by their frequency in the input array.\n\n    Args:\n    input: A numpy array of integers representing colors.\n    colors: A set of unique colors present in the input array except black.\n\n    Returns:\n    A list of colors sorted by their frequency in the input array.\n    \"\"\"\n    color_counts = [(color, np.count_nonzero(input == color)) for color in colors]\n    sorted_colors = [color for color, count in sorted(color_counts, key=lambda x: x[1], reverse=True)]\n    return sorted_colors\n\ndef find_colors(input):\n    return set(np.unique(input)) - {black}\n\ndef transform_grid(input):\n    colors = find_colors(input)\n    sorted_colors = sort_colors_by_frequency(input, colors)\n    output = np.array([sorted_colors], dtype=np.int32)\n    return output.T"},
{"name": "9af7a82c.json", "data": {"train": [{"input": [[2, 2, 1], [2, 3, 1], [1, 1, 1]], "output": [[1, 2, 3], [1, 2, 0], [1, 2, 0], [1, 0, 0], [1, 0, 0]]}, {"input": [[3, 1, 1, 4], [2, 2, 2, 4], [4, 4, 4, 4]], "output": [[4, 2, 1, 3], [4, 2, 1, 0], [4, 2, 0, 0], [4, 0, 0, 0], [4, 0, 0, 0], [4, 0, 0, 0]]}, {"input": [[8, 8, 2], [3, 8, 8], [3, 3, 4], [3, 3, 4]], "output": [[3, 8, 4, 2], [3, 8, 4, 0], [3, 8, 0, 0], [3, 8, 0, 0], [3, 0, 0, 0]]}, {"input": [[1, 1, 1], [2, 2, 1], [2, 8, 1], [2, 8, 1]], "output": [[1, 2, 8], [1, 2, 8], [1, 2, 0], [1, 2, 0], [1, 0, 0], [1, 0, 0]]}], "test": [{"input": [[8, 8, 2, 2], [1, 8, 8, 2], [1, 3, 3, 4], [1, 1, 1, 1]], "output": [[1, 8, 2, 3, 4], [1, 8, 2, 3, 0], [1, 8, 2, 0, 0], [1, 8, 0, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef colorize_grid(output_grid: np.ndarray, count_of_colors: List[Tuple[int, int]], number_of_color_types: int) -> np.ndarray:\n    \"\"\"\n    Colors each column of the output grid with the corresponding color type according to the count of colors.\n\n    Args:\n    output_grid: A numpy array representing the empty output grid.\n    count_of_colors: A list of tuples where the first element is the color type and the second element is the number of pixels of that color type in the input grid, sorted from most to least.\n    number_of_color_types: An integer representing the number of unique color types in the input grid.\n\n    Returns:\n    A numpy array representing the output grid with colored columns.\n    \"\"\"\n    for i in range(number_of_color_types):\n        color_type = count_of_colors[i][0]\n        count = count_of_colors[i][1]\n        for j in range(count):\n            output_grid[j][i] = color_type\n    return output_grid\n\ndef make_empty_grid(count_of_colors: List[Tuple[int, int]], number_of_color_types: int) -> np.ndarray:\n    \"\"\"\n    Makes an empty grid with rows equal to the most count of the color and columns equal to the number of unique color types.\n\n    Args:\n    count_of_colors: A list of tuples where the first element is the color type and the second element is the number of pixels of that color type in the input grid, sorted from most to least.\n    number_of_color_types: An integer representing the number of unique color types in the input grid.\n\n    Returns:\n    A numpy array representing the empty output grid.\n    \"\"\"\n    max_count = count_of_colors[0][1]\n    return np.zeros((max_count, number_of_color_types), dtype=int)\n\ndef sort_count(count_of_colors: Dict[int, int]) -> List[Tuple[int, int]]:\n    \"\"\"\n    Sorts the count of colors from most to least.\n\n    Args:\n    count_of_colors: A dictionary where the keys are the color types and the values are the number of pixels of that color type in the input grid.\n\n    Returns:\n    A list of tuples where the first element is the color type and the second element is the number of pixels of that color type in the input grid, sorted from most to least.\n    \"\"\"\n    return sorted(count_of_colors.items(), key=lambda x: x[1], reverse=True)\n\ndef count_color_counts(input_grid: np.ndarray) -> Dict[int, int]:\n    \"\"\"\n    Counts the number of pixels of each color type in the input grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A dictionary where the keys are the color types and the values are the number of pixels of that color type in the input grid.\n    \"\"\"\n    unique_colors, counts = np.unique(input_grid, return_counts=True)\n    return dict(zip(unique_colors, counts))\n\ndef count_color_types(input_grid: np.ndarray) -> int:\n    \"\"\"\n    Counts the number of unique color types in the input grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    An integer representing the number of unique color types in the input grid.\n    \"\"\"\n    return len(np.unique(input_grid))\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you can see a input grid contains pixels of several color, you should count the number of each type of color,                                         \n    sort the counts from the most to the least.                                                                                                                         \n    The output grid has row equals to the most count of the color, col equals to the number of the colors.                                                              \n    To make the output, color each col of same color from left to right according to the number of the counts sequence.                                                 \n    \"\"\"\n    number_of_color_types = count_color_types(input_grid)\n    count_of_colors = count_color_counts(input_grid)\n    count_of_colors = sort_count(count_of_colors)\n    output_grid = make_empty_grid(count_of_colors, number_of_color_types)\n    output_grid = colorize_grid(output_grid, count_of_colors, number_of_color_types)\n    return output_grid"},
{"name": "48d8fb45.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 5, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0]], "output": [[0, 1, 0], [1, 1, 1], [0, 1, 1]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 4, 0], [0, 4, 0, 4, 0, 0, 0, 4, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[4, 4, 0], [0, 0, 4], [0, 4, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 0], [0, 0, 0, 0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 2, 2], [2, 2, 0], [0, 2, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 3, 0], [3, 3, 0], [0, 3, 3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef get_3x3_area_below_gray_pixel(input_grid: np.ndarray, x: int, y: int) -> np.ndarray:\n    return input_grid[x + 1:x + 4, y - 1:y + 2]\n\ndef find_gray_pixel_coordinates(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    This function takes in a numpy array representing an image and returns the coordinates of the first gray pixel found.\n    \n    Args:\n    input_grid: A numpy array representing an image.\n    \n    Returns:\n    A tuple containing the x and y coordinates of the first gray pixel found.\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == grey:\n                return (i, j)\n    return (-1, -1)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    x, y = find_gray_pixel_coordinates(input_grid)\n    output_grid = get_3x3_area_below_gray_pixel(input_grid, x, y)\n    return output_grid"},
{"name": "b60334d2.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 1, 5, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 5, 1, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 1, 5, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 5, 1, 5, 0, 5, 1, 5, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 5, 1, 5, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 5, 1, 5, 0, 0, 5, 1, 5], [0, 1, 0, 1, 0, 0, 1, 0, 1], [0, 5, 1, 5, 0, 0, 5, 1, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 1, 5, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 5, 1, 5, 0, 5, 1, 5, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 5, 1, 5, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[5, 1, 5, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0], [5, 1, 5, 5, 1, 5, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 5, 1, 5, 5, 1, 5], [0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 5, 1, 5, 0, 0, 5, 1, 5], [0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 5, 1, 5, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_positions_to_black(input: List[List[int]], positions: List[Tuple[int, int]]) -> List[List[int]]:\n    for i, j in positions:\n        input[i][j] = black\n    return input\n\ndef change_corners_to_grey(input: List[List[int]], positions: List[Tuple[int, int]]) -> List[List[int]]:\n    for i, j in positions:\n        if i > 0 and j > 0:\n            input[i - 1][j - 1] = grey\n        if i > 0 and j < len(input[i]) - 1:\n            input[i - 1][j + 1] = grey\n        if i < len(input) - 1 and j > 0:\n            input[i + 1][j - 1] = grey\n        if i < len(input) - 1 and j < len(input[i]) - 1:\n            input[i + 1][j + 1] = grey\n    return input\n\ndef change_positions_to_blue(input: List[List[int]], positions: List[Tuple[int, int]]) -> List[List[int]]:\n    for i, j in positions:\n        if i > 0:\n            input[i - 1][j] = blue\n        if i < len(input) - 1:\n            input[i + 1][j] = blue\n        if j > 0:\n            input[i][j - 1] = blue\n        if j < len(input[i]) - 1:\n            input[i][j + 1] = blue\n    return input\n\ndef find_grey_positions(input: List[List[int]]) -> List[Tuple[int, int]]:\n    positions = []\n    for i in range(len(input)):\n        for j in range(len(input[i])):\n            if input[i][j] == grey:\n                positions.append((i, j))\n    return positions\n\ndef transform_grid(input):\n    positions = find_grey_positions(input)\n    output = change_positions_to_blue(input, positions)\n    output = change_corners_to_grey(output, positions)\n    output = change_positions_to_black(output, positions)\n    return output"},
{"name": "67e8384a.json", "data": {"train": [{"input": [[5, 3, 4], [3, 4, 5], [3, 4, 4]], "output": [[5, 3, 4, 4, 3, 5], [3, 4, 5, 5, 4, 3], [3, 4, 4, 4, 4, 3], [3, 4, 4, 4, 4, 3], [3, 4, 5, 5, 4, 3], [5, 3, 4, 4, 3, 5]]}, {"input": [[7, 1, 5], [7, 7, 1], [5, 3, 1]], "output": [[7, 1, 5, 5, 1, 7], [7, 7, 1, 1, 7, 7], [5, 3, 1, 1, 3, 5], [5, 3, 1, 1, 3, 5], [7, 7, 1, 1, 7, 7], [7, 1, 5, 5, 1, 7]]}, {"input": [[2, 5, 2], [2, 6, 4], [2, 2, 2]], "output": [[2, 5, 2, 2, 5, 2], [2, 6, 4, 4, 6, 2], [2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2], [2, 6, 4, 4, 6, 2], [2, 5, 2, 2, 5, 2]]}, {"input": [[1, 2, 1], [2, 8, 1], [8, 1, 6]], "output": [[1, 2, 1, 1, 2, 1], [2, 8, 1, 1, 8, 2], [8, 1, 6, 6, 1, 8], [8, 1, 6, 6, 1, 8], [2, 8, 1, 1, 8, 2], [1, 2, 1, 1, 2, 1]]}], "test": [{"input": [[1, 6, 6], [5, 2, 2], [2, 2, 2]], "output": [[1, 6, 6, 6, 6, 1], [5, 2, 2, 2, 2, 5], [2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2], [5, 2, 2, 2, 2, 5], [1, 6, 6, 6, 6, 1]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef up_down_symmetry(input_grid: np.ndarray) -> np.ndarray:\n    return np.flipud(input_grid)\n\ndef left_right_symmetry(input_grid: np.ndarray) -> np.ndarray:\n    return np.fliplr(input_grid)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.zeros([input_grid.shape[0] * 2, input_grid.shape[1] * 2])\n    output_grid[:input_grid.shape[0], :input_grid.shape[1]] = input_grid\n    output_grid[:input_grid.shape[0], input_grid.shape[1]:] = left_right_symmetry(input_grid)\n    output_grid[input_grid.shape[0]:, :] = up_down_symmetry(output_grid[:input_grid.shape[0], :])\n    return output_grid"},
{"name": "f2829549.json", "data": {"train": [{"input": [[7, 7, 0, 1, 5, 0, 0], [7, 0, 0, 1, 5, 0, 0], [0, 0, 0, 1, 5, 0, 5], [0, 0, 0, 1, 5, 5, 0]], "output": [[0, 0, 3], [0, 3, 3], [0, 3, 0], [0, 0, 3]]}, {"input": [[7, 7, 0, 1, 5, 0, 0], [0, 0, 0, 1, 0, 0, 0], [7, 7, 0, 1, 5, 0, 0], [0, 7, 7, 1, 5, 5, 0]], "output": [[0, 0, 3], [3, 3, 3], [0, 0, 3], [0, 0, 0]]}, {"input": [[0, 7, 7, 1, 5, 0, 0], [0, 0, 7, 1, 0, 5, 5], [0, 7, 0, 1, 5, 5, 0], [0, 0, 7, 1, 0, 0, 0]], "output": [[0, 0, 0], [3, 0, 0], [0, 0, 3], [3, 3, 0]]}, {"input": [[7, 0, 7, 1, 5, 5, 0], [7, 7, 0, 1, 5, 5, 5], [0, 7, 0, 1, 0, 0, 0], [0, 0, 0, 1, 5, 0, 5]], "output": [[0, 0, 0], [0, 0, 0], [3, 0, 3], [0, 3, 0]]}, {"input": [[7, 0, 0, 1, 0, 5, 0], [0, 0, 7, 1, 5, 0, 0], [0, 0, 0, 1, 5, 5, 5], [7, 7, 7, 1, 5, 5, 5]], "output": [[0, 0, 3], [0, 3, 0], [0, 0, 0], [0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 1, 0, 5, 0], [7, 7, 7, 1, 5, 5, 0], [0, 0, 0, 1, 5, 0, 0], [7, 0, 0, 1, 5, 5, 5]], "output": [[3, 0, 3], [0, 0, 0], [0, 3, 3], [0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef mark_common_black(left: np.ndarray, right: np.ndarray, output: np.ndarray) -> None:\n    \"\"\"\n    Marks every location of output to green if left and right in the same location both are black.\n\n    Args:\n    left (np.ndarray): The left half of the input grid.\n    right (np.ndarray): The right half of the input grid.\n    output (np.ndarray): The output grid.\n    \"\"\"\n    for i in range(output.shape[0]):\n        for j in range(output.shape[1]):\n            if left[i][j] == black and right[i][j] == black:\n                output[i][j] = green\n\ndef create_black_array() -> np.ndarray:\n    return np.full((4, 3), black)\n\ndef split_grid(input_grid: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Splits the input grid into two 4x3 grids based on the blue color.\n\n    Args:\n    input_grid (np.ndarray): The input grid.\n\n    Returns:\n    Tuple[np.ndarray, np.ndarray]: The left and right 4x3 grids.\n    \"\"\"\n    blue_indices = np.where(input_grid == blue)\n    blue_columns = np.unique(blue_indices[1])\n    blue_column_index = blue_columns[0]\n    left = input_grid[:, :blue_column_index]\n    right = input_grid[:, blue_column_index + 1:]\n    return (left, right)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    left, right = split_grid(input_grid)\n    output = create_black_array()\n    mark_common_black(left, right, output)\n    return output"},
{"name": "c9f8e694.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 5, 5, 0, 0, 0, 0, 5, 5, 0, 0], [2, 0, 5, 5, 0, 0, 0, 0, 5, 5, 0, 0], [2, 0, 5, 5, 0, 0, 0, 0, 5, 5, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [1, 0, 0, 0, 5, 5, 5, 0, 5, 5, 0, 0], [1, 0, 0, 0, 5, 5, 5, 0, 5, 5, 0, 0], [2, 0, 0, 0, 5, 5, 5, 0, 5, 5, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0], [2, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0], [2, 0, 2, 2, 0, 0, 0, 0, 2, 2, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [2, 0, 0, 0, 2, 2, 2, 0, 2, 2, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [3, 5, 5, 5, 5, 0, 0, 5, 5, 5, 5, 5], [4, 5, 5, 5, 5, 0, 0, 5, 5, 5, 5, 5], [4, 5, 5, 5, 5, 0, 0, 5, 5, 5, 5, 5], [3, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5], [4, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5], [3, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5], [3, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5], [3, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5], [4, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0], [4, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 3], [4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4], [3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3], [4, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4], [3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3], [3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3], [3, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3], [4, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0], [4, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0]]}], "test": [{"input": [[1, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [8, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [1, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [1, 0, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5], [7, 0, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5], [7, 0, 5, 5, 5, 5, 5, 5, 0, 5, 5, 5], [7, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5], [7, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [8, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0], [8, 0, 5, 5, 5, 0, 5, 5, 5, 0, 0, 0], [8, 0, 5, 5, 5, 0, 5, 5, 5, 0, 0, 0], [8, 0, 5, 5, 5, 0, 5, 5, 5, 0, 0, 0]], "output": [[1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [8, 0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1], [7, 0, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7], [7, 0, 7, 7, 7, 7, 7, 7, 0, 7, 7, 7], [7, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7], [7, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0], [8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 0, 0], [8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0], [8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0], [8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef paint_gray_pixels(input_grid: np.ndarray) -> np.ndarray:\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == grey:\n                input_grid[i][j] = input_grid[i][0]\n    return input_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    return paint_gray_pixels(input_grid)"},
{"name": "1b2d62fb.json", "data": {"train": [{"input": [[0, 9, 9, 1, 9, 9, 9], [0, 0, 9, 1, 9, 9, 0], [9, 0, 9, 1, 9, 9, 0], [0, 0, 0, 1, 9, 0, 0], [0, 9, 9, 1, 9, 9, 9]], "output": [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 8, 8], [0, 0, 0]]}, {"input": [[0, 0, 0, 1, 9, 0, 0], [9, 0, 9, 1, 9, 9, 9], [0, 9, 9, 1, 9, 9, 9], [0, 0, 0, 1, 9, 9, 9], [0, 9, 9, 1, 9, 9, 9]], "output": [[0, 8, 8], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]}, {"input": [[9, 0, 0, 1, 9, 0, 9], [9, 0, 0, 1, 0, 9, 0], [9, 0, 0, 1, 9, 0, 0], [0, 9, 9, 1, 0, 9, 9], [0, 0, 9, 1, 0, 9, 0]], "output": [[0, 8, 0], [0, 0, 8], [0, 8, 8], [8, 0, 0], [8, 0, 0]]}, {"input": [[0, 9, 9, 1, 9, 0, 9], [9, 0, 0, 1, 9, 0, 0], [9, 9, 9, 1, 9, 9, 9], [0, 9, 0, 1, 0, 0, 0], [9, 0, 0, 1, 9, 0, 0]], "output": [[0, 0, 0], [0, 8, 8], [0, 0, 0], [8, 0, 8], [0, 8, 8]]}, {"input": [[0, 9, 9, 1, 9, 0, 9], [9, 0, 9, 1, 9, 9, 9], [9, 9, 9, 1, 0, 0, 9], [9, 0, 0, 1, 9, 0, 0], [9, 9, 9, 1, 0, 0, 9]], "output": [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 8, 8], [0, 0, 0]]}], "test": [{"input": [[9, 9, 0, 1, 0, 9, 0], [0, 9, 9, 1, 0, 0, 0], [9, 9, 0, 1, 0, 9, 0], [9, 9, 9, 1, 9, 0, 9], [0, 9, 9, 1, 0, 9, 9]], "output": [[0, 0, 8], [8, 0, 0], [0, 0, 8], [0, 0, 0], [8, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_pos_to_teal(grid: np.ndarray, pos: List[Tuple[int, int]]) -> np.ndarray:\n    for i, j in pos:\n        grid[i, j] = teal\n    return grid\n\ndef get_black_pixels_indices(region1: np.ndarray, region2: np.ndarray) -> List[Tuple[int, int]]:\n    black_pixels = []\n    for i in range(region1.shape[0]):\n        for j in range(region1.shape[1]):\n            if region1[i, j] == black and region2[i, j] == black:\n                black_pixels.append((i, j))\n    return black_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    region1 = input_grid[:, :3]\n    region2 = input_grid[:, -3:]\n    output_grid = np.zeros((5, 3), dtype=int)\n    black_pixels = get_black_pixels_indices(region1, region2)\n    pos = black_pixels\n    output_grid = change_pos_to_teal(output_grid, pos)\n    return output_grid"},
{"name": "7f4411dc.json", "data": {"train": [{"input": [[0, 7, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7], [0, 0, 0, 0, 7, 0, 0, 0, 7, 7, 7, 7, 7], [0, 0, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 0, 0, 0, 0, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7], [0, 0, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 6, 0, 0, 0, 0, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0, 0, 6], [0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0, 6, 0, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5], [0, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 5, 0], [5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0]], "output": [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 0, 0], [0, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [0, 8, 0, 0, 0, 0, 0, 8, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 8, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 8, 8, 8, 8, 8, 0], [8, 0, 0, 0, 8, 8, 8, 8, 8, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 8]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef remove_inner_pixels(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Find all non-black pixels not in the edge line or at the corner. If at least 3 of 4 neighbors of the pixel are black, turn it to black. Return the grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    \n    Returns:\n    A numpy array representing the modified grid with inner pixels removed\n    \"\"\"\n    height, width = input_grid.shape\n    for i in range(1, height - 1):\n        for j in range(1, width - 1):\n            if input_grid[i][j] != black:\n                black_neighbors = 0\n                if input_grid[i - 1][j] == black:\n                    black_neighbors += 1\n                if input_grid[i + 1][j] == black:\n                    black_neighbors += 1\n                if input_grid[i][j - 1] == black:\n                    black_neighbors += 1\n                if input_grid[i][j + 1] == black:\n                    black_neighbors += 1\n                if black_neighbors >= 3:\n                    input_grid[i][j] = black\n    return input_grid\n\ndef remove_edge_pixels(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Find all non-black pixels in the edge line. If at least 2 of 4 neighbors of the pixel are black, turn it to black. Return the grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    \n    Returns:\n    A numpy array representing the modified grid with edge pixels removed\n    \"\"\"\n    height, width = input_grid.shape\n    for i in range(height):\n        for j in range(width):\n            if i == 0 or i == height - 1 or j == 0 or (j == width - 1):\n                if input_grid[i][j] != black:\n                    black_neighbors = 0\n                    if i > 0 and input_grid[i - 1][j] == black:\n                        black_neighbors += 1\n                    if i < height - 1 and input_grid[i + 1][j] == black:\n                        black_neighbors += 1\n                    if j > 0 and input_grid[i][j - 1] == black:\n                        black_neighbors += 1\n                    if j < width - 1 and input_grid[i][j + 1] == black:\n                        black_neighbors += 1\n                    if black_neighbors >= 2:\n                        input_grid[i][j] = black\n    return input_grid\n\ndef remove_corner_pixels(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Find all non-black pixels at the corner. If any neighbor of the pixel is black, turn it to black. Return the grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid\n    \n    Returns:\n    A numpy array representing the modified grid with corner pixels removed\n    \"\"\"\n    height, width = input_grid.shape\n    for i in range(height):\n        for j in range(width):\n            if i == 0 or i == height - 1:\n                if j == 0 or j == width - 1:\n                    if input_grid[i][j] != black:\n                        if i == 0 and j == 0:\n                            if input_grid[i + 1][j] == black or input_grid[i][j + 1] == black:\n                                input_grid[i][j] = black\n                        elif i == 0 and j == width - 1:\n                            if input_grid[i + 1][j] == black or input_grid[i][j - 1] == black:\n                                input_grid[i][j] = black\n                        elif i == height - 1 and j == 0:\n                            if input_grid[i - 1][j] == black or input_grid[i][j + 1] == black:\n                                input_grid[i][j] = black\n                        elif i == height - 1 and j == width - 1:\n                            if input_grid[i - 1][j] == black or input_grid[i][j - 1] == black:\n                                input_grid[i][j] = black\n    return input_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    out1 = remove_corner_pixels(input_grid)\n    out2 = remove_edge_pixels(out1)\n    out = remove_inner_pixels(out2)\n    return out"},
{"name": "dae9d2b5.json", "data": {"train": [{"input": [[4, 4, 0, 3, 3, 0], [4, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 3]], "output": [[6, 6, 0], [6, 0, 0], [0, 0, 6]]}, {"input": [[4, 0, 4, 3, 3, 0], [4, 0, 0, 3, 0, 0], [0, 0, 4, 3, 0, 0]], "output": [[6, 6, 6], [6, 0, 0], [6, 0, 6]]}, {"input": [[0, 0, 4, 0, 3, 0], [0, 4, 4, 3, 0, 3], [4, 4, 0, 0, 0, 3]], "output": [[0, 6, 6], [6, 6, 6], [6, 6, 6]]}, {"input": [[4, 4, 0, 3, 0, 0], [0, 0, 0, 0, 0, 3], [4, 0, 0, 0, 0, 0]], "output": [[6, 6, 0], [0, 0, 6], [6, 0, 0]]}, {"input": [[0, 0, 0, 0, 3, 0], [4, 0, 0, 0, 0, 0], [0, 0, 4, 3, 3, 0]], "output": [[0, 6, 0], [6, 0, 0], [6, 6, 6]]}], "test": [{"input": [[0, 4, 4, 3, 0, 0], [4, 0, 0, 3, 3, 0], [0, 4, 0, 3, 0, 0]], "output": [[6, 6, 6], [6, 6, 0], [6, 6, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef turn_non_black_to_pink(copy: np.ndarray) -> np.ndarray:\n    copy[copy != black] = pink\n    return copy\n\ndef copy_non_black_pixels(sub1: np.ndarray, sub2: np.ndarray, new: np.ndarray) -> np.ndarray:\n    mask = sub2 != black\n    new[mask] = sub2[mask]\n    return new\n\ndef create_sub1_grid(input_grid: np.ndarray) -> np.ndarray:\n    sub1 = input_grid[:, :3]\n    return sub1\n\ndef split_grid(input_grid: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    sub1 = input_grid[:, :3]\n    sub2 = input_grid[:, 3:]\n    return (sub1, sub2)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    sub1, sub2 = split_grid(input_grid)\n    new = create_sub1_grid(sub1)\n    copy = copy_non_black_pixels(sub1, sub2, new)\n    out = turn_non_black_to_pink(copy)\n    return out"},
{"name": "3618c87e.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 5, 0, 0], [5, 5, 5, 5, 5]], "output": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 5, 0, 0], [5, 5, 1, 5, 5]]}, {"input": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [0, 5, 0, 5, 0], [5, 5, 5, 5, 5]], "output": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 5, 0, 5, 0], [5, 1, 5, 1, 5]]}, {"input": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 1, 0, 0, 1], [0, 5, 0, 0, 5], [5, 5, 5, 5, 5]], "output": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 5, 0, 0, 5], [5, 1, 5, 5, 1]]}], "test": [{"input": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 1, 0, 1], [0, 0, 5, 0, 5], [5, 5, 5, 5, 5]], "output": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 5, 0, 5], [5, 5, 1, 5, 1]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_downmost_grey_pixel(blue_pixel: Tuple[int, int], grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Given a blue pixel and a grid, returns the downmost grey pixel in the same column as the blue pixel.\n    \n    Args:\n    - blue_pixel: a tuple representing the indices of a blue pixel in the grid.\n    - grid: a numpy array representing the grid\n    \n    Returns:\n    - A tuple representing the indices of the downmost grey pixel in the same column as the blue pixel.\n    \"\"\"\n    for i in range(grid.shape[0] - 1, blue_pixel[0], -1):\n        if grid[i][blue_pixel[1]] == grey:\n            return (i, blue_pixel[1])\n    return blue_pixel\n\ndef find_blue_pixels(grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given a grid, returns a list of indices of blue pixels in the grid.\n    \n    Args:\n    - grid: a numpy array representing the grid\n    \n    Returns:\n    - A list of tuples representing the indices of blue pixels in the grid.\n    \"\"\"\n    blue_pixels = []\n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if grid[i][j] == blue:\n                blue_pixels.append((i, j))\n    return blue_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    find the blue pixels, color the downmost grey pixels that in the same column of the blue pixels to blue, and color origin blue pixels to black.\n    \"\"\"\n    output_grid = input_grid.copy()\n    blue_pixels = find_blue_pixels(output_grid)\n    for blue_pixel in blue_pixels:\n        downmost_grey_pixel = find_downmost_grey_pixel(blue_pixel, output_grid)\n        output_grid[downmost_grey_pixel[0], downmost_grey_pixel[1]] = blue\n        output_grid[blue_pixel[0], blue_pixel[1]] = black\n    return output_grid"},
{"name": "8efcae92.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 2, 1, 0, 0, 0, 1, 2, 1, 1, 1, 1, 2, 1, 0, 0], [0, 0, 1, 1, 2, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0], [0, 0, 1, 2, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 2, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 2, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[1, 1, 1, 1, 1, 1], [1, 2, 1, 2, 1, 1], [1, 1, 2, 1, 2, 1], [1, 2, 1, 1, 1, 1], [1, 1, 1, 2, 1, 1]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 2, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 1, 1, 1, 1, 1, 2], [0, 0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 0, 0, 1, 1, 2, 1, 1, 1], [0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 2, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 0, 0, 1, 2, 1, 1, 1, 1], [0, 0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 2, 1], [0, 0, 1, 1, 1, 2, 1, 1, 1, 1, 2, 0, 0, 0, 1, 2, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 2, 1, 1, 1, 1, 1, 2, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 2, 1, 1, 1, 1, 0, 0, 1, 1, 1, 2, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 0, 1, 2, 1, 1, 1, 1, 0, 0, 0], [1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[1, 1, 1, 1, 2, 1, 1, 1, 1], [1, 2, 1, 1, 1, 1, 1, 1, 2], [1, 1, 1, 1, 1, 2, 1, 1, 1], [1, 1, 1, 2, 1, 1, 1, 2, 1], [2, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 2, 1, 1, 1], [1, 2, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 2, 1, 1, 1, 1, 2]]}, {"input": [[0, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 2, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0], [0, 1, 2, 1, 1, 2, 1, 0, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 2, 1, 2, 1, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 0, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 2, 1, 2, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0], [0, 0, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 0]], "output": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1], [1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1], [1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 2, 1, 1, 0, 0, 0], [0, 1, 2, 1, 1, 1, 0, 0, 0, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 2, 1, 1, 0, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 2, 1, 1, 1, 0, 0, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 0], [0, 1, 1, 1, 2, 1, 0, 0, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 2, 1, 1, 1, 2, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 1, 1, 2, 1]], "output": [[1, 1, 1, 1, 2, 1, 1, 2, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 2, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 2, 1, 1, 2, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 2, 1, 2, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 2, 1, 1], [1, 1, 2, 1, 2, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef get_max_red_rect(blue_red_rects, input_grid):\n    return input_grid[blue_red_rects[0][0]:blue_red_rects[1][0] + 1, blue_red_rects[0][1]:blue_red_rects[1][1] + 1]\n\ndef find_blue_rect_with_most_red_pixels(blue_red_rects: List[Tuple[Tuple[int, int], Tuple[int, int]]], input_grid: np.ndarray) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Given a list of blue rectangles (may include red pixels) and an input grid, this function finds the blue rectangle with the most red pixels.\n\n    Args:\n    - blue_red_rects (List[Tuple[Tuple[int, int], Tuple[int, int]]]): A list of tuples, where each tuple represents the top-left and bottom-right coordinates of a blue rectangle in the input grid.\n    - input_grid (np.ndarray): A 2D numpy array representing the input grid.\n\n    Returns:\n    - Tuple[Tuple[int, int], Tuple[int, int]]: A tuple representing the top-left and bottom-right coordinates of the blue rectangle with the most red pixels in the input grid.\n    \"\"\"\n    max_red_pixels = 0\n    max_red_rect = None\n    for rect in blue_red_rects:\n        top_left = rect[0]\n        bottom_right = rect[1]\n        red_pixels = 0\n        for i in range(top_left[0], bottom_right[0] + 1):\n            for j in range(top_left[1], bottom_right[1] + 1):\n                if input_grid[i][j] == red:\n                    red_pixels += 1\n        if red_pixels > max_red_pixels:\n            max_red_pixels = red_pixels\n            max_red_rect = rect\n    return max_red_rect\n\ndef find_blue_rectangles(input_grid: np.ndarray) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n    \"\"\"                                                                                                                                          \n    Given an input grid, this function finds all the blue rectangles (may include red pixels) in the input_grid.                                 \n                                                                                                                                                 \n    Args:                                                                                                                                        \n    input_grid: A numpy array representing the input grid.                                                                                       \n                                                                                                                                                 \n    Returns:                                                                                                                                     \n    A list of tuples, where each tuple represents the top-left and bottom-right coordinates of a blue rectangle.                                 \n    \"\"\"\n    flags = np.zeros_like(input_grid)\n    blue_rects = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == blue and (not flags[i, j]):\n                top_left = (i, j)\n                bottom_right = (i, j)\n                while bottom_right[1] < input_grid.shape[1] - 1 and input_grid[i][bottom_right[1] + 1] in [blue, red]:\n                    bottom_right = (i, bottom_right[1] + 1)\n                while bottom_right[0] < input_grid.shape[0] - 1 and input_grid[bottom_right[0] + 1][j] in [blue, red]:\n                    bottom_right = (bottom_right[0] + 1, bottom_right[1])\n                blue_rects.append((top_left, bottom_right))\n                flags[top_left[0]:bottom_right[0] + 1, top_left[1]:bottom_right[1] + 1] = 1\n    return blue_rects\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    blue_red_rects = find_blue_rectangles(input_grid)\n    max_red_rect = find_blue_rect_with_most_red_pixels(blue_red_rects, input_grid)\n    output_grid = get_max_red_rect(max_red_rect, input_grid)\n    return output_grid"},
{"name": "2dc579da.json", "data": {"train": [{"input": [[8, 8, 3, 8, 8], [8, 8, 3, 8, 8], [3, 3, 3, 3, 3], [8, 8, 3, 8, 8], [4, 8, 3, 8, 8]], "output": [[8, 8], [4, 8]]}, {"input": [[4, 4, 4, 2, 4, 4, 4], [4, 4, 4, 2, 4, 1, 4], [4, 4, 4, 2, 4, 4, 4], [2, 2, 2, 2, 2, 2, 2], [4, 4, 4, 2, 4, 4, 4], [4, 4, 4, 2, 4, 4, 4], [4, 4, 4, 2, 4, 4, 4]], "output": [[4, 4, 4], [4, 1, 4], [4, 4, 4]]}, {"input": [[3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3], [3, 8, 3, 3, 3, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 1, 3, 3, 3, 3, 3]], "output": [[3, 3, 3, 3, 3], [3, 3, 3, 3, 3], [3, 8, 3, 3, 3], [3, 3, 3, 3, 3], [3, 3, 3, 3, 3]]}], "test": [{"input": [[1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 1, 2, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1]], "output": [[1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 2, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_non_monochrome_array(inputs: Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]) -> np.ndarray:\n    for arr in inputs:\n        if len(np.unique(arr)) > 1:\n            return arr\n    return None\n\ndef split_input(input: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:\n    center_x = input.shape[0] // 2\n    center_y = input.shape[1] // 2\n    top_left = input[:center_x, :center_y]\n    top_right = input[:center_x, center_y + 1:]\n    bottom_left = input[center_x + 1:, :center_y]\n    bottom_right = input[center_x + 1:, center_y + 1:]\n    return (top_left, top_right, bottom_left, bottom_right)\n\ndef transform_grid(input):\n    inputs = split_input(input)\n    output = find_non_monochrome_array(inputs)\n    return output"},
{"name": "7837ac64.json", "data": {"train": [{"input": [[0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 1, 4, 4, 1, 4, 4, 3, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 1, 4, 4, 1, 4, 4, 3, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 1, 4, 4, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 1, 4, 4, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0]], "output": [[1, 0, 3], [1, 0, 0], [1, 0, 0]]}, {"input": [[0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [3, 3, 3, 2, 3, 3, 3, 2, 3, 3, 3, 8, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0]], "output": [[0, 2, 0], [2, 0, 0], [0, 0, 8]]}, {"input": [[0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 6, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 1, 1, 6, 1, 1, 6, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0]], "output": [[6, 6, 0], [0, 0, 0], [3, 3, 3]]}, {"input": [[0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 2, 8, 8, 8, 2, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 8, 2, 8, 8, 8, 2, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 2, 8, 8, 8, 2, 8, 8, 8, 2, 8, 8, 8, 2, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 2, 8, 8, 8, 2, 8, 8, 8, 2, 8, 8, 8, 2, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0]], "output": [[1, 0, 2], [0, 0, 2], [2, 2, 2]]}], "test": [{"input": [[0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 4, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [2, 2, 2, 2, 1, 2, 2, 2, 2, 1, 2, 2, 2, 2, 4, 2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [2, 2, 2, 2, 8, 2, 2, 2, 2, 8, 2, 2, 2, 2, 8, 2, 2, 2, 2, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [2, 2, 2, 2, 8, 2, 2, 2, 2, 8, 2, 2, 2, 2, 8, 2, 2, 2, 2, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0]], "output": [[1, 0, 4], [0, 0, 0], [8, 8, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef check_non_black_pixels_in_first_row_and_column(temp_grid: np.ndarray) -> bool:\n    if np.any(temp_grid[0] != black) and np.any(temp_grid[:, 0] != black):\n        return True\n    return False\n\ndef assign_colors_to_temp_grid(input_grid: np.ndarray, temp_grid: np.ndarray, i: int, j: int, n: int) -> np.ndarray:\n    temp_grid[0][0] = input_grid[i][j]\n    temp_grid[0][1] = input_grid[i][j + n + 1]\n    temp_grid[0][2] = input_grid[i][j + 2 * n + 2]\n    temp_grid[1][0] = input_grid[i + n + 1][j]\n    temp_grid[1][1] = input_grid[i + n + 1][j + n + 1]\n    temp_grid[1][2] = input_grid[i + n + 1][j + 2 * n + 2]\n    temp_grid[2][0] = input_grid[i + 2 * n + 2][j]\n    temp_grid[2][1] = input_grid[i + 2 * n + 2][j + n + 1]\n    temp_grid[2][2] = input_grid[i + 2 * n + 2][j + 2 * n + 2]\n    return temp_grid\n\ndef assign_color_to_n_by_n_area(input_grid: np.ndarray, i: int, j: int, n: int, c_now: int) -> np.ndarray:\n    input_grid[i + 1:i + n + 1, j + 1:j + n + 1] = c_now\n    return input_grid\n\ndef check_adjacent_colors(input_grid: np.ndarray, i: int, j: int, n: int, c_now: int) -> bool:\n    if i + n + 1 < input_grid.shape[0] and input_grid[i + n + 1][j] != c_now:\n        return False\n    if j + n + 1 < input_grid.shape[1] and input_grid[i][j + n + 1] != c_now:\n        return False\n    if i + n + 1 < input_grid.shape[0] and j + n + 1 < input_grid.shape[1] and (input_grid[i + n + 1][j + n + 1] != c_now):\n        return False\n    return True\n\ndef is_adjacent_pixels_same_color_except_current_pixel(input_grid: np.ndarray, i: int, j: int, c: int) -> bool:\n    if i > 0 and input_grid[i - 1][j] != c:\n        return False\n    if i < input_grid.shape[0] - 1 and input_grid[i + 1][j] != c:\n        return False\n    if j > 0 and input_grid[i][j - 1] != c:\n        return False\n    if j < input_grid.shape[1] - 1 and input_grid[i][j + 1] != c:\n        return False\n    if input_grid[i][j] == c:\n        return False\n    return True\n\ndef get_color_and_spacing(input_grid: np.ndarray) -> Tuple[int, int]:\n    c = 0\n    n = 0\n    for i in range(input_grid.shape[1]):\n        if input_grid[0][i] != black:\n            c = input_grid[0][i]\n            n = i\n            break\n    return (c, n)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    c, n = get_color_and_spacing(input_grid)\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if is_adjacent_pixels_same_color_except_current_pixel(input_grid, i, j, c):\n                c_now = input_grid[i, j]\n                if check_adjacent_colors(input_grid, i, j, n, c_now):\n                    input_grid = assign_color_to_n_by_n_area(input_grid, i, j, n, c_now)\n    for i in range(0, input_grid.shape[0] - 2 * n - 1, n + 1):\n        for j in range(0, input_grid.shape[1] - 2 * n - 1, n + 1):\n            temp_grid = np.zeros((3, 3), dtype=np.int32)\n            temp_grid = assign_colors_to_temp_grid(input_grid, temp_grid, i, j, n)\n            if check_non_black_pixels_in_first_row_and_column(temp_grid):\n                return temp_grid\n    return np.zeros((3, 3), dtype=np.int32)"},
{"name": "22eb0ac0.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 0, 0, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 9], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 0, 0, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 9], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 3]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 3]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 0, 0, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 0, 0, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 9], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 0, 0, 0, 0, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 0, 0, 4]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 9], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 0, 0, 0, 0, 0, 0, 0, 0, 4]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef fill_lines(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    For each line in the input grid, if the start of the line is non-zero and equal to the end of the line,\n    fill the line with the start element.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the output grid with filled lines.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    for i in range(output_grid.shape[0]):\n        if output_grid[i, 0] != 0 and output_grid[i, 0] == output_grid[i, -1]:\n            output_grid[i, :] = output_grid[i, 0]\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = fill_lines(input_grid)\n    return output_grid"},
{"name": "e9614598.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 1, 0, 3, 3, 3, 0, 1, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 3, 3, 3, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef draw_green_cross(input_grid: np.ndarray, x: int, y: int) -> np.ndarray:\n    \"\"\"\n    Given a 2D numpy array, draw a green cross of length 3 centered on (x,y).\n    \n    Args:\n    input_grid: A 2D numpy array representing the input grid.\n    x: An integer representing the x-coordinate of the center of the cross.\n    y: An integer representing the y-coordinate of the center of the cross.\n    \n    Returns:\n    A 2D numpy array representing the output grid with the green cross drawn on it.\n    \"\"\"\n    output_grid = input_grid.copy()\n    output_grid[x, y - 1:y + 2] = green\n    output_grid[x - 1:x + 2, y] = green\n    return output_grid\n\ndef find_middle_point(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Given a 2D numpy array, find the middle point of two blue pixels in the grid.\n    \n    Args:\n    input_grid: A 2D numpy array representing the input grid.\n    \n    Returns:\n    A tuple of two integers representing the middle point of two blue pixels in the grid.\n    \"\"\"\n    rows, cols = input_grid.shape\n    blue_pixels = []\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] == blue:\n                blue_pixels.append((i, j))\n    (x1, y1), (x2, y2) = blue_pixels\n    x = (x1 + x2) // 2\n    y = (y1 + y2) // 2\n    return (x, y)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    x, y = find_middle_point(input_grid)\n    output_grid = draw_green_cross(input_grid, x, y)\n    return output_grid"},
{"name": "d406998b.json", "data": {"train": [{"input": [[5, 0, 5, 0, 0, 5, 0, 0, 0, 5], [0, 5, 0, 0, 5, 0, 0, 5, 0, 0], [0, 0, 0, 5, 0, 0, 5, 0, 5, 0]], "output": [[5, 0, 5, 0, 0, 3, 0, 0, 0, 3], [0, 3, 0, 0, 5, 0, 0, 3, 0, 0], [0, 0, 0, 3, 0, 0, 5, 0, 5, 0]]}, {"input": [[0, 5, 0, 5, 0, 0, 5, 0, 5, 0, 0, 0], [5, 0, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0], [0, 0, 5, 0, 0, 5, 0, 0, 0, 5, 0, 5]], "output": [[0, 3, 0, 3, 0, 0, 5, 0, 5, 0, 0, 0], [5, 0, 0, 0, 5, 0, 0, 3, 0, 0, 5, 0], [0, 0, 5, 0, 0, 3, 0, 0, 0, 3, 0, 3]]}, {"input": [[0, 0, 5, 0, 0, 5, 0, 5, 0, 0, 0, 5, 0], [5, 0, 0, 0, 5, 0, 5, 0, 0, 5, 0, 0, 5], [0, 5, 0, 5, 0, 0, 0, 0, 5, 0, 5, 0, 0]], "output": [[0, 0, 3, 0, 0, 5, 0, 5, 0, 0, 0, 5, 0], [3, 0, 0, 0, 3, 0, 3, 0, 0, 5, 0, 0, 3], [0, 5, 0, 5, 0, 0, 0, 0, 3, 0, 3, 0, 0]]}, {"input": [[0, 0, 5, 0, 0, 5, 0, 5, 0, 5, 0, 5, 0, 0], [5, 0, 0, 0, 5, 0, 0, 0, 5, 0, 5, 0, 0, 5], [0, 5, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0]], "output": [[0, 0, 5, 0, 0, 3, 0, 3, 0, 3, 0, 3, 0, 0], [5, 0, 0, 0, 5, 0, 0, 0, 5, 0, 5, 0, 0, 3], [0, 3, 0, 3, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0]]}], "test": [{"input": [[0, 0, 0, 5, 0, 0, 0, 5, 0, 5, 0, 0, 5, 0, 5, 0, 0], [5, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0, 0, 0, 5, 0], [0, 5, 0, 0, 5, 0, 5, 0, 0, 0, 5, 0, 0, 5, 0, 0, 5]], "output": [[0, 0, 0, 5, 0, 0, 0, 5, 0, 5, 0, 0, 3, 0, 3, 0, 0], [3, 0, 3, 0, 0, 5, 0, 0, 3, 0, 0, 5, 0, 0, 0, 5, 0], [0, 5, 0, 0, 3, 0, 3, 0, 0, 0, 3, 0, 0, 5, 0, 0, 3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_grey_with_green(grid: np.ndarray, i: int) -> np.ndarray:\n    \"\"\"\n    This function replaces the grey elements in the i-th column of the grid with green elements if the total number of columns minus i is odd.\n\n    Args:\n    grid: A numpy array representing the input grid.\n    i: An integer representing the column index.\n\n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    if (grid.shape[1] - i) % 2 == 1:\n        for j in range(grid.shape[0]):\n            if grid[j][i] == grey:\n                grid[j][i] = green\n    return grid\n\ndef initialize_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = initialize_grid(input_grid)\n    for i in range(input_grid.shape[1]):\n        output_grid = replace_grey_with_green(output_grid, i)\n    return output_grid"},
{"name": "25ff71a9.json", "data": {"train": [{"input": [[1, 1, 1], [0, 0, 0], [0, 0, 0]], "output": [[0, 0, 0], [1, 1, 1], [0, 0, 0]]}, {"input": [[0, 0, 0], [1, 1, 1], [0, 0, 0]], "output": [[0, 0, 0], [0, 0, 0], [1, 1, 1]]}, {"input": [[0, 1, 0], [1, 1, 0], [0, 0, 0]], "output": [[0, 0, 0], [0, 1, 0], [1, 1, 0]]}, {"input": [[0, 2, 2], [0, 0, 2], [0, 0, 0]], "output": [[0, 0, 0], [0, 2, 2], [0, 0, 2]]}], "test": [{"input": [[2, 0, 0], [2, 0, 0], [0, 0, 0]], "output": [[0, 0, 0], [2, 0, 0], [2, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef translate_pixels_down(input_grid: np.ndarray, pixels: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    Given an input grid and a list of pixels, translates each pixel down for 1 pixel.                                                                                   \n                                                                                                                                                                        \n    Args:                                                                                                                                                               \n    - input_grid: a numpy ndarray representing the input grid                                                                                                           \n    - pixels: a list of tuples containing the indices of all non-black pixels                                                                                           \n                                                                                                                                                                        \n    Returns:                                                                                                                                                            \n    - A numpy ndarray representing the output grid with translated pixels                                                                                               \n    \"\"\"\n    output_grid = input_grid.copy()\n    for pixel in pixels:\n        i, j = pixel\n        output_grid[i][j] = black\n    for pixel in pixels:\n        i, j = pixel\n        output_grid[i + 1][j] = input_grid[i][j]\n    return output_grid\n\ndef find_non_black_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given an input grid, returns a list of tuples containing the indices of all non-black pixels.\n    \n    Args:\n    - input_grid: a numpy ndarray representing the input grid\n    \n    Returns:\n    - A list of tuples containing the indices of all non-black pixels.\n    \"\"\"\n    non_black_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black:\n                non_black_pixels.append((i, j))\n    return non_black_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    find the pixels which color is not black, translate each pixel down for 1 pixel.                                                    \n    \"\"\"\n    output_grid = input_grid.copy()\n    pixels = find_non_black_pixels(input_grid)\n    output_grid = translate_pixels_down(output_grid, pixels)\n    return output_grid"},
{"name": "928ad970.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 1, 0, 1, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], [0, 5, 1, 0, 0, 1, 0, 1, 0, 0, 1, 5, 0], [0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 5, 3, 0, 3, 3, 3, 0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 3, 0, 3, 0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 3, 3, 3, 0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 5, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 4, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0], [0, 0, 4, 0, 4, 0, 0, 4, 0, 0, 0, 4, 5, 0], [0, 0, 4, 0, 4, 0, 0, 4, 0, 0, 0, 4, 0, 0], [0, 5, 4, 0, 4, 4, 4, 4, 0, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 8, 8, 8, 8, 0, 0, 8, 0, 0, 0], [0, 0, 5, 8, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 8, 8, 8, 8, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 5, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef connect_p2_p4_with_color3(input_grid: np.ndarray, color3: int, p2: Tuple[int, int], p4: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Given an input grid, color3, p2 and p4, this function connects p2 and p4 with a line of color3.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    color3: An integer representing the third color present in the grid.\n    p2: A tuple of two integers representing the coordinates of point p2.\n    p4: A tuple of two integers representing the coordinates of point p4.\n\n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    x2, y2 = p2\n    x4, y4 = p4\n    if x2 == x4:\n        for y in range(min(y2, y4), max(y2, y4) + 1):\n            input_grid[x2][y] = color3\n    elif y2 == y4:\n        for x in range(min(x2, x4), max(x2, x4) + 1):\n            input_grid[x][y2] = color3\n    return input_grid\n\ndef connect_p1_p3_with_color3(input_grid: np.ndarray, color3: int, p1: Tuple[int, int], p3: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Given an input grid, color3, p1 and p3, this function connects p1 and p3 with a line of color3.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    color3: An integer representing the third color present in the grid.\n    p1: A tuple of two integers representing the coordinates of point p1.\n    p3: A tuple of two integers representing the coordinates of point p3.\n\n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    x1, y1 = p1\n    x3, y3 = p3\n    if x1 == x3:\n        for y in range(min(y1, y3), max(y1, y3) + 1):\n            input_grid[x1][y] = color3\n    elif y1 == y3:\n        for x in range(min(x1, x3), max(x1, x3) + 1):\n            input_grid[x][y1] = color3\n    return input_grid\n\ndef connect_p3_p4_with_color3(input_grid: np.ndarray, color3: int, p3: Tuple[int, int], p4: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Given an input grid, color3, p3 and p4, this function connects p3 and p4 with a line of color3.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    color3: An integer representing the third color present in the grid.\n    p3: A tuple of two integers representing the coordinates of point p3.\n    p4: A tuple of two integers representing the coordinates of point p4.\n\n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    x3, y3 = p3\n    x4, y4 = p4\n    if x3 == x4:\n        for y in range(min(y3, y4), max(y3, y4) + 1):\n            input_grid[x3][y] = color3\n    elif y3 == y4:\n        for x in range(min(x3, x4), max(x3, x4) + 1):\n            input_grid[x][y3] = color3\n    return input_grid\n\ndef connect_p1_p2_with_color3(input_grid: np.ndarray, color3: int, p1: Tuple[int, int], p2: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    Given an input grid, color3, p1 and p2, this function connects p1 and p2 with a line of color3.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    color3: An integer representing the third color present in the grid.\n    p1: A tuple of two integers representing the coordinates of point p1.\n    p2: A tuple of two integers representing the coordinates of point p2.\n\n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    x1, y1 = p1\n    x2, y2 = p2\n    if x1 == x2:\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            input_grid[x1][y] = color3\n    elif y1 == y2:\n        for x in range(min(x1, x2), max(x1, x2) + 1):\n            input_grid[x][y1] = color3\n    return input_grid\n\ndef find_gray_coordinates(input_grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Given an input grid, this function returns the minimum and maximum x and y coordinates of the gray cells.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A tuple of four integers representing the minimum and maximum x and y coordinates of the gray cells.\n    \"\"\"\n    gray_indices = np.where(input_grid == grey)\n    xmin = np.min(gray_indices[0])\n    xmax = np.max(gray_indices[0])\n    ymin = np.min(gray_indices[1])\n    ymax = np.max(gray_indices[1])\n    return (xmin, xmax, ymin, ymax)\n\ndef find_third_color(input_grid: np.ndarray) -> int:\n    \"\"\"\n    Given an input grid, this function returns the third color (besides black and gray) present in the grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    An integer representing the third color present in the grid.\n    \"\"\"\n    colors, counts = np.unique(input_grid, return_counts=True)\n    for color, count in zip(colors, counts):\n        if color not in [black, grey] and count > 0:\n            return color\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    color3 = find_third_color(input_grid)\n    xmin, xmax, ymin, ymax = find_gray_coordinates(input_grid)\n    p1 = (xmin + 1, ymin + 1)\n    p2 = (xmin + 1, ymax - 1)\n    p3 = (xmax - 1, ymin + 1)\n    p4 = (xmax - 1, ymax - 1)\n    output_grid = np.copy(input_grid)\n    output_grid = connect_p1_p2_with_color3(output_grid, color3, p1, p2)\n    output_grid = connect_p3_p4_with_color3(output_grid, color3, p3, p4)\n    output_grid = connect_p1_p3_with_color3(output_grid, color3, p1, p3)\n    output_grid = connect_p2_p4_with_color3(output_grid, color3, p2, p4)\n    return output_grid"},
{"name": "6fa7a44f.json", "data": {"train": [{"input": [[9, 1, 4], [9, 1, 4], [2, 1, 1]], "output": [[9, 1, 4], [9, 1, 4], [2, 1, 1], [2, 1, 1], [9, 1, 4], [9, 1, 4]]}, {"input": [[4, 8, 4], [7, 6, 7], [8, 7, 8]], "output": [[4, 8, 4], [7, 6, 7], [8, 7, 8], [8, 7, 8], [7, 6, 7], [4, 8, 4]]}, {"input": [[7, 7, 7], [9, 5, 5], [5, 1, 7]], "output": [[7, 7, 7], [9, 5, 5], [5, 1, 7], [5, 1, 7], [9, 5, 5], [7, 7, 7]]}, {"input": [[2, 6, 9], [2, 6, 9], [2, 9, 2]], "output": [[2, 6, 9], [2, 6, 9], [2, 9, 2], [2, 9, 2], [2, 6, 9], [2, 6, 9]]}], "test": [{"input": [[2, 9, 2], [8, 5, 2], [2, 2, 8]], "output": [[2, 9, 2], [8, 5, 2], [2, 2, 8], [2, 2, 8], [8, 5, 2], [2, 9, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef concatenate_up_down(input_grid: np.ndarray, revert: np.ndarray) -> np.ndarray:\n    return np.concatenate((input_grid, revert))\n\ndef flip_upside_down(input_grid: np.ndarray) -> np.ndarray:\n    return np.flipud(input_grid)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    revert = flip_upside_down(input_grid)\n    output = concatenate_up_down(input_grid, revert)\n    return output"},
{"name": "321b1fc6.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 6, 0, 0, 0, 0, 0, 0, 0], [0, 9, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 6, 0, 0, 0], [0, 0, 0, 0, 0, 9, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 6, 0, 0, 0, 0, 0, 0], [0, 0, 9, 4, 0, 0, 0, 0, 7, 6], [0, 0, 0, 0, 0, 0, 0, 0, 9, 4]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 0, 0, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 7, 0, 0, 0], [0, 0, 0, 0, 0, 6, 6, 6, 0, 0], [0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 6, 6, 6, 0, 0, 7, 7, 0, 0], [0, 0, 0, 0, 0, 0, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 7, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 0, 0, 0, 8, 8, 0, 0], [8, 8, 8, 8, 0, 8, 8, 8, 8, 0], [0, 0, 8, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0, 0], [3, 4, 3, 3, 0, 0, 8, 8, 0, 0], [0, 0, 3, 0, 0, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 4, 4, 0, 0], [3, 4, 3, 3, 0, 3, 4, 3, 3, 0], [0, 0, 3, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 4, 0, 0], [0, 0, 0, 0, 0, 3, 4, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef overwrite_pixels(input_grid: np.ndarray, target_grid: np.ndarray, mask_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Traverse all the elements in the input_grid, match each pixel with a grid same as mask_grid, \n    if the current pixel is matched, overwrite the position with a grid same as target_grid\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if np.array_equal(input_grid[i:i + mask_grid.shape[0], j:j + mask_grid.shape[1]], mask_grid):\n                input_grid[i:i + target_grid.shape[0], j:j + target_grid.shape[1]] = target_grid\n    return input_grid\n\ndef generate_teal_mask(target_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Generate a new grid with the same size as the target_grid. If the pixel in the subgrid is non-black, the value in the new grid is teal; otherwise, it is black\n    \"\"\"\n    return np.where(target_grid != black, teal, black)\n\ndef extract_subgrid(grid: np.ndarray, minx: int, miny: int, maxx: int, maxy: int) -> np.ndarray:\n    \"\"\"\n    Extract the subgrid with (minx, miny) as the upper left corner and (maxx, maxy) as the lower right corner, and return the grid\n    \"\"\"\n    return grid[minx:maxx + 1, miny:maxy + 1]\n\ndef find_bounding_box(grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Define four variables (minx, miny, maxx, maxy) as the smallest x, the smallest y, the largest x, and the largest y. \n    Traverse all the pixels in the new grid, if a pixel (x, y) is not black, use the pixel to update the above four variables\n    \"\"\"\n    minx, miny, maxx, maxy = (float('inf'), float('inf'), -float('inf'), -float('inf'))\n    for x in range(grid.shape[0]):\n        for y in range(grid.shape[1]):\n            if grid[x, y] != black:\n                minx = min(minx, x)\n                miny = min(miny, y)\n                maxx = max(maxx, x)\n                maxy = max(maxy, y)\n    return (minx, miny, maxx, maxy)\n\ndef blacken_teal_pixels(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Generate a new grid, exactly the same as input_grid. Blacken all the teal pixels.\n    \"\"\"\n    return np.where(input_grid == teal, black, input_grid)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    ans_grid = blacken_teal_pixels(input_grid)\n    minx, miny, maxx, maxy = find_bounding_box(ans_grid)\n    target_grid = extract_subgrid(ans_grid, minx, miny, maxx, maxy)\n    mask_grid = generate_teal_mask(target_grid)\n    input_grid[minx:maxx + 1, miny:maxy + 1] = black\n    ans = overwrite_pixels(input_grid, target_grid, mask_grid)\n    return ans"},
{"name": "913fb3ed.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0], [6, 6, 6, 0, 4, 8, 4, 0, 0, 0, 0, 0], [6, 3, 6, 0, 4, 4, 4, 1, 1, 1, 0, 0], [6, 6, 6, 0, 0, 0, 0, 1, 2, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[0, 0, 6, 6, 6, 0], [0, 0, 6, 3, 6, 0], [0, 0, 6, 6, 6, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 3, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 0, 0], [0, 4, 8, 4, 0, 0], [0, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 3, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef set_elements_around_colors(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Sets black elements around red element in input grid to blue elments, sets black elements around green element in input grid to pink elements, and sets black elements around teal element in input grid to yellow elements.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the output grid after setting the elements around the specified colors.\n    \"\"\"\n    output_grid = copy_grid(input_grid)\n    for i in range(1, input_grid.shape[0] - 1):\n        for j in range(1, input_grid.shape[1] - 1):\n            if input_grid[i][j] == red:\n                output_grid[i - 1:i + 2, j - 1:j + 2][output_grid[i - 1:i + 2, j - 1:j + 2] == black] = blue\n            elif input_grid[i][j] == green:\n                output_grid[i - 1:i + 2, j - 1:j + 2][output_grid[i - 1:i + 2, j - 1:j + 2] == black] = pink\n            elif input_grid[i][j] == teal:\n                output_grid[i - 1:i + 2, j - 1:j + 2][output_grid[i - 1:i + 2, j - 1:j + 2] == black] = yellow\n    return output_grid\n\ndef copy_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns a copy of the input grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing a copy of the input grid.\n    \"\"\"\n    return np.copy(input_grid)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = copy_grid(input_grid)\n    output_grid = set_elements_around_colors(output_grid)\n    return output_grid"},
{"name": "1f642eb9.json", "data": {"train": [{"input": [[0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 9, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 9, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [6, 0, 0, 0, 6, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 2], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0], [3, 0, 0, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 6, 7, 8, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 8, 8, 2, 0, 0, 0, 2], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0], [3, 0, 0, 3, 8, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 6], [3, 0, 0, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0], [2, 0, 0, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 8, 6, 0, 0, 0, 6], [3, 0, 0, 3, 8, 8, 0, 0, 0, 0], [0, 0, 0, 8, 8, 8, 0, 0, 0, 0], [2, 0, 0, 2, 8, 8, 0, 0, 0, 0], [0, 0, 0, 7, 8, 2, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 6, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 0, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 8, 8, 8, 8, 0, 0, 0, 7], [3, 0, 8, 8, 8, 8, 0, 0, 0, 0], [4, 0, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 6, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 0, 9, 6, 8, 2, 0, 0, 0, 0], [0, 0, 8, 8, 8, 7, 0, 0, 0, 7], [3, 0, 3, 8, 8, 8, 0, 0, 0, 0], [4, 0, 4, 8, 6, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef rotate_grid_90_clockwise(grid: np.ndarray) -> np.ndarray:\n    return np.rot90(grid, k=-1)\n\ndef fill_leftmost_teal_block(grid: np.ndarray, row: int, color: int) -> np.ndarray:\n    for i in range(len(grid[row])):\n        if grid[row][i] == teal:\n            grid[row][i] = color\n            break\n    return grid\n\ndef find_non_black_cells(arr: np.ndarray) -> List[Tuple[int, int]]:\n    return [(arr[i], i) for i in range(len(arr)) if arr[i] != black]\n\ndef get_first_column(grid: np.ndarray) -> np.ndarray:\n    return grid[:, 0]\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n    for i in range(4):\n        first_col = get_first_column(output_grid)\n        list = find_non_black_cells(first_col)\n        for color, row in list:\n            output_grid = fill_leftmost_teal_block(output_grid, row, color)\n        output_grid = rotate_grid_90_clockwise(output_grid)\n    return output_grid"},
{"name": "780d0b14.json", "data": {"train": [{"input": [[1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 8, 8, 8, 8, 8, 0, 8, 8, 8], [1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 8, 0, 8, 8, 8, 8, 8, 8, 8, 8], [0, 1, 1, 0, 1, 1, 1, 1, 0, 8, 0, 8, 8, 0, 8, 8, 8, 0, 8, 8], [1, 0, 1, 1, 1, 1, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 8], [1, 1, 0, 1, 1, 1, 1, 1, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 0, 0], [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 8, 8, 0, 8, 8, 8, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 0, 6, 6, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0], [6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0], [0, 6, 0, 6, 6, 6, 0, 6, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1], [6, 6, 6, 0, 6, 6, 6, 6, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1], [6, 0, 6, 6, 0, 6, 0, 6, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1], [6, 6, 6, 6, 6, 0, 6, 6, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1], [6, 6, 6, 6, 6, 0, 6, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1], [6, 6, 6, 0, 6, 6, 0, 6, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1], [0, 6, 6, 6, 0, 0, 6, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0], [6, 0, 0, 0, 6, 0, 6, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1], [6, 6, 0, 6, 0, 6, 6, 6, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0]], "output": [[1, 8], [6, 1]]}, {"input": [[4, 4, 4, 4, 4, 0, 0, 8, 0, 8, 8, 8, 0, 0, 3, 3, 3, 0, 0, 3, 3, 3], [4, 4, 4, 0, 0, 4, 0, 8, 8, 8, 8, 8, 0, 0, 3, 3, 3, 3, 0, 3, 3, 0], [4, 4, 4, 4, 0, 0, 0, 8, 8, 0, 0, 8, 0, 0, 3, 3, 3, 0, 3, 0, 3, 3], [4, 4, 0, 0, 4, 4, 0, 8, 8, 8, 8, 8, 8, 0, 3, 3, 3, 3, 0, 3, 3, 3], [4, 4, 4, 4, 4, 4, 0, 0, 8, 8, 8, 8, 8, 0, 3, 0, 3, 0, 3, 0, 3, 0], [0, 0, 4, 4, 4, 4, 0, 8, 0, 8, 0, 8, 0, 0, 3, 0, 3, 3, 3, 3, 3, 3], [4, 4, 0, 4, 4, 0, 0, 8, 8, 8, 8, 0, 8, 0, 3, 0, 0, 3, 3, 3, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 2, 0, 2, 2, 2, 2, 0, 8, 0, 8, 0, 0, 8, 8, 8], [1, 0, 1, 1, 0, 1, 0, 2, 0, 2, 2, 2, 0, 0, 8, 8, 8, 0, 0, 8, 8, 8], [1, 1, 1, 0, 1, 0, 0, 2, 0, 2, 2, 2, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 0, 1, 0, 1, 0, 2, 2, 2, 2, 0, 2, 0, 0, 0, 8, 8, 8, 0, 8, 8], [1, 1, 1, 0, 1, 0, 0, 2, 2, 0, 2, 2, 0, 0, 0, 8, 0, 8, 8, 8, 8, 0], [1, 1, 1, 1, 1, 1, 0, 0, 2, 2, 2, 0, 2, 0, 8, 8, 0, 0, 8, 0, 8, 8], [1, 1, 1, 0, 0, 0, 0, 2, 0, 2, 2, 2, 2, 0, 8, 8, 0, 0, 0, 8, 8, 8], [1, 0, 0, 1, 0, 1, 0, 2, 2, 0, 2, 2, 0, 0, 8, 0, 8, 8, 0, 0, 0, 8], [1, 1, 1, 1, 0, 1, 0, 0, 2, 2, 2, 0, 2, 0, 0, 8, 8, 0, 0, 0, 8, 0], [1, 1, 0, 1, 1, 1, 0, 2, 2, 2, 0, 2, 0, 0, 8, 0, 8, 8, 0, 0, 8, 8]], "output": [[4, 8, 3], [1, 2, 8]]}, {"input": [[2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 7, 0, 0, 7, 0, 0], [2, 2, 0, 0, 2, 0, 2, 0, 7, 0, 7, 0, 7, 7, 7, 7, 0], [2, 2, 2, 2, 0, 2, 2, 0, 0, 7, 7, 0, 0, 7, 7, 0, 7], [2, 0, 2, 2, 0, 2, 2, 0, 0, 0, 7, 7, 7, 7, 7, 7, 0], [2, 2, 2, 0, 2, 2, 2, 0, 0, 7, 0, 7, 7, 7, 0, 0, 0], [2, 0, 2, 0, 2, 2, 2, 0, 7, 7, 0, 7, 7, 0, 0, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0, 0, 8, 0, 8, 8, 8, 8, 8, 8], [4, 0, 4, 4, 0, 4, 0, 0, 8, 0, 8, 8, 8, 8, 8, 8, 8], [4, 0, 0, 4, 0, 4, 4, 0, 0, 8, 0, 8, 8, 0, 8, 0, 8], [4, 4, 0, 0, 0, 0, 4, 0, 8, 8, 0, 8, 8, 8, 8, 8, 8], [4, 4, 4, 4, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0], [4, 4, 4, 4, 0, 4, 4, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8], [4, 4, 4, 4, 4, 4, 0, 0, 8, 8, 8, 0, 0, 8, 8, 8, 0], [0, 4, 4, 4, 0, 4, 4, 0, 8, 8, 0, 8, 8, 8, 8, 0, 8], [0, 0, 0, 0, 4, 4, 4, 0, 0, 8, 0, 0, 8, 0, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 6, 6, 0, 6, 6, 0, 6, 6, 6], [0, 1, 1, 1, 1, 1, 0, 0, 6, 6, 6, 0, 6, 6, 6, 6, 0], [1, 1, 1, 1, 1, 0, 1, 0, 6, 6, 6, 6, 0, 6, 6, 6, 6], [1, 0, 0, 0, 1, 1, 1, 0, 6, 6, 6, 0, 6, 6, 6, 6, 6], [1, 0, 1, 1, 1, 0, 0, 0, 6, 6, 6, 6, 6, 0, 0, 6, 6], [1, 1, 1, 1, 1, 1, 1, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6]], "output": [[2, 7], [4, 8], [1, 6]]}], "test": [{"input": [[3, 3, 3, 0, 3, 3, 3, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4], [3, 3, 3, 3, 3, 3, 3, 0, 2, 2, 0, 2, 2, 2, 2, 0, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 3, 0, 0, 3, 3, 0, 0, 2, 2, 0, 0, 2, 2, 2, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [3, 0, 3, 3, 3, 3, 3, 0, 2, 0, 2, 2, 2, 2, 2, 0, 4, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 8, 0], [1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 8, 8, 8, 8, 8, 8, 0, 8, 0, 8, 8, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 8, 8, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8], [1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 8, 8, 8, 0, 8, 8, 8, 8, 8, 8, 0, 8], [0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 8, 8, 8, 0, 8, 8, 0, 8, 8, 8], [1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 8, 8, 8, 8, 8, 8, 0, 8, 0, 8, 8, 0], [1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 8, 8, 8, 8, 8, 0, 0, 0, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 8, 8, 8, 8, 0, 8, 8, 8, 8, 8, 0, 8], [1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 8, 0], [1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 8, 0, 8, 0, 8, 8, 8, 8, 8, 8, 8, 8], [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 8, 8, 8, 8, 8, 8, 0, 8, 0, 8, 8, 8], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 8, 0, 8, 8, 8, 8, 8, 8, 8, 8, 0, 8], [0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 8, 0, 8, 8, 8, 8, 8, 0, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [7, 7, 0, 7, 7, 0, 7, 0, 3, 3, 0, 0, 3, 3, 3, 0, 2, 0, 2, 2, 2, 2, 0, 2, 2, 0, 2, 2], [7, 7, 7, 0, 7, 7, 7, 0, 0, 3, 3, 0, 3, 0, 0, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0], [7, 7, 7, 7, 7, 7, 7, 0, 3, 3, 3, 3, 3, 3, 3, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]], "output": [[3, 2, 4], [1, 1, 8], [7, 3, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef fill_subgrid_colors(sub_grids: List[np.ndarray], output_grid: np.ndarray) -> np.ndarray:\n    for i, sub_grid in enumerate(sub_grids):\n        unique, counts = np.unique(sub_grid, return_counts=True)\n        color_counts = dict(zip(unique, counts))\n        if black in color_counts:\n            del color_counts[black]\n        if color_counts:\n            max_color = max(color_counts, key=color_counts.get)\n            output_grid[i // output_grid.shape[1], i % output_grid.shape[1]] = max_color\n    return output_grid\n\ndef create_output_grid(rows: List[int], columns: List[int]) -> np.ndarray:\n    return np.zeros((len(rows) - 1, len(columns) - 1), dtype=int)\n\ndef divide_subgrids(rows: List[int], columns: List[int], input_grid: np.ndarray) -> List[np.ndarray]:\n    sub_grids = []\n    for i in range(len(rows) - 1):\n        for j in range(len(columns) - 1):\n            sub_grid = input_grid[rows[i]:rows[i + 1], columns[j]:columns[j + 1]]\n            sub_grids.append(sub_grid)\n    return sub_grids\n\ndef add_border(rows: List[int], columns: List[int], input_grid: np.ndarray) -> Tuple[List[int], List[int]]:\n    max_row, max_col = input_grid.shape\n    rows = [0] + [r + 1 for r in rows] + [max_row]\n    columns = [0] + [c + 1 for c in columns] + [max_col]\n    return (rows, columns)\n\ndef find_all_black_rows_and_columns(input_grid: np.ndarray) -> Tuple[List[int], List[int]]:\n    rows, columns = (np.where(np.all(input_grid == black, axis=1)), np.where(np.all(input_grid == black, axis=0)))\n    return (rows[0].tolist(), columns[0].tolist())\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    rows, colomns = find_all_black_rows_and_columns(input_grid)\n    rows, colomns = add_border(rows, colomns, input_grid)\n    sub_grids = divide_subgrids(rows, colomns, input_grid)\n    output_grid = create_output_grid(rows, colomns)\n    output_grid = fill_subgrid_colors(sub_grids, output_grid)\n    return output_grid"},
{"name": "beb8660c.json", "data": {"train": [{"input": [[0, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0], [1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 0, 0], [0, 0, 0, 4, 4, 4, 4], [0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8]], "output": [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 2, 2], [0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 4, 4, 4, 4], [0, 0, 6, 6, 6, 6, 6], [0, 5, 5, 5, 5, 5, 5], [8, 8, 8, 8, 8, 8, 8]]}, {"input": [[0, 0, 0, 1], [0, 0, 0, 0], [2, 2, 2, 0], [0, 0, 0, 0], [0, 3, 3, 0], [0, 0, 0, 0], [8, 8, 8, 8]], "output": [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 3, 3], [0, 2, 2, 2], [8, 8, 8, 8]]}, {"input": [[2, 2, 0], [0, 4, 0], [8, 8, 8]], "output": [[0, 0, 4], [0, 2, 2], [8, 8, 8]]}], "test": [{"input": [[6, 6, 6, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0], [0, 0, 3, 3, 3, 3, 3, 3], [0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8]], "output": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 9], [0, 0, 0, 0, 0, 0, 7, 7], [0, 0, 0, 0, 0, 6, 6, 6], [0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 4, 4, 4, 4, 4], [0, 0, 3, 3, 3, 3, 3, 3], [0, 2, 2, 2, 2, 2, 2, 2], [8, 8, 8, 8, 8, 8, 8, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef put_pixels_right_to_left_at_row(color: int, row: int, number: int, output_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Puts the given number of pixels of the given color from right to left at the given row in the output grid.\n\n    Args:\n    color: An integer representing the color of the pixels to be put.\n    row: An integer representing the row at which the pixels are to be put.\n    number: An integer representing the number of pixels to be put.\n    output_grid: A numpy array representing the output grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    for i in range(number):\n        output_grid[row][output_grid.shape[1] - 1 - i] = color\n    return output_grid\n\ndef count_non_black_pixels(input_grid: np.ndarray) -> List[int]:\n    \"\"\"\n    Counts the number of non-black pixels of each color in the input grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A list of integers representing the count of non-black pixels of each color.\n    \"\"\"\n    color_counts = [0] * 10\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black:\n                color_counts[input_grid[i][j]] += 1\n    sorted_color = sorted(range(len(color_counts)), key=lambda k: color_counts[k], reverse=True)\n    return sorted_color\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    sorted_color = count_non_black_pixels(input_grid)\n    output_grid = np.zeros_like(input_grid)\n    for i in range(len(sorted_color)):\n        color = sorted_color[i]\n        row = output_grid.shape[0] - 1 - i\n        number = output_grid.shape[1] - i\n        output_grid = put_pixels_right_to_left_at_row(color, row, number, output_grid)\n    return output_grid"},
{"name": "a2fd1cf0.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 2, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_pixels_between_red_and_green(red: Tuple[int, int], green: Tuple[int, int], f: Tuple[int, int], input_grid: np.ndarray) -> np.ndarray:\n    input_grid[f] = teal\n    if red[1] < f[1]:\n        input_grid[red[0], red[1] + 1:f[1]] = teal\n    else:\n        input_grid[red[0], f[1] + 1:red[1]] = teal\n    if green[0] < f[0]:\n        input_grid[green[0] + 1:f[0], green[1]] = teal\n    else:\n        input_grid[f[0] + 1:green[0], green[1]] = teal\n    return input_grid\n\ndef find_pixel_same_row_as_red_and_same_column_as_green(red: Tuple[int, int], green: Tuple[int, int]) -> Tuple[int, int]:\n    return (red[0], green[1])\n\ndef find_red_green_pixels(input_grid: np.ndarray) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    red_pixels = np.where(input_grid == red)\n    green_pixels = np.where(input_grid == green)\n    return ((red_pixels[0][0], red_pixels[1][0]), (green_pixels[0][0], green_pixels[1][0]))\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    r, g = find_red_green_pixels(input_grid)\n    f = find_pixel_same_row_as_red_and_same_column_as_green(r, g)\n    out = color_pixels_between_red_and_green(r, g, f, input_grid)\n    return out"},
{"name": "06df4c85.json", "data": {"train": [{"input": [[0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 2, 2, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 2, 2, 8, 0, 0], [0, 0, 8, 2, 2, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 2, 2, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 0, 0, 8, 0, 0, 8, 1, 1, 8, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 8, 1, 1, 8, 0, 0, 8, 0, 0, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 2, 2, 8, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 2, 2, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 3, 3, 8, 0, 0, 8, 3, 3, 8, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 8, 3, 3, 8, 0, 0, 8, 3, 3, 8, 0, 0, 8, 0, 0, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0]], "output": [[0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 2, 2, 8, 2, 2, 8, 2, 2, 8, 2, 2, 8, 2, 2, 8, 0, 0], [0, 0, 8, 2, 2, 8, 2, 2, 8, 2, 2, 8, 2, 2, 8, 2, 2, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 0, 0, 8, 0, 0, 8, 1, 1, 8, 0, 0, 8, 2, 2, 8, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 8, 1, 1, 8, 0, 0, 8, 2, 2, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 2, 2, 8, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 2, 2, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 8, 3, 3, 8, 3, 3, 8, 3, 3, 8, 0, 0, 8, 0, 0, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0], [0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0]]}, {"input": [[0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 2, 2, 1, 0, 0, 1, 0, 0, 1, 4, 4, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 2, 2, 1, 0, 0, 1, 0, 0, 1, 4, 4, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 9, 9, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 9, 9], [0, 0, 1, 0, 0, 1, 0, 0, 1, 9, 9, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 9, 9], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 2, 2, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 2, 2, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0]], "output": [[0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 2, 2, 1, 0, 0, 1, 0, 0, 1, 4, 4, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 2, 2, 1, 0, 0, 1, 0, 0, 1, 4, 4, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 2, 2, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 2, 2, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 2, 2, 1, 0, 0, 1, 9, 9, 1, 9, 9, 1, 9, 9, 1, 9, 9, 1, 9, 9], [0, 0, 1, 2, 2, 1, 0, 0, 1, 9, 9, 1, 9, 9, 1, 9, 9, 1, 9, 9, 1, 9, 9], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 2, 2, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 0, 0], [0, 0, 1, 2, 2, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 2, 2, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 0, 0], [0, 0, 1, 2, 2, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 8, 8, 1, 8, 8, 1, 8, 8, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 8, 8, 1, 8, 8, 1, 8, 8, 1, 8, 8, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0]]}, {"input": [[0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0], [0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0], [0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0]], "output": [[0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0], [0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 3, 3, 4, 0, 0, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 0, 0], [0, 0, 4, 3, 3, 4, 0, 0, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 3, 3, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 0, 0, 4, 0, 0], [0, 0, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 3, 3, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0]]}], "test": [{"input": [[0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 3, 3, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 3, 3, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0]], "output": [[0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 3, 3, 4, 0, 0], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 3, 3, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 8, 8, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 2, 2, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0, 4, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_pixels_between_same_color_pixels(grid: np.ndarray, pixels: List[Tuple[int, int]], color: int) -> np.ndarray:\n    \"\"\"\n    Given a grid, a list of pixels and a color, this function turns all black pixels between any two pixels in the list\n    that are in the same row or column into the given color.\n    \n    Args:\n    1. grid: np.ndarray - A numpy array representing the input grid.\n    2. pixels: List[Tuple[int, int]] - A list of tuples representing the indices of pixels.\n    3. color: int - An integer representing the color to turn the pixels into.\n    \n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    for i in range(len(pixels)):\n        for j in range(i + 1, len(pixels)):\n            if pixels[i][0] == pixels[j][0]:\n                for k in range(min(pixels[i][1], pixels[j][1]) + 1, max(pixels[i][1], pixels[j][1])):\n                    if grid[pixels[i][0]][k] == black:\n                        grid[pixels[i][0]][k] = color\n            elif pixels[i][1] == pixels[j][1]:\n                for k in range(min(pixels[i][0], pixels[j][0]) + 1, max(pixels[i][0], pixels[j][0])):\n                    if grid[k][pixels[i][1]] == black:\n                        grid[k][pixels[i][1]] = color\n    return grid\n\ndef find_pixels_in_color(grid: np.ndarray, color: int) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given a grid and a color, this function returns a list of tuples representing the indices of all pixels in the grid\n    that have the given color.\n    \n    Args:\n    1. grid: np.ndarray - A numpy array representing the input grid.\n    2. color: int - An integer representing the color to search for.\n    \n    Returns:\n    A list of tuples representing the indices of all pixels in the grid that have the given color.\n    \"\"\"\n    pixels = []\n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if grid[i][j] == color:\n                pixels.append((i, j))\n    return pixels\n\ndef color_between_same_color_pixels(grid: np.ndarray, line_color: int) -> np.ndarray:\n    for color in range(10):\n        if color != black and color != line_color:\n            p = find_pixels_in_color(grid, color)\n            grid = color_pixels_between_same_color_pixels(grid, p, color)\n    return grid\n\ndef find_color(grid: np.ndarray) -> int:\n    \"\"\"\n    Given a grid, this function finds the color of the line in the grid.\n    \n    Args:\n    1. grid: np.ndarray - A numpy array representing the input grid.\n    \n    Returns:\n    An integer representing the color of the line.\n    \"\"\"\n    for color in range(10):\n        if color != black:\n            for i in range(grid.shape[0]):\n                row = grid[i, :]\n                col = grid[:, i]\n                if np.all(row == color) or np.all(col == color):\n                    return color\n    return black\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    line = find_color(input_grid)\n    out = color_between_same_color_pixels(input_grid, line)\n    return out"},
{"name": "d89b689b.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 9]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 7, 0, 0, 0, 0], [0, 0, 0, 0, 4, 9, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 9, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 9, 0, 0, 0, 0], [0, 0, 0, 0, 2, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 1, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 6], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 4, 0, 0, 0], [0, 0, 0, 0, 0, 3, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 7, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 4, 0, 0, 0, 0], [0, 0, 0, 0, 6, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef make_non_black_teal_black(input_grid: np.ndarray, non_black_teal: List[Tuple[int, int]]) -> np.ndarray:\n    for i, j in non_black_teal:\n        if input_grid[i][j] != black and input_grid[i][j] != teal:\n            input_grid[i][j] = black\n    return input_grid\n\ndef make_nearest_teal_same_color(input_grid: np.ndarray, color_point: Tuple[int, int]) -> np.ndarray:\n    i, j = color_point\n    if input_grid[i][j] == teal:\n        return input_grid\n    min_dist = float('inf')\n    nearest_teal = None\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x][y] == teal:\n                dist = (x - i) ** 2 + (y - j) ** 2\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest_teal = (x, y)\n    if nearest_teal is not None:\n        input_grid[nearest_teal[0]][nearest_teal[1]] = input_grid[i][j]\n    return input_grid\n\ndef find_non_black_teal(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    non_black_teal = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black and input_grid[i][j] != teal:\n                non_black_teal.append((i, j))\n    return non_black_teal\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    non_black_teal = find_non_black_teal(input_grid)\n    for color_point in non_black_teal:\n        input_grid = make_nearest_teal_same_color(input_grid, color_point)\n    input_grid = make_non_black_teal_black(input_grid, non_black_teal)\n    return input_grid"},
{"name": "ce22a75a.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1, 1]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef turn_grey_pixels_blue(input_grid: np.ndarray, grey_pixels: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"\n    Given an input grid and a list of tuples containing the indices of all the grey pixels in the grid,\n    turns each grey pixel and its 8 neighbors in the 3x3 area into blue.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    grey_pixels: A list of tuples containing the indices of all the grey pixels in the grid.\n    \n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    for i, j in grey_pixels:\n        for x in range(max(0, i - 1), min(input_grid.shape[0], i + 2)):\n            for y in range(max(0, j - 1), min(input_grid.shape[1], j + 2)):\n                input_grid[x][y] = blue\n    return input_grid\n\ndef find_grey_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given an input grid, returns a list of tuples containing the indices of all the grey pixels in the grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of tuples containing the indices of all the grey pixels in the grid.\n    \"\"\"\n    grey_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == grey:\n                grey_pixels.append((i, j))\n    return grey_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    p = find_grey_pixels(input_grid)\n    out = turn_grey_pixels_blue(input_grid, p)\n    return out"},
{"name": "a61f2674.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 5, 0, 0], [5, 0, 5, 0, 0, 0, 5, 0, 0], [5, 0, 5, 0, 0, 0, 5, 0, 0], [5, 0, 5, 0, 5, 0, 5, 0, 0], [5, 0, 5, 0, 5, 0, 5, 0, 5], [5, 0, 5, 0, 5, 0, 5, 0, 5], [5, 0, 5, 0, 5, 0, 5, 0, 5]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 2], [0, 0, 1, 0, 0, 0, 0, 0, 2], [0, 0, 1, 0, 0, 0, 0, 0, 2]]}, {"input": [[0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0], [5, 0, 0, 0, 5, 0, 0, 0, 0], [5, 0, 0, 0, 5, 0, 5, 0, 0], [5, 0, 0, 0, 5, 0, 5, 0, 0], [5, 0, 0, 0, 5, 0, 5, 0, 0], [5, 0, 0, 0, 5, 0, 5, 0, 0], [5, 0, 5, 0, 5, 0, 5, 0, 0], [5, 0, 5, 0, 5, 0, 5, 0, 0]], "output": [[0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 2, 0, 1, 0, 0, 0, 0], [0, 0, 2, 0, 1, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0], [0, 0, 0, 5, 0, 5, 0, 5, 0], [0, 0, 0, 5, 0, 5, 0, 5, 0], [0, 0, 0, 5, 0, 5, 0, 5, 0], [0, 0, 0, 5, 0, 5, 0, 5, 0], [0, 5, 0, 5, 0, 5, 0, 5, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 2, 0, 0, 0, 0, 0, 1, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_grey_with_black(input_grid: np.ndarray) -> np.ndarray:\n    input_grid[input_grid == grey] = black\n    return input_grid\n\ndef replace_grey_with_red_in_column(input_grid: np.ndarray, column: int) -> np.ndarray:\n    input_grid[:, column][input_grid[:, column] == grey] = red\n    return input_grid\n\ndef replace_grey_with_blue_in_column(input_grid: np.ndarray, column: int) -> np.ndarray:\n    input_grid[:, column][input_grid[:, column] == grey] = blue\n    return input_grid\n\ndef get_column_with_lowest_nonzero_gray_pixels(input_grid: np.ndarray) -> int:\n    gray_pixels_per_column = np.sum(input_grid == grey, axis=0)\n    nonzero_gray_pixels_per_column = np.where(gray_pixels_per_column > 0, gray_pixels_per_column, np.inf)\n    return np.argmin(nonzero_gray_pixels_per_column)\n\ndef get_column_with_highest_gray_pixels(input_grid: np.ndarray) -> int:\n    gray_pixels_per_column = np.sum(input_grid == grey, axis=0)\n    return np.argmax(gray_pixels_per_column)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    a = get_column_with_highest_gray_pixels(input_grid)\n    b = get_column_with_lowest_nonzero_gray_pixels(input_grid)\n    out = replace_grey_with_blue_in_column(input_grid, a)\n    out = replace_grey_with_red_in_column(out, b)\n    out = replace_grey_with_black(out)\n    return out"},
{"name": "29c11459.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 5, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 5, 7, 7, 7, 7, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 4, 5, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 5, 9, 9, 9, 9, 9]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_non_black_color_with_gray(inp: np.ndarray) -> np.ndarray:\n    out = inp.copy()\n    non_black_mask = out[:, 5] != black\n    out[non_black_mask, 5] = grey\n    return out\n\ndef replace_last_five_columns_with_last_column(inp: np.ndarray) -> np.ndarray:\n    out = inp.copy()\n    out[:, -5:] = out[:, -1:]\n    return out\n\ndef replace_first_six_columns_with_first_column(inp: np.ndarray) -> np.ndarray:\n    out = inp.copy()\n    out[:, :6] = out[:, :1]\n    return out\n\ndef replace_middle_color_with_gray(inp: np.ndarray) -> np.ndarray:\n    out = replace_non_black_color_with_gray(inp)\n    return out\n\ndef copy_first_column_to_next_four_columns(inp: np.ndarray) -> np.ndarray:\n    out = replace_last_five_columns_with_last_column(inp)\n    return out\n\ndef copy_first_column(inp: np.ndarray) -> np.ndarray:\n    out = replace_first_six_columns_with_first_column(inp)\n    return out\n\ndef transform_grid(inp: np.ndarray) -> np.ndarray:\n    out = copy_first_column(inp)\n    out = copy_first_column_to_next_four_columns(out)\n    out = replace_middle_color_with_gray(out)\n    return out"},
{"name": "44d8ac46.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0, 0, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 0, 0, 5, 0, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 2, 2, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 2, 2, 5, 0, 0, 5, 5, 5, 5, 0], [0, 5, 5, 5, 5, 0, 0, 5, 0, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 5, 2, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5], [0, 5, 5, 5, 5, 0, 5, 0, 0, 0, 0, 5], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5], [5, 5, 5, 5, 5, 0, 5, 0, 0, 0, 0, 5], [5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5], [5, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0], [5, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 2, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5], [0, 5, 5, 5, 5, 0, 5, 2, 2, 2, 2, 5], [0, 0, 0, 0, 0, 0, 5, 2, 2, 2, 2, 5], [0, 0, 0, 0, 0, 0, 5, 2, 2, 2, 2, 5], [5, 5, 5, 5, 5, 0, 5, 2, 2, 2, 2, 5], [5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 5, 5], [5, 2, 2, 5, 5, 0, 0, 0, 0, 0, 0, 0], [5, 2, 2, 5, 5, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 5, 5, 5, 5, 0], [0, 5, 0, 0, 0, 5, 0, 5, 0, 0, 5, 0], [0, 5, 0, 0, 0, 5, 0, 5, 0, 0, 5, 0], [0, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 5, 5, 5, 5, 0], [0, 5, 0, 0, 0, 5, 0, 5, 2, 2, 5, 0], [0, 5, 0, 0, 0, 5, 0, 5, 2, 2, 5, 0], [0, 5, 5, 5, 5, 5, 0, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 0, 0, 5, 5, 5, 5, 0], [5, 0, 0, 0, 5, 0, 0, 5, 5, 0, 5, 0], [5, 0, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0], [5, 0, 0, 0, 5, 0, 0, 5, 0, 0, 5, 0], [5, 5, 5, 5, 5, 0, 0, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 0, 0, 5, 5, 5, 5, 0], [5, 2, 2, 2, 5, 0, 0, 5, 5, 0, 5, 0], [5, 2, 2, 2, 5, 0, 0, 5, 0, 0, 5, 0], [5, 2, 2, 2, 5, 0, 0, 5, 0, 0, 5, 0], [5, 5, 5, 5, 5, 0, 0, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_surrounded_squares_red(grid: np.ndarray, square: Tuple[int, int, int]) -> None:\n    i, j, size = square\n    if i > 0 and j > 0 and (i + size < grid.shape[0]) and (j + size < grid.shape[1]):\n        if np.all(grid[i - 1:i + size + 1, j - 1] == 5) and np.all(grid[i - 1:i + size + 1, j + size] == 5) and np.all(grid[i - 1, j - 1:j + size + 1] == 5) and np.all(grid[i + size, j - 1:j + size + 1] == 5):\n            grid[i:i + size, j:j + size] = red\n\ndef find_black_squares(grid: np.ndarray) -> List[Tuple[int, int, int]]:\n    black_squares = []\n    for size in range(1, min(grid.shape) + 1):\n        for i in range(grid.shape[0] - size + 1):\n            for j in range(grid.shape[1] - size + 1):\n                if np.all(grid[i:i + size, j:j + size] == black):\n                    black_squares.append((i, j, size))\n    return black_squares\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    black_squares = find_black_squares(input_grid)\n    for square in black_squares:\n        color_surrounded_squares_red(input_grid, square)\n    return input_grid"},
{"name": "9565186b.json", "data": {"train": [{"input": [[2, 2, 2], [2, 1, 8], [2, 8, 8]], "output": [[2, 2, 2], [2, 5, 5], [2, 5, 5]]}, {"input": [[1, 1, 1], [8, 1, 3], [8, 2, 2]], "output": [[1, 1, 1], [5, 1, 5], [5, 5, 5]]}, {"input": [[2, 2, 2], [8, 8, 2], [2, 2, 2]], "output": [[2, 2, 2], [5, 5, 2], [2, 2, 2]]}, {"input": [[3, 3, 8], [4, 4, 4], [8, 1, 1]], "output": [[5, 5, 5], [4, 4, 4], [5, 5, 5]]}], "test": [{"input": [[1, 3, 2], [3, 3, 2], [1, 3, 2]], "output": [[5, 3, 5], [3, 3, 5], [5, 3, 5]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef turn_other_colors_to_grey(color: int, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given an input grid and a color, this function turns all pixels in colors other than the given color to grey.\n\n    Args:\n    color: An integer representing the color to keep.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the output grid with all pixels in colors other than the given color turned to grey.\n    \"\"\"\n    output_grid = np.copy(input_grid)\n    for i in range(output_grid.shape[0]):\n        for j in range(output_grid.shape[1]):\n            if output_grid[i][j] != color and output_grid[i][j] != black:\n                output_grid[i][j] = grey\n    return output_grid\n\ndef find_max_color(color_counts: Dict[int, int]) -> int:\n    \"\"\"\n    Given a dictionary of color counts, this function returns the color with the maximum number of pixels.\n\n    Args:\n    color_counts: A dictionary where the keys are the colors of non-black patterns and the values are the number of pixels in the color.\n\n    Returns:\n    The color with the maximum number of pixels.\n    \"\"\"\n    max_color = None\n    max_count = 0\n    for color, count in color_counts.items():\n        if count > max_count:\n            max_color = color\n            max_count = count\n    return max_color\n\ndef record_colors(input_grid: np.ndarray) -> Dict[int, int]:\n    \"\"\"\n    Given an input grid, this function records the colors of all non-black patterns on the grid and the number of pixels\n    in the color.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A dictionary where the keys are the colors of non-black patterns and the values are the number of pixels in the color.\n    \"\"\"\n    color_counts = {}\n    for row in input_grid:\n        for pixel in row:\n            if pixel != black:\n                if pixel in color_counts:\n                    color_counts[pixel] += 1\n                else:\n                    color_counts[pixel] = 1\n    return color_counts\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    Record = record_colors(input_grid)\n    p = find_max_color(Record)\n    out = turn_other_colors_to_grey(p, input_grid)\n    return out"},
{"name": "f1cefba8.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 2, 8, 8, 8, 8, 0], [0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 8, 8, 0], [0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 8, 8, 0], [0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 8, 0], [0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 8, 8, 0], [0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 8, 8, 0], [0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 8, 8, 0], [0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 8, 8, 0], [0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 8, 8, 0], [0, 8, 8, 2, 2, 2, 2, 2, 2, 2, 8, 8, 0], [0, 8, 8, 8, 2, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 2, 8, 2, 2, 8, 2, 2, 8, 8, 0], [0, 8, 8, 2, 8, 2, 2, 8, 2, 2, 8, 8, 0], [2, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2], [0, 8, 8, 2, 8, 2, 2, 8, 2, 2, 8, 8, 0], [0, 8, 8, 2, 8, 2, 2, 8, 2, 2, 8, 8, 0], [0, 8, 8, 2, 8, 2, 2, 8, 2, 2, 8, 8, 0], [0, 8, 8, 2, 8, 2, 2, 8, 2, 2, 8, 8, 0], [0, 8, 8, 2, 8, 2, 2, 8, 2, 2, 8, 8, 0], [0, 8, 8, 2, 8, 2, 2, 8, 2, 2, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 0, 0, 0], [0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 0, 0, 0], [0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 0, 0, 0], [0, 0, 1, 1, 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 4, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 4, 4, 1, 4, 1, 4, 4, 4, 1, 1, 0, 0, 0], [4, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4], [0, 0, 1, 1, 4, 4, 1, 4, 1, 4, 4, 4, 1, 1, 0, 0, 0], [0, 0, 1, 1, 4, 4, 1, 4, 1, 4, 4, 4, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 2, 2, 0, 0], [3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 3, 3, 3, 3, 3, 2, 3, 3, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 8, 1, 1, 1, 8, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 0, 0, 0], [0, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 1, 1, 0, 0, 0], [8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 8, 8, 8], [0, 1, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 8, 8, 8, 1, 8, 8, 8, 1, 8, 8, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_row(input_grid: np.ndarray, in_color: int, out_color: int, i: int) -> None:\n    for j in range(0, input_grid.shape[1]):\n        if input_grid[i][j] == in_color:\n            input_grid[i][j] = out_color\n        elif input_grid[i][j] == black:\n            input_grid[i][j] = in_color\n\ndef color_column(input_grid: np.ndarray, in_color: int, out_color: int, j: int) -> None:\n    for i in range(0, input_grid.shape[0]):\n        if input_grid[i][j] == in_color:\n            input_grid[i][j] = out_color\n        elif input_grid[i][j] == black:\n            input_grid[i][j] = in_color\n\ndef find_in_color_points(input_grid: np.ndarray, in_color: int, out_color: int) -> List[Tuple[int, int]]:\n    in_color_points = []\n    for i in range(1, input_grid.shape[0] - 1):\n        for j in range(1, input_grid.shape[1] - 1):\n            if input_grid[i][j] == in_color:\n                neighbors = (input_grid[i - 1][j], input_grid[i + 1][j], input_grid[i][j - 1], input_grid[i][j + 1])\n                if neighbors.count(out_color) == 3 and neighbors.count(in_color) == 1:\n                    in_color_points.append((i, j))\n    return in_color_points\n\ndef find_out_in_colors(input_grid: np.ndarray, color1: int, color2: int) -> Tuple[int, int]:\n    if np.min(np.where(input_grid == color1)[1]) < np.min(np.where(input_grid == color2)[1]):\n        return (color1, color2)\n    else:\n        return (color2, color1)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    color1 = np.unique(input_grid)[1]\n    color2 = np.unique(input_grid)[2]\n    out_color, in_color = find_out_in_colors(input_grid, color1, color2)\n    points = find_in_color_points(input_grid, in_color, out_color)\n    for point in points:\n        i, j = point\n        if input_grid[i - 1][j] == in_color or input_grid[i + 1][j] == in_color:\n            color_column(input_grid, in_color, out_color, j)\n        if input_grid[i][j + 1] == in_color or input_grid[i][j - 1] == in_color:\n            color_row(input_grid, in_color, out_color, i)\n    return input_grid"},
{"name": "623ea044.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 8, 0], [8, 0, 0, 0, 8, 0, 0], [0, 8, 0, 8, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0], [0, 8, 0, 8, 0, 0, 0], [8, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 0, 8, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 6], [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 6, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 6], [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_diagonal_pixels(input_grid: np.ndarray, c: int) -> np.ndarray:\n    not_black_indices = np.where(input_grid != black)\n    not_black_pixel = (not_black_indices[0][0], not_black_indices[1][0])\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if i + j == not_black_pixel[0] + not_black_pixel[1] or i - j == not_black_pixel[0] - not_black_pixel[1]:\n                input_grid[i][j] = c\n    return input_grid\n\ndef get_not_black_color(input_grid: np.ndarray) -> int:\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black:\n                return input_grid[i][j]\n    return black\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    c = get_not_black_color(input_grid)\n    out = color_diagonal_pixels(input_grid, c)\n    return out"},
{"name": "fafffa47.json", "data": {"train": [{"input": [[0, 9, 9], [0, 9, 9], [9, 9, 9], [0, 1, 0], [0, 0, 1], [1, 1, 1]], "output": [[2, 0, 0], [2, 0, 0], [0, 0, 0]]}, {"input": [[9, 0, 9], [0, 9, 9], [0, 0, 9], [1, 0, 1], [1, 0, 0], [1, 0, 0]], "output": [[0, 2, 0], [0, 0, 0], [0, 2, 0]]}, {"input": [[0, 9, 0], [9, 0, 9], [9, 0, 0], [0, 0, 0], [0, 0, 1], [1, 0, 0]], "output": [[2, 0, 2], [0, 2, 0], [0, 2, 2]]}, {"input": [[0, 0, 9], [9, 9, 9], [0, 9, 0], [1, 0, 0], [0, 1, 1], [0, 0, 1]], "output": [[0, 2, 0], [0, 0, 0], [2, 0, 0]]}, {"input": [[0, 9, 0], [0, 9, 9], [0, 9, 9], [0, 0, 0], [1, 1, 1], [1, 0, 1]], "output": [[2, 0, 2], [0, 0, 0], [0, 0, 0]]}], "test": [{"input": [[9, 0, 9], [0, 0, 9], [9, 0, 9], [0, 1, 1], [0, 1, 0], [1, 0, 0]], "output": [[0, 0, 0], [2, 0, 0], [0, 2, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_black_pixels_with_red(out: np.ndarray, m1: np.ndarray, m2: np.ndarray) -> np.ndarray:\n    for i in range(3):\n        for j in range(3):\n            if m1[i][j] == black and m2[i][j] == black:\n                out[i][j] = red\n    return out\n\ndef build_black_matrix() -> np.ndarray:\n    return np.full((3, 3), black)\n\ndef divide_into_2_matrices(input_grid: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:\n    m1 = input_grid[:3, :]\n    m2 = input_grid[3:, :]\n    return (m1, m2)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    m1, m2 = divide_into_2_matrices(input_grid)\n    out = build_black_matrix()\n    out = replace_black_pixels_with_red(out, m1, m2)\n    return out"},
{"name": "a48eeaf7.json", "data": {"train": [{"input": [[0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 5, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 5, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 5, 0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 5, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 5, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 5, 0, 0, 0, 0, 0], [0, 0, 2, 2, 5, 0, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef move_grey_pixel_to_nearest_red_pixel(input_grid: np.ndarray, grey_pixels: List[Tuple[int, int]], red_pixels: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"                                                                                                                                                                   \n    Given an input grid, a list of grey pixels and a list of red pixels, this function moves each grey pixel to its nearest red pixel until they touch each other.        \n                                                                                                                                                                          \n    Args:                                                                                                                                                                 \n    - input_grid: a numpy ndarray representing the input grid                                                                                                             \n    - grey_pixels: a list of tuples containing the indices of all grey pixels in the grid.                                                                                \n    - red_pixels: a list of tuples containing the indices of all red pixels in the grid.                                                                                  \n                                                                                                                                                                          \n    Returns:                                                                                                                                                              \n    - A numpy ndarray representing the output grid.                                                                                                                       \n    \"\"\"\n    output_grid = input_grid.copy()\n    for grey_pixel in grey_pixels:\n        min_distance = float('inf')\n        nearest_red_pixel = None\n        for red_pixel in red_pixels:\n            distance = np.sqrt((grey_pixel[0] - red_pixel[0]) ** 2 + (grey_pixel[1] - red_pixel[1]) ** 2)\n            if distance < min_distance:\n                min_distance = distance\n                nearest_red_pixel = red_pixel\n        output_grid[grey_pixel[0]][grey_pixel[1]] = black\n        if nearest_red_pixel[0] == grey_pixel[0]:\n            if grey_pixel[1] < nearest_red_pixel[1]:\n                output_grid[nearest_red_pixel[0]][nearest_red_pixel[1] - 1] = grey\n            else:\n                output_grid[nearest_red_pixel[0]][nearest_red_pixel[1] + 1] = grey\n        elif nearest_red_pixel[1] == grey_pixel[1]:\n            if grey_pixel[0] < nearest_red_pixel[0]:\n                output_grid[nearest_red_pixel[0] - 1][nearest_red_pixel[1]] = grey\n            else:\n                output_grid[nearest_red_pixel[0] + 1][nearest_red_pixel[1]] = grey\n        elif grey_pixel[0] < nearest_red_pixel[0] and grey_pixel[1] < nearest_red_pixel[1]:\n            output_grid[nearest_red_pixel[0] - 1][nearest_red_pixel[1] - 1] = grey\n        elif grey_pixel[0] < nearest_red_pixel[0] and grey_pixel[1] > nearest_red_pixel[1]:\n            output_grid[nearest_red_pixel[0] - 1][nearest_red_pixel[1] + 1] = grey\n        elif grey_pixel[0] > nearest_red_pixel[0] and grey_pixel[1] < nearest_red_pixel[1]:\n            output_grid[nearest_red_pixel[0] + 1][nearest_red_pixel[1] - 1] = grey\n        elif grey_pixel[0] > nearest_red_pixel[0] and grey_pixel[1] > nearest_red_pixel[1]:\n            output_grid[nearest_red_pixel[0] + 1][nearest_red_pixel[1] + 1] = grey\n    return output_grid\n\ndef find_red_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given an input grid, returns a list of tuples representing the indices of all red pixels in the grid.\n    \n    Parameters:\n    input_grid (np.ndarray): A numpy array representing the input grid.\n    \n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing the indices of all red pixels in the grid.\n    \"\"\"\n    red_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                red_pixels.append((i, j))\n    return red_pixels\n\ndef find_grey_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Given an input grid, returns a list of tuples representing the indices of all grey pixels in the grid.\n    \n    Parameters:\n    input_grid (np.ndarray): A numpy array representing the input grid.\n    \n    Returns:\n    List[Tuple[int, int]]: A list of tuples representing the indices of all grey pixels in the grid.\n    \"\"\"\n    grey_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == grey:\n                grey_pixels.append((i, j))\n    return grey_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                   \n    in the input grid, you can see grey pixels and red pixels.                                                                                                            \n    the output grid is the same size as the input grid.                                                                                                                   \n    to make the output, you should move each grey pixel to its nearest red pixels until they touch each other.\n    if the grey pixel and its nearest red pixel are on the same row or column, you should move vertically or horizontally\n    if the grey pixel and its nearest red pixel are on the same diagonal, you should move diagonal                                            \n    \"\"\"\n    output_grid = input_grid.copy()\n    grey_pixels = find_grey_pixels(input_grid)\n    red_pixels = find_red_pixels(input_grid)\n    output_grid = move_grey_pixel_to_nearest_red_pixel(input_grid, grey_pixels, red_pixels)\n    return output_grid"},
{"name": "2013d3e2.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [0, 0, 0, 6, 8, 8, 6, 0, 0, 0], [0, 0, 7, 8, 4, 4, 8, 7, 0, 0], [0, 0, 7, 8, 4, 4, 8, 7, 0, 0], [0, 0, 0, 6, 8, 8, 6, 0, 0, 0], [0, 0, 0, 0, 7, 7, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 7], [0, 6, 8], [7, 8, 4]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 3, 6, 5, 3, 0, 0, 0, 0], [0, 0, 5, 2, 2, 6, 0, 0, 0, 0], [0, 0, 6, 2, 2, 5, 0, 0, 0, 0], [0, 0, 3, 5, 6, 3, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[1, 0, 0], [0, 3, 6], [0, 5, 2]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 4, 4, 8, 4, 0, 0, 0], [0, 0, 8, 8, 3, 3, 4, 0, 0, 0], [0, 0, 0, 4, 3, 3, 8, 8, 0, 0], [0, 0, 0, 4, 8, 4, 4, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0], [0, 4, 4], [8, 8, 3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef cut_three_by_three(inner_grid: np.ndarray) -> np.ndarray:\n    return inner_grid[:3, :3]\n\ndef cut_six_by_six(input_grid: np.ndarray, row: int, col: int) -> np.ndarray:\n    return input_grid[row:row + 6, col:col + 6]\n\ndef find_smallest_col(input_grid: np.ndarray) -> int:\n    for i in range(input_grid.shape[1]):\n        if not np.all(input_grid[:, i] == black):\n            return i\n    return input_grid.shape[1]\n\ndef find_smallest_row(input_grid: np.ndarray) -> int:\n    for i in range(input_grid.shape[0]):\n        if not np.all(input_grid[i] == black):\n            return i\n    return input_grid.shape[0]\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    smallest_row = find_smallest_row(input_grid)\n    smallest_col = find_smallest_col(input_grid)\n    inner_grid = cut_six_by_six(input_grid, smallest_row, smallest_col)\n    output = cut_three_by_three(inner_grid)\n    return output"},
{"name": "6cdd2623.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 2, 0, 5, 2, 0, 5, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0], [5, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 5, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 5, 0, 0, 0, 0, 0, 2, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0], [3, 0, 0, 5, 5, 0, 2, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 5, 0, 5, 0, 0, 0, 2, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 5, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 4, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 8, 0, 4, 0], [0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 5], [4, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 5, 0, 0, 0, 0, 0, 0, 0, 5], [0, 4, 0, 0, 0, 5, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 4, 0], [0, 0, 0, 0, 0, 0, 4, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0], [4, 0, 4, 0, 4, 0, 0, 0, 4, 5, 0, 0, 0, 8, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 7, 8, 0], [7, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 7, 0, 0, 0], [0, 7, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 7, 7, 6], [0, 7, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 8, 0, 8, 0, 0, 0, 7], [0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 7, 0, 0, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 0, 0, 0, 0, 0], [7, 0, 0, 6, 7, 0, 8, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_columns_to_color(input_grid: np.ndarray, color: int, columns: List[int]) -> np.ndarray:\n    \"\"\"\n    Given a 2D numpy array, a color, and a list of columns, changes all the cells in the specified columns to the input color.\n    \n    Parameters:\n    input_grid (np.ndarray): A 2D numpy array representing the input grid.\n    color (int): An integer representing the color to change to.\n    columns (List[int]): A list of integers representing the columns to change.\n    \n    Returns:\n    np.ndarray: A 2D numpy array with the specified columns changed to the input color.\n    \"\"\"\n    for column in columns:\n        input_grid[:, column] = color\n    return input_grid\n\ndef change_rows_to_color(input_grid: np.ndarray, color: int, rows: List[int]) -> np.ndarray:\n    \"\"\"\n    Given a 2D numpy array, a color, and a list of rows, changes all the cells in the specified rows to the input color.\n    \n    Parameters:\n    input_grid (np.ndarray): A 2D numpy array representing the input grid.\n    color (int): An integer representing the color to change to.\n    rows (List[int]): A list of integers representing the rows to change.\n    \n    Returns:\n    np.ndarray: A 2D numpy array with the specified rows changed to the input color.\n    \"\"\"\n    for row in rows:\n        input_grid[row, :] = color\n    return input_grid\n\ndef find_columns_with_color_in_first_row(input_grid: np.ndarray, color: int) -> List[int]:\n    \"\"\"\n    Given a 2D numpy array and a color, returns a list of columns where the color is present in the first row.\n    \n    Parameters:\n    input_grid (np.ndarray): A 2D numpy array representing the input grid.\n    color (int): An integer representing the color to search for.\n    \n    Returns:\n    List[int]: A list of integers representing the columns where the color is present in the first row.\n    \"\"\"\n    columns_with_color = []\n    for i in range(input_grid.shape[1]):\n        if input_grid[0][i] == color:\n            columns_with_color.append(i)\n    return columns_with_color\n\ndef find_rows_with_color_in_first_column(input_grid: np.ndarray, color: int) -> List[int]:\n    \"\"\"\n    Given a 2D numpy array and a color, returns a list of rows where the color is present in the first column.\n    \n    Parameters:\n    input_grid (np.ndarray): A 2D numpy array representing the input grid.\n    color (int): An integer representing the color to search for.\n    \n    Returns:\n    List[int]: A list of integers representing the rows where the color is present in the first column.\n    \"\"\"\n    rows_with_color = []\n    for i in range(input_grid.shape[0]):\n        if input_grid[i][0] == color:\n            rows_with_color.append(i)\n    return rows_with_color\n\ndef find_least_color(input_grid: np.ndarray) -> int:\n    \"\"\"\n    Given a 2D numpy array, returns the least occurring color in the array.\n    \n    Parameters:\n    input_grid (np.ndarray): A 2D numpy array representing the input grid.\n    \n    Returns:\n    int: An integer representing the least occurring color in the array.\n    \"\"\"\n    colors, counts = np.unique(input_grid, return_counts=True)\n    least_color = colors[np.argmin(counts)]\n    return least_color\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    color = find_least_color(input_grid)\n    list1 = find_rows_with_color_in_first_column(input_grid, color)\n    list2 = find_columns_with_color_in_first_row(input_grid, color)\n    row = input_grid.shape[0]\n    column = input_grid.shape[1]\n    output_grid = np.zeros((row, column), dtype=int)\n    output_grid = change_rows_to_color(output_grid, color, list1)\n    output_grid = change_columns_to_color(output_grid, color, list2)\n    return output_grid"},
{"name": "8a004b2b.json", "data": {"train": [{"input": [[0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 3, 3, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[4, 0, 0, 0, 0, 0, 4], [0, 2, 2, 3, 3, 0, 0], [0, 2, 2, 3, 3, 0, 0], [0, 3, 3, 8, 8, 0, 0], [0, 3, 3, 8, 8, 0, 0], [0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 4]]}, {"input": [[0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0], [0, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0], [0, 2, 2, 2, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 3, 3, 3, 1, 1, 1, 0], [0, 0, 0, 0, 3, 3, 3, 1, 1, 1, 0], [0, 0, 0, 0, 3, 3, 3, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]]}], "test": [{"input": [[4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 8, 8, 8, 8, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 4]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef copy_target_grid_to_first_non_black_non_yellow_pixel(ans_grid: np.ndarray, target_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given ans_grid and target_grid, this function finds the first non-black and non-yellow pixel (x, y) in ans_grid and copies target_grid to this position.\n    \"\"\"\n    rows = ans_grid.shape[0]\n    cols = ans_grid.shape[1]\n    for i in range(rows):\n        for j in range(cols):\n            if ans_grid[i][j] != black and ans_grid[i][j] != yellow:\n                ans_grid[i:i + target_grid.shape[0], j:j + target_grid.shape[1]] = target_grid\n                return ans_grid\n    return ans_grid\n\ndef expand_target_grid(target_grid: np.ndarray, side_length: float) -> np.ndarray:\n    \"\"\"\n    Given a target grid and a side length, this function expands the target grid proportionally by the side length times and returns the expanded grid.\n    \"\"\"\n    return np.repeat(np.repeat(target_grid, side_length, axis=0), side_length, axis=1)\n\ndef count_non_black_pixels(ans_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Given an input grid, this function counts the number of unique non-black pixels and their total count and returns them as a tuple (kind, cnt).\n    \"\"\"\n    kind = len(np.unique(ans_grid)) - 1\n    cnt = np.count_nonzero(ans_grid != black)\n    return (kind, cnt)\n\ndef update_min_max_coordinates(grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Given an input grid, this function returns the smallest x, the smallest y, the largest x, and the largest y coordina\n    \"\"\"\n    rows = grid.shape[0]\n    cols = grid.shape[1]\n    minx, miny, maxx, maxy = (rows, cols, -1, -1)\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] != black:\n                minx = min(minx, i)\n                miny = min(miny, j)\n                maxx = max(maxx, i)\n                maxy = max(maxy, j)\n    return (minx, miny, maxx, maxy)\n\ndef find_yellow_pixels(input_grid: np.ndarray) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Given an input grid, this function finds the first and last yellow pixels and returns their coordinates as a tuple (\n    \"\"\"\n    rows = input_grid.shape[0]\n    cols = input_grid.shape[1]\n    x1, y1, x2, y2 = (rows, cols, -1, -1)\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] == yellow:\n                x1 = min(x1, i)\n                y1 = min(y1, j)\n                x2 = max(x2, i)\n                y2 = max(y2, j)\n    return (x1, y1, x2, y2)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    x1, y1, x2, y2 = find_yellow_pixels(input_grid)\n    ans_grid = input_grid[x1:x2 + 1, y1:y2 + 1].copy()\n    input_grid[x1:x2 + 1, y1:y2 + 1] = black\n    minx, miny, maxx, maxy = update_min_max_coordinates(input_grid)\n    target_grid = input_grid[minx:maxx + 1, miny:maxy + 1]\n    kind, cnt = count_non_black_pixels(ans_grid)\n    import math\n    side_length = math.sqrt(cnt / (kind - 1))\n    target_grid = expand_target_grid(target_grid, side_length)\n    ans = copy_target_grid_to_first_non_black_non_yellow_pixel(ans_grid, target_grid)\n    return ans"},
{"name": "42a50994.json", "data": {"train": [{"input": [[0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 8, 0, 8, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0], [0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 8], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0]], "output": [[0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 6, 0, 0, 6, 0, 6, 0, 0, 0, 6, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 6, 0, 0, 6], [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 6, 0, 0, 0], [0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 5, 0, 0, 0, 5, 0, 0], [0, 5, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 5, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 5, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 5, 0, 0], [5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 5, 5, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0, 5]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 5, 0, 0, 0, 5, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5], [5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0], [5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 5, 5, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5]]}, {"input": [[0, 0, 0, 0, 0, 4, 0, 4, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 4, 0, 0, 4, 4], [4, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 4, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 4], [4, 0, 4, 0, 4, 0, 0, 4, 0], [0, 4, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 4, 4, 0, 0, 0], [4, 0, 4, 0, 4, 0, 0, 4, 4], [0, 0, 4, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 4, 4], [0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 4], [4, 0, 4, 0, 0, 0, 0, 4, 0], [0, 4, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 4, 4, 0, 0, 0], [0, 0, 4, 0, 4, 0, 0, 4, 4], [0, 0, 4, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 3], [3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 3], [3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 3, 0, 0, 0, 0, 3, 3, 3, 0, 0], [3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 3, 3, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 0, 3, 3, 0, 0, 0, 0, 0], [3, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0], [3, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0], [3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 3, 0, 0, 0, 0, 0, 3, 3]], "output": [[0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3], [3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 0, 0, 3], [3, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 0, 3, 3, 0, 0, 0, 0, 0], [3, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0], [3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 3, 0, 0, 0, 0, 0, 3, 3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_to_black(input_grid: np.ndarray, i: int, j: int) -> np.ndarray:\n    \"\"\"\n    Colors the given point in input_grid to black.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    i: An integer representing the row index of the point.\n    j: An integer representing the column index of the point.\n\n    Returns:\n    A numpy array with the given point colored black.\n    \"\"\"\n    input_grid[i][j] = black\n    return input_grid\n\ndef all_adjacent_black(input_grid: np.ndarray, i: int, j: int) -> bool:\n    \"\"\"\n    Checks if all eight adjacent points of the given point in input_grid are black.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    i: An integer representing the row index of the point.\n    j: An integer representing the column index of the point.\n\n    Returns:\n    A boolean value indicating if all eight adjacent points of the given point in input_grid are black.\n    \"\"\"\n    rows, cols = input_grid.shape\n    adjacent_points = [(i + di, j + dj) for di in [-1, 0, 1] for dj in [-1, 0, 1] if di != 0 or dj != 0]\n    for x, y in adjacent_points:\n        if x >= 0 and x < rows and (y >= 0) and (y < cols) and (input_grid[x][y] != black):\n            return False\n    return True\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if all_adjacent_black(input_grid, i, j):\n                input_grid = color_to_black(input_grid, i, j)\n    return input_grid"},
{"name": "8403a5d5.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 2, 5, 2, 0, 2, 5, 2, 0, 2], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2], [0, 2, 0, 2, 0, 2, 0, 2, 0, 2], [0, 2, 0, 2, 5, 2, 0, 2, 5, 2]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 3, 5, 3, 0, 3], [0, 0, 0, 0, 0, 3, 0, 3, 0, 3], [0, 0, 0, 0, 0, 3, 0, 3, 0, 3], [0, 0, 0, 0, 0, 3, 0, 3, 0, 3], [0, 0, 0, 0, 0, 3, 0, 3, 0, 3], [0, 0, 0, 0, 0, 3, 0, 3, 0, 3], [0, 0, 0, 0, 0, 3, 0, 3, 0, 3], [0, 0, 0, 0, 0, 3, 0, 3, 0, 3], [0, 0, 0, 0, 0, 3, 0, 3, 0, 3], [0, 0, 0, 0, 0, 3, 0, 3, 5, 3]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 4, 5, 4, 0, 4, 5], [0, 0, 0, 0, 4, 0, 4, 0, 4, 0], [0, 0, 0, 0, 4, 0, 4, 0, 4, 0], [0, 0, 0, 0, 4, 0, 4, 0, 4, 0], [0, 0, 0, 0, 4, 0, 4, 0, 4, 0], [0, 0, 0, 0, 4, 0, 4, 0, 4, 0], [0, 0, 0, 0, 4, 0, 4, 0, 4, 0], [0, 0, 0, 0, 4, 0, 4, 0, 4, 0], [0, 0, 0, 0, 4, 0, 4, 0, 4, 0], [0, 0, 0, 0, 4, 0, 4, 5, 4, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 1, 5, 1, 0, 1, 5, 1, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 5, 1, 0, 1, 5]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef replace_last_element_with_grey(output_grid: np.ndarray, i: int, col: int) -> np.ndarray:\n    if (i - col) % 4 == 3:\n        output_grid[-1, i] = grey\n    return output_grid\n\ndef replace_odd_column_with_grey(output_grid: np.ndarray, i: int, col: int) -> np.ndarray:\n    if (i - col) % 4 == 1:\n        output_grid[0, i] = grey\n    return output_grid\n\ndef replace_even_column_with_element(output_grid: np.ndarray, i: int, col: int, ele: int) -> np.ndarray:\n    if (i - col) % 2 == 0:\n        output_grid[:, i] = ele\n    return output_grid\n\ndef find_non_zero_element(input_grid: np.ndarray) -> Tuple[int, int]:\n    non_zero_indices = np.nonzero(input_grid)\n    return (non_zero_indices[1][0], input_grid[non_zero_indices][0])\n\ndef create_black_grid(input_grid: np.ndarray) -> np.ndarray:\n    return np.zeros_like(input_grid)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = create_black_grid(input_grid)\n    col, ele = find_non_zero_element(input_grid)\n    for i in range(input_grid.shape[1]):\n        if i >= col:\n            output_grid = replace_even_column_with_element(output_grid, i, col, ele)\n            output_grid = replace_odd_column_with_grey(output_grid, i, col)\n            output_grid = replace_last_element_with_grey(output_grid, i, col)\n    return output_grid"},
{"name": "d511f180.json", "data": {"train": [{"input": [[2, 7, 8, 8, 8], [5, 5, 6, 5, 4], [8, 5, 5, 5, 2], [8, 8, 4, 3, 6], [6, 5, 1, 9, 3]], "output": [[2, 7, 5, 5, 5], [8, 8, 6, 8, 4], [5, 8, 8, 8, 2], [5, 5, 4, 3, 6], [6, 8, 1, 9, 3]]}, {"input": [[3, 5, 1], [4, 5, 8], [2, 4, 9]], "output": [[3, 8, 1], [4, 8, 5], [2, 4, 9]]}, {"input": [[6, 5, 3], [5, 7, 5], [8, 8, 2]], "output": [[6, 8, 3], [8, 7, 8], [5, 5, 2]]}], "test": [{"input": [[8, 8, 4, 5], [3, 8, 7, 5], [3, 7, 1, 9], [6, 4, 8, 8]], "output": [[5, 5, 4, 8], [3, 5, 7, 8], [3, 7, 1, 9], [6, 4, 5, 5]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_color(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes an n*n grid with multiple color pixels as input.\n    It traverses all pixels and changes the color of the pixel from gray to teal and from teal to gray.\n    It returns the updated grid.\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == grey:\n                input_grid[i][j] = teal\n            elif input_grid[i][j] == teal:\n                input_grid[i][j] = grey\n    return input_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    ans_grid = change_color(input_grid)\n    return ans_grid"},
{"name": "a9f96cdd.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0], [0, 2, 0, 0, 0], [0, 0, 0, 0, 0]], "output": [[3, 0, 6, 0, 0], [0, 0, 0, 0, 0], [8, 0, 7, 0, 0]]}, {"input": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 2]], "output": [[0, 0, 0, 0, 0], [0, 0, 0, 3, 0], [0, 0, 0, 0, 0]]}, {"input": [[0, 0, 2, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0], [0, 8, 0, 7, 0], [0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0], [0, 0, 0, 2, 0], [0, 0, 0, 0, 0]], "output": [[0, 0, 3, 0, 6], [0, 0, 0, 0, 0], [0, 0, 8, 0, 7]]}], "test": [{"input": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 2], [0, 0, 0, 0, 0]], "output": [[0, 0, 0, 3, 0], [0, 0, 0, 0, 0], [0, 0, 0, 8, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef turn_red_pixel_to_black(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given an input grid, this function finds the first red pixel and turns it into black. \n    Then, it colors the neighboring pixels of the red pixel with specific colors and returns the updated grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    p = find_red_pixel(input_grid)\n    input_grid[p[0]][p[1]] = black\n    color = color_neighbors(p, input_grid)\n    return color\n\ndef color_neighbors(p: Tuple[int, int], input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a pixel coordinate and an input grid, this function colors the neighboring pixels of the given pixel\n    with specific colors and returns the updated grid.\n    \n    Args:\n    p: A tuple containing the row and column indices of the pixel to be colored.\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A numpy array representing the updated grid.\n    \"\"\"\n    if p[0] > 0:\n        if p[1] > 0:\n            input_grid[p[0] - 1][p[1] - 1] = green\n        if p[1] < input_grid.shape[1] - 1:\n            input_grid[p[0] - 1][p[1] + 1] = pink\n    if p[0] < input_grid.shape[0] - 1:\n        if p[1] > 0:\n            input_grid[p[0] + 1][p[1] - 1] = teal\n        if p[1] < input_grid.shape[1] - 1:\n            input_grid[p[0] + 1][p[1] + 1] = orange\n    return input_grid\n\ndef find_red_pixel(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Given an input grid, this function returns the coordinates of the first red pixel found.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A tuple containing the row and column indices of the first red pixel found.\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                return (i, j)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    p = find_red_pixel(input_grid)\n    color = color_neighbors(p, input_grid)\n    out = turn_red_pixel_to_black(color)\n    return out"},
{"name": "cf98881b.json", "data": {"train": [{"input": [[0, 4, 0, 4, 2, 9, 9, 0, 0, 2, 0, 0, 0, 0], [0, 4, 0, 0, 2, 0, 0, 9, 9, 2, 0, 1, 0, 0], [4, 0, 0, 0, 2, 0, 0, 0, 0, 2, 1, 1, 1, 0], [4, 4, 4, 4, 2, 9, 0, 9, 0, 2, 1, 1, 0, 1]], "output": [[9, 4, 0, 4], [0, 4, 9, 9], [4, 1, 1, 0], [4, 4, 4, 4]]}, {"input": [[4, 4, 4, 4, 2, 9, 0, 9, 0, 2, 0, 0, 0, 1], [4, 4, 0, 0, 2, 9, 9, 0, 0, 2, 1, 0, 0, 0], [4, 0, 4, 4, 2, 0, 0, 0, 9, 2, 0, 1, 0, 1], [0, 0, 0, 0, 2, 0, 0, 9, 0, 2, 1, 0, 1, 0]], "output": [[4, 4, 4, 4], [4, 4, 0, 0], [4, 1, 4, 4], [1, 0, 9, 0]]}, {"input": [[4, 4, 4, 0, 2, 9, 9, 0, 9, 2, 0, 1, 0, 1], [0, 4, 0, 4, 2, 0, 0, 9, 0, 2, 0, 1, 0, 0], [0, 4, 0, 4, 2, 0, 0, 9, 9, 2, 1, 0, 0, 1], [4, 0, 4, 4, 2, 9, 9, 9, 0, 2, 0, 0, 0, 1]], "output": [[4, 4, 4, 9], [0, 4, 9, 4], [1, 4, 9, 4], [4, 9, 4, 4]]}, {"input": [[0, 0, 0, 4, 2, 0, 0, 0, 9, 2, 0, 0, 0, 0], [4, 4, 0, 4, 2, 9, 0, 9, 0, 2, 0, 0, 0, 0], [4, 0, 4, 4, 2, 0, 9, 9, 0, 2, 1, 1, 0, 1], [0, 4, 4, 4, 2, 0, 9, 0, 0, 2, 1, 1, 1, 1]], "output": [[0, 0, 0, 4], [4, 4, 9, 4], [4, 9, 4, 4], [1, 4, 4, 4]]}, {"input": [[4, 0, 4, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 1], [4, 4, 4, 4, 2, 0, 0, 0, 9, 2, 1, 1, 0, 0], [0, 4, 4, 4, 2, 0, 9, 9, 0, 2, 1, 1, 0, 1], [0, 4, 4, 0, 2, 0, 0, 9, 0, 2, 0, 1, 0, 1]], "output": [[4, 0, 4, 1], [4, 4, 4, 4], [1, 4, 4, 4], [0, 4, 4, 1]]}], "test": [{"input": [[0, 0, 4, 0, 2, 9, 0, 9, 0, 2, 1, 1, 0, 0], [4, 4, 0, 4, 2, 9, 9, 9, 0, 2, 1, 1, 1, 0], [0, 0, 0, 0, 2, 0, 9, 9, 9, 2, 1, 1, 0, 1], [0, 4, 4, 0, 2, 9, 0, 9, 9, 2, 1, 0, 0, 0]], "output": [[9, 1, 4, 0], [4, 4, 9, 4], [1, 9, 9, 9], [9, 4, 4, 9]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef copy_non_black_pixels(output_grid: np.ndarray, grid: np.ndarray) -> np.ndarray:\n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if grid[i, j] != black:\n                output_grid[i, j] = grid[i, j]\n    return output_grid\n\ndef divide_grid_by_red_columns(grid: np.ndarray) -> List[np.ndarray]:\n    divided_grids = []\n    start_col = 0\n    for j in range(grid.shape[1]):\n        if np.all(grid[:, j] == red):\n            divided_grids.append(grid[:, start_col:j])\n            start_col = j + 1\n    divided_grids.append(grid[:, start_col:])\n    return divided_grids[:-1][::-1]\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    input_grid = np.concatenate((input_grid, np.array([[2], [2], [2], [2]])), axis=1)\n    divided_grids = divide_grid_by_red_columns(input_grid)\n    output_grid = np.zeros((4, 4))\n    for grid in divided_grids:\n        output_grid = copy_non_black_pixels(output_grid, grid)\n    return output_grid"},
{"name": "0ca9ddb6.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 4, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 4, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0], [0, 0, 0, 0, 0, 7, 1, 7, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 4, 0], [0, 0, 7, 0, 0, 0, 2, 0, 0], [0, 7, 1, 7, 0, 4, 0, 4, 0], [0, 0, 7, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0], [4, 0, 4, 0, 0, 7, 1, 7, 0], [0, 2, 0, 0, 0, 0, 7, 0, 0], [4, 0, 4, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 0, 4, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 4, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0], [0, 0, 7, 1, 7, 0, 0, 0, 0], [0, 0, 0, 7, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 6, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 7, 0, 0], [0, 4, 0, 4, 0, 7, 1, 7, 0], [0, 0, 2, 0, 0, 0, 7, 0, 0], [0, 4, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 4], [0, 6, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 4, 0, 4]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef set_orange_around_position(input_grid: np.ndarray, positions: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"\n    Sets the elements in up, down, left and right of input positions to orange in input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    positions: A list of tuples representing the positions in the input grid.\n    \n    Returns:\n    A numpy array representing the input grid with orange elements around the input positions.\n    \"\"\"\n    for i, j in positions:\n        if i > 0:\n            input_grid[i - 1][j] = orange\n        if i < input_grid.shape[0] - 1:\n            input_grid[i + 1][j] = orange\n        if j > 0:\n            input_grid[i][j - 1] = orange\n        if j < input_grid.shape[1] - 1:\n            input_grid[i][j + 1] = orange\n    return input_grid\n\ndef set_yellow_around_position(input_grid: np.ndarray, positions: List[Tuple[int, int]]) -> np.ndarray:\n    \"\"\"\n    Sets the elements in up-left, up-right, down-left and down-right of input positions to yellow in input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    positions: A list of tuples representing the positions in the input grid.\n    \n    Returns:\n    A numpy array representing the input grid with yellow elements around the input positions.\n    \"\"\"\n    for i, j in positions:\n        if i > 0 and j > 0:\n            input_grid[i - 1][j - 1] = yellow\n        if i > 0 and j < input_grid.shape[1] - 1:\n            input_grid[i - 1][j + 1] = yellow\n        if i < input_grid.shape[0] - 1 and j > 0:\n            input_grid[i + 1][j - 1] = yellow\n        if i < input_grid.shape[0] - 1 and j < input_grid.shape[1] - 1:\n            input_grid[i + 1][j + 1] = yellow\n    return input_grid\n\ndef find_blue_positions(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Returns a list of tuples representing the positions of all blue elements in the input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of tuples representing the positions of all blue elements in the input grid.\n    \"\"\"\n    blue_positions = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == blue:\n                blue_positions.append((i, j))\n    return blue_positions\n\ndef find_red_positions(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    Returns a list of tuples representing the positions of all red elements in the input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of tuples representing the positions of all red elements in the input grid.\n    \"\"\"\n    red_positions = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                red_positions.append((i, j))\n    return red_positions\n\ndef identity(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Returns the input grid as is.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A numpy array representing the input grid.\n    \"\"\"\n    return input_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = identity(input_grid)\n    red_positions = find_red_positions(input_grid)\n    blue_positions = find_blue_positions(input_grid)\n    output_grid = set_yellow_around_position(output_grid, red_positions)\n    output_grid = set_orange_around_position(output_grid, blue_positions)\n    return output_grid"},
{"name": "ff28f65a.json", "data": {"train": [{"input": [[2, 2, 0, 0, 0], [2, 2, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], "output": [[1, 0, 0], [0, 0, 0], [0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0], [0, 2, 2, 0, 0], [0, 2, 2, 0, 0], [0, 0, 0, 2, 2], [0, 0, 0, 2, 2]], "output": [[1, 0, 1], [0, 0, 0], [0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0], [0, 2, 2, 0, 2, 2, 0], [0, 0, 0, 0, 2, 2, 0], [0, 0, 2, 2, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], "output": [[1, 0, 1], [0, 1, 0], [0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0], [0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0], [0, 0, 2, 2, 0, 0]], "output": [[1, 0, 1], [0, 0, 0], [0, 0, 0]]}, {"input": [[0, 0, 0], [0, 2, 2], [0, 2, 2]], "output": [[1, 0, 0], [0, 0, 0], [0, 0, 0]]}, {"input": [[0, 0, 0, 0, 2, 2, 0], [0, 0, 0, 0, 2, 2, 0], [0, 2, 2, 0, 0, 0, 0], [0, 2, 2, 0, 2, 2, 0], [0, 0, 0, 0, 2, 2, 0], [0, 2, 2, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0]], "output": [[1, 0, 1], [0, 1, 0], [1, 0, 0]]}, {"input": [[0, 0, 0, 0, 2, 2, 0], [0, 2, 2, 0, 2, 2, 0], [0, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 2], [2, 2, 0, 0, 0, 2, 2], [2, 2, 0, 2, 2, 0, 0], [0, 0, 0, 2, 2, 0, 0]], "output": [[1, 0, 1], [0, 1, 0], [1, 0, 1]]}, {"input": [[0, 0, 2, 2, 0, 2, 2], [0, 0, 2, 2, 0, 2, 2], [2, 2, 0, 0, 0, 0, 0], [2, 2, 0, 2, 2, 0, 0], [0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], "output": [[1, 0, 1], [0, 1, 0], [1, 0, 0]]}], "test": [{"input": [[0, 0, 0, 2, 2, 0], [2, 2, 0, 2, 2, 0], [2, 2, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0], [0, 0, 2, 2, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[1, 0, 1], [0, 1, 0], [0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef generate_blue_grid(cnt: int) -> np.ndarray:\n    \"\"\"\n    Generates a new grid with blue squares based on the count of red squares in the input grid.\n    \n    Args:\n    cnt: An integer representing the count of 2x2 red squares in the input grid.\n    \n    Returns:\n    A numpy array representing the new grid with blue squares.\n    \"\"\"\n    grid = np.full((3, 3), black)\n    if cnt == 1:\n        grid[0][0] = blue\n    elif cnt == 2:\n        grid[0][0] = blue\n        grid[0][2] = blue\n    elif cnt == 3:\n        grid[0][0] = blue\n        grid[0][2] = blue\n        grid[1][1] = blue\n    elif cnt == 4:\n        grid[0][0] = blue\n        grid[0][2] = blue\n        grid[1][1] = blue\n        grid[2][0] = blue\n    elif cnt == 5:\n        grid[0][0] = blue\n        grid[0][2] = blue\n        grid[1][1] = blue\n        grid[2][0] = blue\n        grid[2][2] = blue\n    return grid\n\ndef count_red_squares(input_grid: np.ndarray) -> int:\n    \"\"\"\n    Counts how many 2x2 red squares there are in the input grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    An integer representing the number of 2x2 red squares in the input grid.\n    \"\"\"\n    cnt = 0\n    for i in range(input_grid.shape[0] - 1):\n        for j in range(input_grid.shape[1] - 1):\n            if input_grid[i][j] == red and input_grid[i + 1][j] == red and (input_grid[i][j + 1] == red) and (input_grid[i + 1][j + 1] == red):\n                cnt += 1\n    return cnt\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    cnt = count_red_squares(input_grid)\n    ans_grid = generate_blue_grid(cnt)\n    return ans_grid"},
{"name": "ec883f72.json", "data": {"train": [{"input": [[3, 3, 0, 9, 0, 0], [3, 3, 0, 9, 0, 0], [0, 0, 0, 9, 0, 0], [9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]], "output": [[3, 3, 0, 9, 0, 0], [3, 3, 0, 9, 0, 0], [0, 0, 0, 9, 0, 0], [9, 9, 9, 9, 0, 0], [0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 3]]}, {"input": [[0, 0, 8, 0, 6, 0, 8, 0], [0, 0, 8, 0, 0, 0, 8, 0], [0, 0, 8, 8, 8, 8, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 8, 0, 6, 0, 8, 0], [0, 0, 8, 0, 0, 0, 8, 0], [0, 0, 8, 8, 8, 8, 8, 0], [0, 6, 0, 0, 0, 0, 0, 6], [6, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0], [0, 4, 0, 2, 2, 0, 4, 0, 0], [0, 4, 0, 2, 2, 0, 4, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2], [2, 0, 0, 0, 0, 0, 0, 2, 0], [0, 4, 4, 4, 4, 4, 4, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0], [0, 4, 0, 2, 2, 0, 4, 0, 0], [0, 4, 0, 2, 2, 0, 4, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0], [4, 4, 4, 4, 0, 5, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 3, 0, 4, 4, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 4, 4, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 4, 4, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 3, 0, 4, 4, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 4, 4, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 4, 4, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 4], [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef inside_grid(grid: np.ndarray, coordinate: Tuple[int, int]) -> bool:\n    x, y = coordinate\n    return 0 <= x < grid.shape[0] and 0 <= y < grid.shape[1]\n\ndef draw_diagonal_line_after_meeting_color(grid, line_color, other_color, start_coordinate, direction):\n    x, y = start_coordinate\n    has_meet = False\n    while inside_grid(grid, start_coordinate):\n        if grid[x][y] == black and has_meet:\n            grid[x][y] = line_color\n        elif grid[x][y] == other_color:\n            has_meet = True\n        x += direction[0]\n        y += direction[1]\n        start_coordinate = (x, y)\n\ndef find_rectangle_corners(grid: np.ndarray, color: int) -> Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int], Tuple[int, int]]:\n    x, y = np.where(grid == color)\n    left, top = (np.min(y), np.min(x))\n    right, bottom = (np.max(y), np.max(x))\n    return ((top, left), (bottom, left), (top, right), (bottom, right))\n\ndef is_color_area_rectangle(color: int, grid: np.ndarray) -> bool:\n    x, y = np.where(grid == color)\n    if len(x) == 0:\n        return False\n    left, top = (np.min(y), np.min(x))\n    right, bottom = (np.max(y), np.max(x))\n    return np.all(grid[top:bottom + 1, left:right + 1] == color)\n\ndef find_all_colors_except_black(input_grid: np.ndarray) -> Tuple[int, int]:\n    colors = set(np.unique(input_grid))\n    colors.discard(black)\n    return tuple(colors)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    color1, color2 = find_all_colors_except_black(input_grid)\n    if is_color_area_rectangle(color1, input_grid):\n        rectangle_color, other_color = (color1, color2)\n    else:\n        rectangle_color, other_color = (color2, color1)\n    left_top, left_bottom, right_top, right_bottom = find_rectangle_corners(input_grid, rectangle_color)\n    draw_diagonal_line_after_meeting_color(input_grid, rectangle_color, other_color, left_top, (-1, -1))\n    draw_diagonal_line_after_meeting_color(input_grid, rectangle_color, other_color, left_bottom, (1, -1))\n    draw_diagonal_line_after_meeting_color(input_grid, rectangle_color, other_color, right_top, (-1, 1))\n    draw_diagonal_line_after_meeting_color(input_grid, rectangle_color, other_color, right_bottom, (1, 1))\n    return input_grid"},
{"name": "98cf29f8.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 4, 4, 4, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0], [0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 7, 0, 0], [0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 7, 7, 7, 7, 0, 0], [0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 7, 7, 7, 7, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef move_rectangle(rectangle_positions: Tuple[Tuple[int, int], Tuple[int, int]], direction: str, steps: int) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Given the top-left and bottom-right coordinates of a rectangle, the direction of movement, and the number of steps,\n    move the rectangle accordingly and return its new coordinates.\n    \n    Args:\n    rectangle_positions: A tuple containing the top-left and bottom-right coordinates of the rectangle\n    direction: A string representing the direction of movement ('up', 'down', 'left', or 'right')\n    steps: An integer representing the number of steps to move the rectangle\n    \n    Returns:\n    A tuple containing the top-left and bottom-right coordinates of the rectangle after movement\n    \"\"\"\n    top_left, bottom_right = rectangle_positions\n    if direction == 'up':\n        top_left = (top_left[0] - steps, top_left[1])\n        bottom_right = (bottom_right[0] - steps, bottom_right[1])\n    elif direction == 'down':\n        top_left = (top_left[0] + steps, top_left[1])\n        bottom_right = (bottom_right[0] + steps, bottom_right[1])\n    elif direction == 'left':\n        top_left = (top_left[0], top_left[1] - steps)\n        bottom_right = (bottom_right[0], bottom_right[1] - steps)\n    else:\n        top_left = (top_left[0], top_left[1] + steps)\n        bottom_right = (bottom_right[0], bottom_right[1] + steps)\n    return (top_left, bottom_right)\n\ndef get_direction_and_steps(rectangle_positions: Tuple[Tuple[int, int], Tuple[int, int]], flag_position: Tuple[int, int]) -> Tuple[str, int]:\n    \"\"\"\n    Given the top-left and bottom-right coordinates of a rectangle and the position of a flag, \n    determine the direction and number of steps needed to move the rectangle to cover the flag.\n    \n    Args:\n    rectangle_positions: A tuple containing the top-left and bottom-right coordinates of the rectangle\n    flag_position: A tuple containing the row and column index of the flag\n    \n    Returns:\n    A tuple containing the direction ('up', 'down', 'left', or 'right') and number of steps needed to move the rectangle\n    \"\"\"\n    top_left, bottom_right = rectangle_positions\n    flag_row, flag_col = flag_position\n    if flag_row < top_left[0]:\n        direction = 'up'\n        steps = top_left[0] - flag_row\n    elif flag_row > bottom_right[0]:\n        direction = 'down'\n        steps = flag_row - bottom_right[0]\n    elif flag_col < top_left[1]:\n        direction = 'left'\n        steps = top_left[1] - flag_col\n    else:\n        direction = 'right'\n        steps = flag_col - bottom_right[1]\n    return (direction, steps)\n\ndef get_rectangle_coordinates(input_grid: List[List[int]], color: int) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Traverse the input, return the top-left and bottom-right coordinates of the rectangle corresponding to the color\n    \n    Args:\n    input_grid: A list of lists representing the grid of colors\n    color: An integer representing the color of the rectangle\n    \n    Returns:\n    A tuple containing the top-left and bottom-right coordinates of the rectangle\n    \"\"\"\n    rows, cols = (len(input_grid), len(input_grid[0]))\n    top_left = None\n    bottom_right = None\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] == color:\n                if top_left is None:\n                    top_left = (i, j)\n                else:\n                    top_left = (min(top_left[0], i), min(top_left[1], j))\n                if bottom_right is None:\n                    bottom_right = (i, j)\n                else:\n                    bottom_right = (max(bottom_right[0], i), max(bottom_right[1], j))\n    return (top_left, bottom_right)\n\ndef move_rectangle_to_cover_flag(input, color, flag):\n    positions = get_rectangle_coordinates(input, color)\n    direction, steps = get_direction_and_steps(positions, flag)\n    output_positions = move_rectangle(positions, direction, steps)\n    output = np.copy(input)\n    output[positions[0][0]:positions[1][0] + 1, positions[0][1]:positions[1][1] + 1] = black\n    output[output_positions[0][0]:output_positions[1][0] + 1, output_positions[0][1]:output_positions[1][1] + 1] = color\n    return output\n\ndef black_positions_with_two_black_neighbors(input_grid: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    Traverse the input, black the position, two opposite connected positions of which are black\n    \n    Args:\n    input_grid: A list of lists representing the grid of colors\n    \n    Returns:\n    A list of lists with the updated grid of colors\n    \"\"\"\n    rows, cols = (len(input_grid), len(input_grid[0]))\n    output = np.copy(input_grid)\n    for i in range(rows):\n        for j in range(cols):\n            if i > 0 and i < rows - 1 and (j > 0) and (j < cols - 1):\n                if input_grid[i][j] != black and input_grid[i - 1][j] == black and (input_grid[i + 1][j] == black):\n                    output[i][j] = black\n                elif input_grid[i][j] != black and input_grid[i][j - 1] == black and (input_grid[i][j + 1] == black):\n                    output[i][j] = black\n    return output\n\ndef find_position_with_three_different_colors(input_grid: List[List[int]]) -> Tuple[int, int]:\n    \"\"\"\n    Traverse the input, return the position, the four connected positions of which have three different colors and this position is not black\n    \n    Args:\n    input_grid: A list of lists representing the grid of colors\n    \n    Returns:\n    A tuple containing the row and column index of the position\n    \"\"\"\n    rows, cols = (len(input_grid), len(input_grid[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if input_grid[i][j] != black:\n                colors = set()\n                if i > 0:\n                    colors.add(input_grid[i - 1][j])\n                if i < rows - 1:\n                    colors.add(input_grid[i + 1][j])\n                if j > 0:\n                    colors.add(input_grid[i][j - 1])\n                if j < cols - 1:\n                    colors.add(input_grid[i][j + 1])\n                if len(colors) == 3:\n                    return (i, j)\n    return None\n\ndef transform_grid(input_grid):\n    flag = find_position_with_three_different_colors(input_grid)\n    color = input_grid[flag]\n    output = np.copy(input_grid)\n    output = black_positions_with_two_black_neighbors(output)\n    output = move_rectangle_to_cover_flag(output, color, flag)\n    return output"},
{"name": "ff805c23.json", "data": {"train": [{"input": [[0, 3, 3, 3, 3, 0, 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 0, 1, 1, 1, 1, 1, 0], [3, 3, 3, 3, 3, 0, 2, 2, 0, 2, 2, 0, 0, 2, 2, 0, 2, 2, 1, 1, 1, 1, 1, 3], [3, 3, 3, 0, 0, 3, 2, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 2, 1, 1, 1, 1, 1, 3], [3, 3, 0, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 3], [3, 3, 0, 3, 3, 3, 0, 2, 0, 2, 2, 2, 2, 2, 2, 0, 2, 0, 1, 1, 1, 1, 1, 3], [0, 0, 3, 3, 3, 3, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 3, 3, 3, 3, 0, 0], [0, 2, 2, 2, 0, 0, 2, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 2, 0, 0, 2, 2, 2, 0], [2, 2, 0, 2, 2, 0, 0, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 0, 0, 2, 2, 0, 2, 2], [2, 0, 0, 2, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 2], [2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2], [0, 2, 0, 2, 2, 2, 2, 2, 0, 2, 0, 2, 2, 0, 2, 0, 2, 2, 2, 2, 2, 0, 2, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0], [0, 2, 0, 2, 2, 2, 2, 2, 0, 2, 0, 2, 2, 0, 2, 0, 2, 2, 2, 2, 2, 0, 2, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2], [2, 0, 0, 2, 0, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 2, 2, 0, 0, 0, 2, 0, 0, 2], [2, 2, 0, 2, 2, 0, 0, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 0, 0, 2, 2, 0, 2, 2], [0, 2, 2, 2, 0, 0, 2, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 2, 0, 0, 2, 2, 2, 0], [0, 0, 3, 3, 3, 3, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 3, 3, 3, 3, 0, 0], [3, 3, 0, 3, 3, 3, 0, 2, 0, 2, 2, 2, 2, 2, 2, 0, 2, 0, 3, 3, 3, 0, 3, 3], [3, 3, 0, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 0, 3, 3], [3, 3, 3, 0, 0, 3, 2, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 2, 3, 0, 0, 3, 3, 3], [3, 3, 3, 3, 3, 0, 2, 2, 0, 2, 2, 0, 0, 2, 2, 0, 2, 2, 0, 3, 3, 3, 3, 3], [0, 3, 3, 3, 3, 0, 0, 2, 2, 2, 0, 0, 0, 0, 2, 2, 2, 0, 0, 3, 3, 3, 3, 0]], "output": [[0, 3, 3, 3, 3], [0, 3, 3, 3, 3], [3, 0, 0, 3, 3], [3, 3, 3, 0, 3], [3, 3, 3, 0, 3]]}, {"input": [[0, 3, 3, 3, 0, 3, 0, 8, 8, 0, 8, 8, 8, 8, 0, 8, 8, 0, 3, 0, 3, 3, 3, 0], [3, 0, 3, 0, 3, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 3, 0, 3, 0, 3], [3, 3, 3, 3, 3, 3, 8, 8, 8, 0, 8, 8, 8, 8, 0, 8, 8, 8, 3, 3, 3, 3, 3, 3], [3, 0, 3, 0, 3, 3, 0, 0, 0, 8, 0, 8, 8, 0, 8, 0, 0, 0, 3, 3, 0, 3, 0, 3], [0, 3, 3, 3, 0, 0, 8, 0, 8, 0, 0, 8, 8, 0, 0, 8, 0, 8, 0, 0, 3, 3, 3, 0], [3, 0, 3, 3, 0, 3, 8, 0, 8, 8, 8, 0, 0, 8, 8, 8, 0, 8, 3, 0, 3, 3, 0, 3], [0, 8, 8, 0, 8, 8, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8, 0, 8, 8, 0], [8, 0, 8, 0, 0, 0, 6, 6, 0, 6, 6, 6, 6, 6, 6, 0, 6, 6, 0, 0, 0, 8, 0, 8], [8, 8, 8, 0, 8, 8, 6, 0, 0, 6, 0, 6, 6, 0, 6, 0, 0, 6, 8, 8, 0, 8, 8, 8], [0, 0, 0, 8, 0, 8, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 0, 8, 0, 0, 0], [8, 0, 8, 0, 0, 8, 6, 6, 0, 6, 6, 6, 6, 6, 6, 0, 6, 6, 8, 0, 0, 8, 0, 8], [8, 0, 8, 8, 8, 0, 1, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6, 6, 0, 8, 8, 8, 0, 8], [8, 0, 8, 8, 8, 0, 1, 1, 1, 1, 1, 0, 0, 6, 6, 6, 6, 6, 0, 8, 8, 8, 0, 8], [8, 0, 8, 0, 0, 8, 1, 1, 1, 1, 1, 6, 6, 6, 6, 0, 6, 6, 8, 0, 0, 8, 0, 8], [0, 0, 0, 8, 0, 8, 1, 1, 1, 1, 1, 6, 6, 6, 6, 6, 6, 6, 8, 0, 8, 0, 0, 0], [8, 8, 8, 0, 8, 8, 1, 1, 1, 1, 1, 6, 6, 0, 6, 0, 0, 6, 8, 8, 0, 8, 8, 8], [8, 0, 8, 0, 0, 0, 6, 6, 0, 6, 6, 6, 6, 6, 6, 0, 6, 6, 0, 0, 0, 8, 0, 8], [0, 8, 8, 0, 8, 8, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8, 0, 8, 8, 0], [3, 0, 3, 3, 0, 3, 8, 0, 8, 8, 8, 0, 0, 8, 8, 8, 0, 8, 3, 0, 3, 3, 0, 3], [0, 3, 3, 3, 0, 0, 8, 0, 8, 0, 0, 8, 8, 0, 0, 8, 0, 8, 0, 0, 3, 3, 3, 0], [3, 0, 3, 0, 3, 3, 0, 0, 0, 8, 0, 8, 8, 0, 8, 0, 0, 0, 3, 3, 0, 3, 0, 3], [3, 3, 3, 3, 3, 3, 8, 8, 8, 0, 8, 8, 8, 8, 0, 8, 8, 8, 3, 3, 3, 3, 3, 3], [3, 0, 3, 0, 3, 0, 8, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 3, 0, 3, 0, 3], [0, 3, 3, 3, 0, 3, 0, 8, 8, 0, 8, 8, 8, 8, 0, 8, 8, 0, 3, 0, 3, 3, 3, 0]], "output": [[6, 6, 6, 6, 6], [6, 6, 6, 6, 6], [6, 6, 0, 6, 6], [6, 6, 6, 6, 6], [6, 0, 0, 6, 0]]}, {"input": [[0, 3, 3, 3, 3, 0, 5, 5, 5, 0, 0, 5, 5, 0, 0, 5, 5, 5, 0, 3, 3, 3, 3, 0], [3, 3, 3, 3, 3, 3, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 3, 3, 3, 3, 3, 3], [3, 3, 3, 0, 0, 0, 5, 0, 0, 5, 5, 0, 0, 5, 5, 0, 0, 5, 0, 0, 0, 3, 3, 3], [3, 3, 0, 0, 3, 3, 0, 0, 5, 0, 5, 5, 5, 5, 0, 5, 0, 0, 3, 3, 0, 0, 3, 3], [3, 3, 0, 3, 3, 0, 0, 0, 5, 5, 0, 0, 0, 0, 5, 5, 0, 0, 0, 3, 3, 0, 3, 3], [0, 3, 0, 3, 0, 3, 5, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 5, 3, 0, 3, 0, 3, 0], [5, 5, 5, 0, 0, 5, 0, 5, 0, 0, 5, 5, 5, 5, 0, 0, 5, 0, 5, 0, 0, 5, 5, 5], [5, 5, 0, 0, 0, 0, 5, 5, 5, 0, 0, 5, 5, 0, 0, 5, 5, 5, 0, 0, 0, 0, 5, 5], [5, 0, 0, 5, 5, 0, 0, 5, 5, 5, 0, 5, 5, 0, 5, 5, 5, 0, 0, 5, 5, 0, 0, 5], [0, 0, 5, 0, 5, 5, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 5, 5, 0, 5, 0, 0], [0, 0, 5, 5, 0, 0, 5, 0, 0, 5, 0, 5, 5, 0, 5, 0, 0, 5, 0, 0, 5, 5, 0, 0], [5, 0, 0, 5, 0, 0, 5, 5, 5, 5, 5, 0, 0, 5, 5, 5, 5, 5, 0, 0, 5, 0, 0, 5], [5, 0, 0, 5, 0, 0, 5, 5, 5, 5, 5, 0, 0, 5, 5, 5, 5, 5, 0, 0, 5, 0, 0, 5], [0, 0, 5, 5, 0, 0, 5, 0, 0, 5, 0, 5, 5, 0, 5, 0, 0, 5, 0, 0, 5, 5, 0, 0], [0, 0, 5, 0, 5, 5, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 5, 5, 0, 5, 0, 0], [5, 0, 0, 5, 5, 0, 0, 5, 5, 5, 1, 1, 1, 1, 1, 5, 5, 0, 0, 5, 5, 0, 0, 5], [5, 5, 0, 0, 0, 0, 5, 5, 5, 0, 1, 1, 1, 1, 1, 5, 5, 5, 0, 0, 0, 0, 5, 5], [5, 5, 5, 0, 0, 5, 0, 5, 0, 0, 1, 1, 1, 1, 1, 0, 5, 0, 5, 0, 0, 5, 5, 5], [0, 3, 0, 3, 0, 3, 5, 0, 0, 5, 1, 1, 1, 1, 1, 0, 0, 5, 3, 0, 3, 0, 3, 0], [3, 3, 0, 3, 3, 0, 0, 0, 5, 5, 1, 1, 1, 1, 1, 5, 0, 0, 0, 3, 3, 0, 3, 3], [3, 3, 0, 0, 3, 3, 0, 0, 5, 0, 5, 5, 5, 5, 0, 5, 0, 0, 3, 3, 0, 0, 3, 3], [3, 3, 3, 0, 0, 0, 5, 0, 0, 5, 5, 0, 0, 5, 5, 0, 0, 5, 0, 0, 0, 3, 3, 3], [3, 3, 3, 3, 3, 3, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 3, 3, 3, 3, 3, 3], [0, 3, 3, 3, 3, 0, 5, 5, 5, 0, 0, 5, 5, 0, 0, 5, 5, 5, 0, 3, 3, 3, 3, 0]], "output": [[0, 5, 5, 0, 5], [0, 5, 5, 0, 0], [5, 5, 5, 5, 0], [0, 0, 0, 0, 5], [0, 0, 0, 0, 5]]}], "test": [{"input": [[4, 4, 4, 0, 4, 0, 0, 3, 3, 3, 0, 0, 0, 0, 3, 3, 3, 0, 0, 4, 0, 4, 4, 4], [4, 4, 4, 4, 0, 4, 3, 3, 3, 3, 0, 3, 3, 0, 3, 3, 3, 3, 4, 0, 4, 4, 4, 4], [4, 4, 0, 4, 0, 0, 3, 3, 0, 0, 3, 3, 3, 3, 0, 0, 3, 3, 0, 0, 4, 0, 4, 4], [0, 4, 4, 0, 4, 4, 3, 3, 0, 0, 3, 3, 3, 3, 0, 0, 3, 3, 4, 4, 0, 4, 4, 0], [4, 0, 0, 4, 4, 4, 0, 0, 3, 3, 0, 3, 3, 0, 3, 3, 0, 0, 4, 4, 4, 0, 0, 4], [0, 4, 0, 4, 4, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 4, 4, 0, 4, 0], [0, 3, 3, 3, 0, 0, 8, 8, 8, 1, 1, 1, 1, 1, 8, 8, 8, 8, 0, 0, 3, 3, 3, 0], [3, 3, 3, 3, 0, 3, 8, 8, 8, 1, 1, 1, 1, 1, 0, 8, 8, 8, 3, 0, 3, 3, 3, 3], [3, 3, 0, 0, 3, 3, 8, 8, 8, 1, 1, 1, 1, 1, 0, 8, 8, 8, 3, 3, 0, 0, 3, 3], [3, 3, 0, 0, 3, 3, 8, 0, 0, 1, 1, 1, 1, 1, 8, 0, 0, 8, 3, 3, 0, 0, 3, 3], [0, 0, 3, 3, 0, 3, 8, 0, 8, 1, 1, 1, 1, 1, 8, 8, 0, 8, 3, 0, 3, 3, 0, 0], [0, 3, 3, 3, 3, 3, 8, 8, 0, 8, 8, 8, 8, 8, 8, 0, 8, 8, 3, 3, 3, 3, 3, 0], [0, 3, 3, 3, 3, 3, 8, 8, 0, 8, 8, 8, 8, 8, 8, 0, 8, 8, 3, 3, 3, 3, 3, 0], [0, 0, 3, 3, 0, 3, 8, 0, 8, 8, 0, 8, 8, 0, 8, 8, 0, 8, 3, 0, 3, 3, 0, 0], [3, 3, 0, 0, 3, 3, 8, 0, 0, 8, 8, 8, 8, 8, 8, 0, 0, 8, 3, 3, 0, 0, 3, 3], [3, 3, 0, 0, 3, 3, 8, 8, 8, 0, 8, 0, 0, 8, 0, 8, 8, 8, 3, 3, 0, 0, 3, 3], [3, 3, 3, 3, 0, 3, 8, 8, 8, 0, 0, 8, 8, 0, 0, 8, 8, 8, 3, 0, 3, 3, 3, 3], [0, 3, 3, 3, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 0, 0, 3, 3, 3, 0], [0, 4, 0, 4, 4, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 4, 4, 0, 4, 0], [4, 0, 0, 4, 4, 4, 0, 0, 3, 3, 0, 3, 3, 0, 3, 3, 0, 0, 4, 4, 4, 0, 0, 4], [0, 4, 4, 0, 4, 4, 3, 3, 0, 0, 3, 3, 3, 3, 0, 0, 3, 3, 4, 4, 0, 4, 4, 0], [4, 4, 0, 4, 0, 0, 3, 3, 0, 0, 3, 3, 3, 3, 0, 0, 3, 3, 0, 0, 4, 0, 4, 4], [4, 4, 4, 4, 0, 4, 3, 3, 3, 3, 0, 3, 3, 0, 3, 3, 3, 3, 4, 0, 4, 4, 4, 4], [4, 4, 4, 0, 4, 0, 0, 3, 3, 3, 0, 0, 0, 0, 3, 3, 3, 0, 0, 4, 0, 4, 4, 4]], "output": [[8, 8, 8, 8, 8], [0, 0, 8, 8, 0], [0, 8, 0, 0, 8], [8, 8, 8, 8, 8], [8, 0, 8, 8, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef rotate_grid_180(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a 2D numpy array representing a grid of colors, this function rotates the grid 180 degrees.\n\n    Args:\n    input_grid: A 2D numpy array representing a grid of colors.\n\n    Returns:\n    A 2D numpy array representing the rotated grid.\n    \"\"\"\n    return np.rot90(np.rot90(input_grid))\n\ndef find_blue_square(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Given a 2D numpy array representing a grid of colors, this function finds the top-left coordinates of a 5x5 blue square.\n\n    Args:\n    input_grid: A 2D numpy array representing a grid of colors.\n\n    Returns:\n    A tuple of two integers representing the top-left coordinates of a 5x5 blue square.\n    \"\"\"\n    i, j = np.where(input_grid == blue)\n    return (i[0], j[0])\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    i, j = find_blue_square(input_grid)\n    grid = rotate_grid_180(input_grid)\n    return grid[i:i + 5, j:j + 5]"},
{"name": "eb5a1d5d.json", "data": {"train": [{"input": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]], "output": [[8, 8, 8, 8, 8], [8, 3, 3, 3, 8], [8, 3, 2, 3, 8], [8, 3, 3, 3, 8], [8, 8, 8, 8, 8]]}, {"input": [[5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]], "output": [[5, 5, 5], [5, 6, 5], [5, 5, 5]]}, {"input": [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 2, 2, 2, 1, 1, 1, 1, 1, 2, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 2, 2, 2, 1, 1, 1, 1, 1, 2, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 2, 2, 2, 1, 1, 1, 1, 1, 2, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]], "output": [[3, 3, 3, 3, 3, 3, 3], [3, 8, 8, 8, 8, 8, 3], [3, 8, 2, 2, 2, 8, 3], [3, 8, 2, 1, 2, 8, 3], [3, 8, 2, 2, 2, 8, 3], [3, 8, 8, 8, 8, 8, 3], [3, 3, 3, 3, 3, 3, 3]]}], "test": [{"input": [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 8, 8, 8, 2, 2, 2, 2, 8, 8, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 8, 8, 8, 2, 2, 2, 2, 8, 8, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 8, 8, 8, 2, 2, 2, 2, 8, 8, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 8, 8, 8, 2, 2, 2, 2, 8, 8, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]], "output": [[2, 2, 2, 2, 2, 2, 2, 2, 2], [2, 1, 1, 1, 1, 1, 1, 1, 2], [2, 1, 3, 3, 3, 3, 3, 1, 2], [2, 1, 3, 8, 8, 8, 3, 1, 2], [2, 1, 3, 8, 2, 8, 3, 1, 2], [2, 1, 3, 8, 8, 8, 3, 1, 2], [2, 1, 3, 3, 3, 3, 3, 1, 2], [2, 1, 1, 1, 1, 1, 1, 1, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_bottom_right_position(input: np.ndarray, color: int) -> Tuple[int, int]:\n    \"\"\"\n    This function takes in a numpy array representing a grid of integers and a color.\n    It returns the most bottom right position with a different color than the given color.\n    \"\"\"\n    for i in range(len(input) - 1, -1, -1):\n        for j in range(len(input[0]) - 1, -1, -1):\n            if input[i][j] != color:\n                return (i, j)\n    return (-1, -1)\n\ndef find_top_left_position(input: np.ndarray, color: int) -> Tuple[int, int]:\n    \"\"\"\n    This function takes in a numpy array representing a grid of integers and a color.\n    It returns the most top left position with a different color than the given color.\n    \"\"\"\n    for i in range(len(input)):\n        for j in range(len(input[0])):\n            if input[i][j] != color:\n                return (i, j)\n    return (-1, -1)\n\ndef all_positions_same_color(input: np.ndarray) -> bool:\n    \"\"\"\n    This function takes in a numpy array representing a grid of integers.\n    It returns True if all positions in the input are the same color, False otherwise.\n    \"\"\"\n    return (input == input[0, 0]).all()\n\ndef color_output(output: np.ndarray, colors: List[int]) -> np.ndarray:\n    \"\"\"\n    This function takes in a numpy array representing an output grid and a list of colors.\n    It colors the output in a spiral pattern, starting from the outside and moving inwards, changing one circle at a time.\n    \"\"\"\n    color_index = 0\n    row_start = col_start = 0\n    row_end = col_end = output.shape[0] - 1\n    while row_start <= row_end and col_start <= col_end:\n        for j in range(col_start, col_end + 1):\n            output[row_start][j] = colors[color_index]\n        row_start += 1\n        for i in range(row_start, row_end + 1):\n            output[i][col_end] = colors[color_index]\n        col_end -= 1\n        if row_start <= row_end:\n            for j in range(col_end, col_start - 1, -1):\n                output[row_end][j] = colors[color_index]\n            row_end -= 1\n        if col_start <= col_end:\n            for i in range(row_end, row_start - 1, -1):\n                output[i][col_start] = colors[color_index]\n            col_start += 1\n        color_index += 1\n    return output\n\ndef find_and_sort_colors(input):\n    color = []\n    while True:\n        color.append(input[0, 0])\n        if all_positions_same_color(input):\n            break\n        position_1 = find_top_left_position(input, color[-1])\n        position_2 = find_bottom_right_position(input, color[-1])\n        input = input[position_1[0]:position_2[0], position_1[1]:position_2[1]]\n    return color\n\ndef transform_grid(input_grid):\n    exist_colors = find_and_sort_colors(input_grid)\n    number_colors = len(exist_colors)\n    output = np.zeros((2 * number_colors - 1, 2 * number_colors - 1), dtype=np.int32)\n    output = color_output(output, exist_colors)\n    return output"},
{"name": "0d3d703e.json", "data": {"train": [{"input": [[3, 1, 2], [3, 1, 2], [3, 1, 2]], "output": [[4, 5, 6], [4, 5, 6], [4, 5, 6]]}, {"input": [[2, 3, 8], [2, 3, 8], [2, 3, 8]], "output": [[6, 4, 9], [6, 4, 9], [6, 4, 9]]}, {"input": [[5, 8, 6], [5, 8, 6], [5, 8, 6]], "output": [[1, 9, 2], [1, 9, 2], [1, 9, 2]]}, {"input": [[9, 4, 2], [9, 4, 2], [9, 4, 2]], "output": [[8, 3, 6], [8, 3, 6], [8, 3, 6]]}], "test": [{"input": [[8, 1, 3], [8, 1, 3], [8, 1, 3]], "output": [[9, 5, 4], [9, 5, 4], [9, 5, 4]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_colors(input: List[List[int]], colors: Dict[int, int]) -> List[List[int]]:\n    for i in range(len(input)):\n        for j in range(len(input[0])):\n            if input[i][j] in colors:\n                input[i][j] = colors[input[i][j]]\n    return input\n\ndef transform_grid(input):\n    colors = {green: yellow, blue: grey, red: pink, teal: maroon, grey: blue, yellow: green, maroon: teal, pink: red}\n    output = change_colors(input, colors)\n    return output"},
{"name": "d037b0a7.json", "data": {"train": [{"input": [[0, 0, 6], [0, 4, 0], [3, 0, 0]], "output": [[0, 0, 6], [0, 4, 6], [3, 4, 6]]}, {"input": [[0, 2, 0], [7, 0, 8], [0, 0, 0]], "output": [[0, 2, 0], [7, 2, 8], [7, 2, 8]]}, {"input": [[4, 0, 0], [0, 2, 0], [0, 0, 0]], "output": [[4, 0, 0], [4, 2, 0], [4, 2, 0]]}], "test": [{"input": [[4, 0, 8], [0, 0, 0], [0, 7, 0]], "output": [[4, 0, 8], [4, 0, 8], [4, 7, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef fill_blocks_below(input_grid: np.ndarray, x: int, y: int) -> np.ndarray:\n    \"\"\"\n    This function takes a numpy array and the indexes of a colored block as input and fills the blocks below it with its color.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    x: An integer representing the row index of the colored block.\n    y: An integer representing the column index of the colored block.\n    \n    Returns:\n    A numpy array with the blocks below the colored block filled with its color.\n    \"\"\"\n    color = input_grid[x][y]\n    for i in range(x + 1, input_grid.shape[0]):\n        if input_grid[i][y] == black:\n            input_grid[i][y] = color\n        else:\n            break\n    return input_grid\n\ndef find_non_black_indexes(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    \"\"\"\n    This function takes a numpy array as input and returns a list of tuples containing the indexes of non-black blocks in the grid.\n    \n    Args:\n    input_grid: A numpy array representing the input grid.\n    \n    Returns:\n    A list of tuples containing the indexes of non-black blocks in the grid.\n    \"\"\"\n    non_black_indexes = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black:\n                non_black_indexes.append((i, j))\n    return non_black_indexes\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    colored_index_list = find_non_black_indexes(input_grid)\n    for x, y in colored_index_list:\n        input_grid = fill_blocks_below(input_grid, x, y)\n    return input_grid"},
{"name": "d5d6de2d.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 2, 0, 2, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 0, 0], [0, 0, 0, 0, 2, 0, 0, 2, 0, 0], [0, 0, 0, 0, 2, 0, 0, 2, 0, 0], [0, 0, 0, 0, 2, 0, 0, 2, 0, 0], [0, 0, 0, 0, 2, 2, 2, 2, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 2, 0, 2, 0, 0, 0], [0, 0, 0, 0, 2, 0, 2, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0], [0, 2, 0, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 0, 0, 0, 2, 0], [0, 2, 2, 2, 2, 2, 2, 2, 2, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 3, 3, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_red_black(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes in a numpy array as input_grid and colors all the red grids black.\n    \n    Args:\n    input_grid: A numpy array of shape (n, m) representing the input grid.\n    \n    Returns:\n    A numpy array of shape (n, m) representing the updated input grid with black colored red grids.\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                input_grid[i][j] = black\n    return input_grid\n\ndef color_holes_green(locations: List[Tuple[Tuple[int, int], Tuple[int, int]]], input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes in a list of tuples containing the location of red boxes in the input_grid and the input_grid itself.\n    It then locates the holes in each red box and colors them green in the input_grid. The function returns the updated input_grid.\n    \n    Args:\n    locations: A list of tuples, where each tuple contains the location of a red box in the input_grid.\n    input_grid: A numpy array of shape (n, m) representing the input grid.\n    \n    Returns:\n    A numpy array of shape (n, m) representing the updated input grid with green holes in each red box.\n    \"\"\"\n    for location in locations:\n        left_top = location[0]\n        down_right = location[1]\n        for i in range(left_top[0] + 1, down_right[0]):\n            for j in range(left_top[1] + 1, down_right[1]):\n                input_grid[i][j] = green\n    return input_grid\n\ndef get_red_box_locations(input_grid: np.ndarray) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n    \"\"\"\n    This function takes in a numpy array as input_grid and returns a list of tuples, where each tuple contains the \n    location of a red box in the input_grid. The location of a box is its left-top corner and the down-right corner.\n    \n    Args:\n    input_grid: A numpy array of shape (n, m) representing the input grid.\n    \n    Returns:\n    A list of tuples, where each tuple contains the location of a red box in the input_grid.\n    \"\"\"\n    red_boxes = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == red:\n                left_top = (i, j)\n                down_right = (i, j)\n                while down_right[0] < input_grid.shape[0] and input_grid[down_right[0]][down_right[1]] == red:\n                    down_right = (down_right[0] + 1, down_right[1])\n                while down_right[1] < input_grid.shape[1] and input_grid[left_top[0]][down_right[1]] == red:\n                    down_right = (down_right[0], down_right[1] + 1)\n                red_boxes.append((left_top, (down_right[0] - 1, down_right[1] - 1)))\n    return red_boxes\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    locations = get_red_box_locations(input_grid)\n    output = color_holes_green(locations, input_grid)\n    output = color_red_black(output)\n    return output"},
{"name": "272f95fa.json", "data": {"train": [{"input": [[0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 8, 2, 2, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 2, 2, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [4, 4, 4, 4, 8, 6, 6, 6, 6, 6, 6, 8, 3, 3, 3, 3, 3, 3, 3], [4, 4, 4, 4, 8, 6, 6, 6, 6, 6, 6, 8, 3, 3, 3, 3, 3, 3, 3], [4, 4, 4, 4, 8, 6, 6, 6, 6, 6, 6, 8, 3, 3, 3, 3, 3, 3, 3], [4, 4, 4, 4, 8, 6, 6, 6, 6, 6, 6, 8, 3, 3, 3, 3, 3, 3, 3], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0]], "output": [[0, 0, 8, 2, 2, 2, 2, 2, 2, 8, 0, 0, 0, 0], [0, 0, 8, 2, 2, 2, 2, 2, 2, 8, 0, 0, 0, 0], [0, 0, 8, 2, 2, 2, 2, 2, 2, 8, 0, 0, 0, 0], [0, 0, 8, 2, 2, 2, 2, 2, 2, 8, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [4, 4, 8, 6, 6, 6, 6, 6, 6, 8, 3, 3, 3, 3], [4, 4, 8, 6, 6, 6, 6, 6, 6, 8, 3, 3, 3, 3], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0], [0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0], [0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0], [0, 0, 8, 1, 1, 1, 1, 1, 1, 8, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 8, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 2, 2, 2, 2, 8, 0, 0, 0, 0, 0, 0], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [4, 4, 4, 8, 6, 6, 6, 6, 8, 3, 3, 3, 3, 3, 3], [4, 4, 4, 8, 6, 6, 6, 6, 8, 3, 3, 3, 3, 3, 3], [4, 4, 4, 8, 6, 6, 6, 6, 8, 3, 3, 3, 3, 3, 3], [4, 4, 4, 8, 6, 6, 6, 6, 8, 3, 3, 3, 3, 3, 3], [4, 4, 4, 8, 6, 6, 6, 6, 8, 3, 3, 3, 3, 3, 3], [4, 4, 4, 8, 6, 6, 6, 6, 8, 3, 3, 3, 3, 3, 3], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [0, 0, 0, 8, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0], [0, 0, 0, 8, 1, 1, 1, 1, 8, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_rectangle(grid: np.ndarray, rectangle: Tuple[int, int, int, int], color: int) -> np.ndarray:\n    i, j, k, l = rectangle\n    grid[i:k + 1, j:l + 1] = color\n    return grid\n\ndef find_black_rectangles(grid: np.ndarray) -> List[Tuple[int, int, int, int]]:\n    black_rectangles = []\n    rows, cols = grid.shape\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == black:\n                k = i\n                while k < rows and grid[k][j] == black:\n                    k += 1\n                l = j\n                while l < cols and grid[i][l] == black:\n                    l += 1\n                black_rectangles.append((i, j, k - 1, l - 1))\n                grid[i:k, j:l] = teal\n    return black_rectangles\n\ndef copy_grid(input_grid: np.ndarray) -> np.ndarray:\n    return np.copy(input_grid)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output = copy_grid(input_grid)\n    BLACK_block_list = find_black_rectangles(input_grid)\n    output = color_rectangle(output, BLACK_block_list[1], red)\n    output = color_rectangle(output, BLACK_block_list[3], yellow)\n    output = color_rectangle(output, BLACK_block_list[4], pink)\n    output = color_rectangle(output, BLACK_block_list[5], green)\n    output = color_rectangle(output, BLACK_block_list[7], blue)\n    return output"},
{"name": "834ec97d.json", "data": {"train": [{"input": [[0, 2, 0], [0, 0, 0], [0, 0, 0]], "output": [[0, 4, 0], [0, 2, 0], [0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 6, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]], "output": [[4, 0, 4, 0, 4], [4, 0, 4, 0, 4], [4, 0, 4, 0, 4], [0, 0, 6, 0, 0], [0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[4, 0, 4, 0, 4, 0, 4, 0, 4], [4, 0, 4, 0, 4, 0, 4, 0, 4], [4, 0, 4, 0, 4, 0, 4, 0, 4], [4, 0, 4, 0, 4, 0, 4, 0, 4], [4, 0, 4, 0, 4, 0, 4, 0, 4], [0, 0, 9, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4], [0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4], [0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4], [0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef copy_short_yellow_line(input_grid: np.ndarray, shape: Tuple[int, int], i: int) -> np.ndarray:\n    \"\"\"\n    Copies a short yellow line with the given shape at the specified column index in the input grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    shape: A tuple representing the shape of the yellow line (start row, end row).\n    i: An integer representing the column index where the yellow line should be copied.\n\n    Returns:\n    A numpy array representing the updated grid after copying the yellow line.\n    \"\"\"\n    start_row, end_row = shape\n    for row in range(start_row, end_row + 1):\n        input_grid[row][i] = yellow\n    return input_grid\n\ndef find_yellow_line(input_grid: np.ndarray) -> Tuple[int, Tuple[int, int]]:\n    \"\"\"\n    Finds the index and shape of the vertical line in yellow in the input grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A tuple containing the index of the yellow line and a tuple representing its shape (start row, end row).\n    \"\"\"\n    yellow_pixels = np.where(input_grid == yellow)\n    if len(yellow_pixels[1]) == 0:\n        return None\n    j = yellow_pixels[1][0]\n    start_row = min(yellow_pixels[0])\n    end_row = max(yellow_pixels[0])\n    return (j, (start_row, end_row))\n\ndef copy_yellow_pattern_along_horizontal(input_grid: np.ndarray) -> np.ndarray:\n    index, shape = find_yellow_line(input_grid)\n    for i in range(input_grid.shape[1]):\n        if i % 2 == index % 2:\n            input_grid = copy_short_yellow_line(input_grid, shape, i)\n    return input_grid\n\ndef color_pixels_above_yellow(p: Tuple[int, int], input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Colors the given pixel and the pixels above it in the same column in yellow.\n\n    Args:\n    p: A tuple containing the row and column indices of the pixel to be colored.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated grid after coloring the pixels in yellow.\n    \"\"\"\n    i, j = p\n    input_grid[i][j] = yellow\n    for k in range(i):\n        input_grid[k][j] = yellow\n    return input_grid\n\ndef move_down(p: Tuple[int, int], input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Moves the given pixel down by one row in the input grid.\n\n    Args:\n    p: A tuple containing the row and column indices of the pixel to be moved.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated grid after moving the pixel down by one row.\n    \"\"\"\n    i, j = p\n    if i == input_grid.shape[0] - 1:\n        return input_grid\n    input_grid[i][j], input_grid[i + 1][j] = (input_grid[i + 1][j], input_grid[i][j])\n    return input_grid\n\ndef find_not_black_pixel(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    Finds the first non-black pixel in the input grid and returns its coordinates.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A tuple containing the row and column indices of the first non-black pixel.\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] != black:\n                return (i, j)\n    return None\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    p = find_not_black_pixel(input_grid)\n    move = move_down(p, input_grid)\n    color = color_pixels_above_yellow(p, input_grid)\n    out = copy_yellow_pattern_along_horizontal(input_grid)\n    return out"},
{"name": "5117e062.json", "data": {"train": [{"input": [[0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 3, 3, 3, 0, 0, 0, 0, 0, 4, 8, 4, 0], [0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 4, 0], [4, 4, 4], [0, 4, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 3, 3], [3, 3, 0], [0, 3, 3]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[2, 2, 2], [0, 2, 0], [2, 2, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 7, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 7, 7], [7, 7, 7], [0, 7, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef extract_3x3_grid(input_grid: np.ndarray, special_pixels: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    This function takes in the input grid as a numpy array and the special pixel's indices as a tuple.\n    It extracts the 3x3 grid from the input_grid whose center is the special pixel.\n    It returns the extracted 3x3 grid.\n    \"\"\"\n    i, j = special_pixels\n    return input_grid[i - 1:i + 2, j - 1:j + 2]\n\ndef change_special_pixel_color(input_grid: np.ndarray, special_pixels: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    This function takes in the input grid as a numpy array and the special pixel's indices as a tuple.\n    It changes the color of the special pixel to the color of its surrounding pixels, except for black.\n    It returns the updated input grid.\n    \"\"\"\n    i, j = special_pixels\n    surrounding_pixels = get_surrounding_pixels(i, j, input_grid)\n    new_color = [color for color in surrounding_pixels if color != black][0]\n    input_grid[i, j] = new_color\n    return input_grid\n\ndef get_surrounding_pixels(i: int, j: int, input_grid: np.ndarray) -> List[int]:\n    \"\"\"\n    This function takes in the row index i, column index j, and the input grid as a numpy array.\n    It returns a list of the surrounding pixels of the 3x3 grid in the input_grid except for itself.\n    \"\"\"\n    return [input_grid[x, y] for x in range(i - 1, i + 2) for y in range(j - 1, j + 2) if 0 <= x < input_grid.shape[0] and 0 <= y < input_grid.shape[1] and ((x, y) != (i, j))]\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    flag = False\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            surroding_pixels = get_surrounding_pixels(i, j, input_grid)\n            if surroding_pixels != [black] * 9 and input_grid[i, j] not in surroding_pixels and (not flag):\n                flag = True\n                special_pixels = (i, j)\n    input_grid = change_special_pixel_color(input_grid, special_pixels)\n    output_grid = extract_3x3_grid(input_grid, special_pixels)\n    return output_grid"},
{"name": "4347f46a.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 7, 7, 7, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 7, 7, 7, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 7, 7, 7, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 7, 7, 7, 0], [0, 0, 6, 0, 0, 0, 0, 0, 6, 0, 0, 0, 7, 0, 7, 0], [0, 0, 6, 0, 0, 0, 0, 0, 6, 0, 0, 0, 7, 0, 7, 0], [0, 0, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 7, 0, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 0], [0, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 2, 2, 2, 0], [0, 2, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 2, 0], [0, 2, 2, 2, 2, 2, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 6, 0, 0, 6, 0, 0, 0, 0], [0, 8, 8, 8, 8, 8, 8, 0, 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 4, 0, 0, 0, 0, 4, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 4, 4, 4, 4, 4, 4, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef check_surrounding_colors(input_grid: np.ndarray, i: int, j: int) -> int:\n    current_color = input_grid[i][j]\n    if current_color == black:\n        return current_color\n    else:\n        surrounding_colors = []\n        if i > 0:\n            surrounding_colors.append(input_grid[i - 1][j])\n        if i < input_grid.shape[0] - 1:\n            surrounding_colors.append(input_grid[i + 1][j])\n        if j > 0:\n            surrounding_colors.append(input_grid[i][j - 1])\n        if j < input_grid.shape[1] - 1:\n            surrounding_colors.append(input_grid[i][j + 1])\n        if all((color == current_color for color in surrounding_colors)):\n            return black\n        else:\n            return current_color\n\ndef new_function(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            output_grid[i][j] = check_surrounding_colors(input_grid, i, j)\n    return output_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = new_function(input_grid)\n    return output_grid"},
{"name": "8be77c9e.json", "data": {"train": [{"input": [[1, 1, 0], [1, 1, 1], [0, 0, 0]], "output": [[1, 1, 0], [1, 1, 1], [0, 0, 0], [0, 0, 0], [1, 1, 1], [1, 1, 0]]}, {"input": [[0, 0, 0], [1, 0, 1], [1, 1, 0]], "output": [[0, 0, 0], [1, 0, 1], [1, 1, 0], [1, 1, 0], [1, 0, 1], [0, 0, 0]]}, {"input": [[0, 0, 0], [0, 0, 1], [0, 0, 1]], "output": [[0, 0, 0], [0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 0]]}], "test": [{"input": [[0, 0, 0], [0, 0, 1], [1, 0, 0]], "output": [[0, 0, 0], [0, 0, 1], [1, 0, 0], [1, 0, 0], [0, 0, 1], [0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef assign_input_to_bottom_half(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    output_grid[3:, :] = input_grid\n    return output_grid\n\ndef flip_input_grid(input_grid: np.ndarray) -> np.ndarray:\n    return np.flipud(input_grid)\n\ndef assign_input_to_top_half(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    output_grid[:3, :] = input_grid\n    return output_grid\n\ndef create_image_matrix() -> np.ndarray:\n    return np.zeros((6, 3))\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = create_image_matrix()\n    output_grid = assign_input_to_top_half(output_grid, input_grid)\n    input_grid = flip_input_grid(input_grid)\n    output_grid = assign_input_to_bottom_half(output_grid, input_grid)\n    return output_grid"},
{"name": "3ac3eb23.json", "data": {"train": [{"input": [[0, 2, 0, 0, 0, 8, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 2, 0, 0, 0, 8, 0, 0, 0, 0], [2, 0, 2, 0, 8, 0, 8, 0, 0, 0], [0, 2, 0, 0, 0, 8, 0, 0, 0, 0], [2, 0, 2, 0, 8, 0, 8, 0, 0, 0], [0, 2, 0, 0, 0, 8, 0, 0, 0, 0], [2, 0, 2, 0, 8, 0, 8, 0, 0, 0]]}, {"input": [[0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], "output": [[0, 4, 0, 0, 0, 0, 0], [4, 0, 4, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 0], [4, 0, 4, 0, 0, 0, 0], [0, 4, 0, 0, 0, 0, 0], [4, 0, 4, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 3, 0, 0, 0, 6, 0, 0, 7, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 3, 0, 0, 0, 6, 0, 0, 7, 0, 0], [0, 3, 0, 3, 0, 6, 0, 6, 7, 0, 7, 0], [0, 0, 3, 0, 0, 0, 6, 0, 0, 7, 0, 0], [0, 3, 0, 3, 0, 6, 0, 6, 7, 0, 7, 0], [0, 0, 3, 0, 0, 0, 6, 0, 0, 7, 0, 0], [0, 3, 0, 3, 0, 6, 0, 6, 7, 0, 7, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef paint_same_color_as_toppest(input_grid: np.ndarray, i: int, j: int) -> np.ndarray:\n    top_color = input_grid[0][j]\n    input_grid[i][j] = top_color\n    return input_grid\n\ndef is_even_rows(input_grid: np.ndarray, i: int) -> bool:\n    return i % 2 == 0\n\ndef paint_adjacent_points(input_grid: np.ndarray, i: int, j: int) -> np.ndarray:\n    top_color = input_grid[0][j]\n    input_grid[i][j - 1] = top_color\n    input_grid[i][j + 1] = top_color\n    return input_grid\n\ndef is_odd_rows(input_grid: np.ndarray, i: int) -> bool:\n    return i % 2 != 0\n\ndef is_not_black(input_grid: np.ndarray, i: int, j: int) -> bool:\n    return input_grid[i][j] != black\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    for j in range(input_grid.shape[1]):\n        if is_not_black(input_grid, 0, j):\n            for i in range(1, input_grid.shape[0]):\n                if is_odd_rows(input_grid, i):\n                    input_grid = paint_adjacent_points(input_grid, i, j)\n                if is_even_rows(input_grid, i):\n                    input_grid = paint_same_color_as_toppest(input_grid, i, j)\n    return input_grid"},
{"name": "0520fde7.json", "data": {"train": [{"input": [[1, 0, 0, 5, 0, 1, 0], [0, 1, 0, 5, 1, 1, 1], [1, 0, 0, 5, 0, 0, 0]], "output": [[0, 0, 0], [0, 2, 0], [0, 0, 0]]}, {"input": [[1, 1, 0, 5, 0, 1, 0], [0, 0, 1, 5, 1, 1, 1], [1, 1, 0, 5, 0, 1, 0]], "output": [[0, 2, 0], [0, 0, 2], [0, 2, 0]]}, {"input": [[0, 0, 1, 5, 0, 0, 0], [1, 1, 0, 5, 1, 0, 1], [0, 1, 1, 5, 1, 0, 1]], "output": [[0, 0, 0], [2, 0, 0], [0, 0, 2]]}], "test": [{"input": [[1, 0, 1, 5, 1, 0, 1], [0, 1, 0, 5, 1, 0, 1], [1, 0, 1, 5, 0, 1, 0]], "output": [[2, 0, 2], [0, 0, 0], [0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef set_to_2(grid: np.ndarray, x: int, y: int) -> np.ndarray:\n    grid[x][y] = 2\n    return grid\n\ndef both_equal(a: int, b: int, num: int) -> bool:\n    return a == b == num\n\ndef samepixels(outleft, outright):\n    out = np.zeros((3, 3), dtype=int)\n    for i in range(0, outleft.shape[0]):\n        for j in range(0, outleft.shape[1]):\n            if both_equal(a=outleft[i][j], b=outright[i][j], num=1):\n                out = set_to_2(out, x=i, y=j)\n    return out\n\ndef extract_middle_grid(grid: np.ndarray) -> np.ndarray:\n    return grid[:, 4:7]\n\ndef extract_left_grid(grid: np.ndarray) -> np.ndarray:\n    return grid[:, :3]\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    outleft = np.zeros((3, 3), dtype=int)\n    outright = np.zeros((3, 3), dtype=int)\n    outleft = extract_left_grid(input_grid)\n    outright = extract_middle_grid(input_grid)\n    out = np.zeros((3, 3), dtype=int)\n    out = samepixels(outleft, outright)\n    return out"},
{"name": "a416b8f3.json", "data": {"train": [{"input": [[0, 5, 0], [5, 5, 2], [0, 0, 0]], "output": [[0, 5, 0, 0, 5, 0], [5, 5, 2, 5, 5, 2], [0, 0, 0, 0, 0, 0]]}, {"input": [[3, 0, 0], [2, 3, 0], [2, 1, 8], [0, 1, 0]], "output": [[3, 0, 0, 3, 0, 0], [2, 3, 0, 2, 3, 0], [2, 1, 8, 2, 1, 8], [0, 1, 0, 0, 1, 0]]}, {"input": [[5, 2, 3, 0], [2, 5, 3, 0], [5, 2, 8, 8], [0, 0, 6, 0]], "output": [[5, 2, 3, 0, 5, 2, 3, 0], [2, 5, 3, 0, 2, 5, 3, 0], [5, 2, 8, 8, 5, 2, 8, 8], [0, 0, 6, 0, 0, 0, 6, 0]]}], "test": [{"input": [[4, 0, 0, 0], [4, 5, 0, 0], [0, 5, 6, 0], [6, 6, 1, 0], [0, 0, 0, 1]], "output": [[4, 0, 0, 0, 4, 0, 0, 0], [4, 5, 0, 0, 4, 5, 0, 0], [0, 5, 6, 0, 0, 5, 6, 0], [6, 6, 1, 0, 6, 6, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef double_size_shape1(input_grid: np.ndarray) -> np.ndarray:\n    out = np.concatenate((input_grid, input_grid), axis=1)\n    return out\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    out = double_size_shape1(input_grid)\n    return out"},
{"name": "fcb5c309.json", "data": {"train": [{"input": [[0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 4], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 2, 2], [2, 4, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 2], [2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 2], [2, 0, 0, 0, 4, 0, 2, 0, 0, 0, 2, 2, 2], [2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0]], "output": [[4, 4, 4, 4, 4, 4, 4], [4, 0, 0, 0, 0, 0, 4], [4, 4, 0, 0, 0, 0, 4], [4, 0, 0, 0, 0, 0, 4], [4, 0, 0, 0, 4, 0, 4], [4, 0, 0, 0, 0, 0, 4], [4, 4, 4, 4, 4, 4, 4]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 0, 1, 0], [0, 3, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 3, 0, 1, 3, 0, 3, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [3, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 3, 0, 0, 0, 0], [3, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 3, 0, 0, 0, 0]], "output": [[3, 3, 3, 3, 3, 3, 3], [3, 0, 0, 3, 0, 0, 3], [3, 0, 0, 0, 0, 0, 3], [3, 3, 0, 3, 0, 0, 3], [3, 0, 0, 0, 0, 0, 3], [3, 3, 3, 3, 3, 3, 3]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 2, 0, 0, 0, 0, 0], [0, 3, 0, 2, 0, 2, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 3, 0, 0, 3, 3, 3, 3, 0, 0], [0, 3, 0, 0, 0, 0, 0, 3, 2, 0, 3, 0, 2, 3, 0, 0], [0, 3, 0, 2, 0, 0, 0, 3, 0, 0, 3, 0, 0, 3, 0, 0], [0, 3, 0, 0, 0, 0, 2, 3, 0, 0, 3, 0, 0, 3, 0, 0], [0, 3, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 3, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 3, 3, 3, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 2, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0]], "output": [[2, 2, 2, 2, 2, 2, 2], [2, 0, 2, 0, 2, 0, 2], [2, 0, 0, 0, 0, 0, 2], [2, 0, 0, 0, 0, 0, 2], [2, 0, 2, 0, 0, 0, 2], [2, 0, 0, 0, 0, 2, 2], [2, 2, 2, 2, 2, 2, 2]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 8, 0, 8, 0, 0, 1, 8, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 8, 0, 8, 0, 0], [1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 8, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 8, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8], [0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 8, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 1, 8, 0, 8, 0, 1, 0], [0, 0, 0, 8, 8, 0, 0, 8, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 8]], "output": [[8, 8, 8, 8, 8, 8, 8, 8], [8, 0, 8, 0, 8, 0, 0, 8], [8, 0, 0, 0, 0, 0, 0, 8], [8, 0, 0, 0, 0, 0, 0, 8], [8, 0, 0, 0, 0, 0, 0, 8], [8, 0, 8, 0, 0, 0, 0, 8], [8, 0, 0, 0, 0, 8, 0, 8], [8, 8, 8, 8, 8, 8, 8, 8]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_non_black(input: np.ndarray, color: int) -> np.ndarray:\n    \"\"\"\n    Given a 2D numpy array and a color, this function colors all the positions in the input array which is not black with the color.\n    \"\"\"\n    input[input != black] = color\n    return input\n\ndef find_middle_color(input: np.ndarray) -> int:\n    \"\"\"\n    Given a 2D numpy array representing a grid of colors, this function finds the color which is not black inside of input.\n    It eliminates the outermost circle and returns the color of the remaining cells.\n    \"\"\"\n    inner_input = input[1:-1, 1:-1]\n    unique_colors = np.unique(inner_input[inner_input != black])\n    if len(unique_colors) == 1:\n        return unique_colors[0]\n    else:\n        return black\n\ndef clip_rectangle(input: List[List[int]], rectangle: Tuple[Tuple[int, int], Tuple[int, int]]) -> np.ndarray:\n    \"\"\"\n    Given a 2D list of integers representing a grid of colors and a tuple representing the coordinates of the top-left and bottom-right corners of a rectangle,\n    this function clips the rectangle from the input and returns it as a numpy array.\n    \"\"\"\n    (x1, y1), (x2, y2) = rectangle\n    return np.array(input[x1:x2 + 1, y1:y2 + 1])\n\ndef find_max_rectangle(hollow_rectangles: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\"\n    Given a list of tuples representing the coordinates of the top-left and bottom-right corners of hollow rectangles,\n    this function returns the maximum rectangle among them.\n    \"\"\"\n    max_area = 0\n    max_rectangle = None\n    for rectangle in hollow_rectangles:\n        (x1, y1), (x2, y2) = rectangle\n        area = (x2 - x1 + 1) * (y2 - y1 + 1)\n        if area > max_area:\n            max_area = area\n            max_rectangle = rectangle\n    return max_rectangle\n\ndef find_hollow_rectangles(input: List[List[int]]) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n    \"\"\"\n    Given a 2D list of integers representing a grid of colors, this function finds all the hollow rectangles in the grid.\n    A hollow rectangle is defined as a rectangle with non-black cells on the border and black cells in the interior.\n    The function returns a list of tuples, where each tuple represents the coordinates of the top-left and bottom-right corners of a hollow rectangle.\n    \"\"\"\n    hollow_rectangles = []\n    rows, cols = (len(input), len(input[0]))\n    for i in range(rows):\n        for j in range(cols):\n            if input[i][j] != black:\n                if (i == 0 or input[i - 1][j] == black) and (j == 0 or input[i][j - 1] == black):\n                    k = j\n                    while k < cols and input[i][k] != black:\n                        k += 1\n                    l = i\n                    while l < rows and input[l][j] != black:\n                        l += 1\n                    hollow_rectangles.append(((i, j), (l - 1, k - 1)))\n    return hollow_rectangles\n\ndef transform_grid(input):\n    hollow_rectangles = find_hollow_rectangles(input)\n    max_hollow_rectangle = find_max_rectangle(hollow_rectangles)\n    output = clip_rectangle(input, max_hollow_rectangle)\n    color = find_middle_color(output)\n    output = color_non_black(output, color)\n    return output"},
{"name": "ba26e723.json", "data": {"train": [{"input": [[4, 0, 4, 0, 4, 0, 4, 0, 4, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 4, 0, 4, 0, 4, 0, 4, 0, 4]], "output": [[6, 0, 4, 0, 4, 0, 6, 0, 4, 0], [6, 4, 4, 6, 4, 4, 6, 4, 4, 6], [0, 4, 0, 6, 0, 4, 0, 4, 0, 6]]}, {"input": [[0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4]], "output": [[0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0], [6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4], [6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4]]}, {"input": [[4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0]], "output": [[6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4], [6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4], [0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0]]}, {"input": [[4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0]], "output": [[6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4, 0, 6], [6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4, 4, 6], [0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0, 4, 0]]}, {"input": [[0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0]], "output": [[0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4], [6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4], [6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0]]}], "test": [{"input": [[0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0], [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4], [4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4, 0, 4]], "output": [[0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0], [6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4, 4, 6, 4], [6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4, 0, 6, 0, 4, 0, 4]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    color the yellow pixels that in the column that can mod 3 to pink.\n    \"\"\"\n    output_grid = input_grid.copy()\n    for col in range(input_grid.shape[1]):\n        for row in range(input_grid.shape[0]):\n            if col % 3 == 0:\n                if output_grid[row, col] == yellow:\n                    output_grid[row, col] = pink\n    return output_grid"},
{"name": "95990924.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 4, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0], [0, 0, 3, 0, 0, 4, 0, 0, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 4, 0, 1, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0], [3, 0, 0, 4, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0, 1, 0, 0, 2], [0, 0, 0, 0, 3, 0, 0, 4, 0, 0, 0, 0, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4], [0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0], [0, 0, 5, 5, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 3, 0, 0, 4, 0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef draw_pixel(grid: np.ndarray, coordinate):\n    x, y = coordinate\n    grid[x - 1][y - 1] = blue\n    grid[x - 1][y + 2] = red\n    grid[x + 2][y - 1] = green\n    grid[x + 2][y + 2] = yellow\n\ndef find_grey_squares(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    coordinates = []\n    for i in range(input_grid.shape[0] - 1):\n        for j in range(input_grid.shape[1] - 1):\n            if input_grid[i][j] == grey and input_grid[i][j + 1] == grey and (input_grid[i + 1][j] == grey) and (input_grid[i + 1][j + 1] == grey):\n                coordinates.append((i, j))\n    return coordinates\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    coordinates = find_grey_squares(input_grid)\n    for coordinate in coordinates:\n        draw_pixel(input_grid, coordinate)\n    return input_grid"},
{"name": "f25fbde4.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 4, 4, 4, 4, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 0, 0], [4, 4, 4, 4, 4, 4, 4, 4], [4, 4, 4, 4, 4, 4, 4, 4], [0, 0, 4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0], [0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 4, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [4, 4, 4, 4, 0, 0], [4, 4, 4, 4, 0, 0], [0, 0, 0, 0, 4, 4], [0, 0, 0, 0, 4, 4]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 4, 0, 0, 0, 0, 0, 0], [0, 0, 4, 4, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [4, 4, 4, 4, 0, 0], [4, 4, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 4, 4], [0, 0, 4, 4, 4, 4]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 4, 0, 0], [0, 0, 0, 4, 0, 4, 0, 4, 0], [0, 0, 0, 0, 4, 0, 4, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 4, 4, 0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0, 4, 4, 0, 0], [4, 4, 0, 0, 4, 4, 0, 0, 4, 4], [4, 4, 0, 0, 4, 4, 0, 0, 4, 4], [0, 0, 4, 4, 0, 0, 4, 4, 0, 0], [0, 0, 4, 4, 0, 0, 4, 4, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef expand_blocks(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a 2D numpy array representing a grid of colored blocks, this function expands each block in the grid to a\n    square of four blocks.\n\n    Args:\n    - input_grid (np.ndarray): a 2D numpy array representing a grid of colored blocks, where each element is an integer\n                               representing a color\n\n    Returns:\n    - np.ndarray: a 2D numpy array representing the expanded grid, where each element is an integer representing a color\n    \"\"\"\n    output = np.repeat(np.repeat(input_grid, 2, axis=1), 2, axis=0)\n    return output\n\ndef find_smallest_rectangle(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Given a 2D numpy array representing a grid of colored blocks, this function finds the smallest rectangle that can\n    contain all the yellow blocks in the grid.\n\n    Args:\n    - input_grid (np.ndarray): a 2D numpy array representing a grid of colored blocks, where each element is an integer\n                               representing a color\n\n    Returns:\n    - np.ndarray: a 2D numpy array representing the smallest rectangle that can contain all the yellow blocks in the grid,\n                  where each element is an integer representing a color\n    \"\"\"\n    yellow_indices = np.where(input_grid == yellow)\n    min_row, max_row = (np.min(yellow_indices[0]), np.max(yellow_indices[0]))\n    min_col, max_col = (np.min(yellow_indices[1]), np.max(yellow_indices[1]))\n    output = input_grid[min_row:max_row + 1, min_col:max_col + 1]\n    return output\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output = find_smallest_rectangle(input_grid)\n    output = expand_blocks(output)\n    return output"},
{"name": "ce4f8723.json", "data": {"train": [{"input": [[1, 1, 0, 0], [0, 1, 0, 1], [0, 1, 0, 0], [1, 0, 1, 0], [4, 4, 4, 4], [2, 2, 2, 2], [0, 0, 2, 2], [2, 2, 0, 0], [0, 0, 2, 2]], "output": [[3, 3, 3, 3], [0, 3, 3, 3], [3, 3, 0, 0], [3, 0, 3, 3]]}, {"input": [[1, 1, 1, 0], [0, 1, 0, 1], [0, 0, 1, 1], [1, 1, 0, 1], [4, 4, 4, 4], [0, 0, 0, 2], [0, 0, 0, 2], [2, 2, 2, 2], [2, 2, 0, 2]], "output": [[3, 3, 3, 3], [0, 3, 0, 3], [3, 3, 3, 3], [3, 3, 0, 3]]}, {"input": [[1, 1, 0, 0], [1, 0, 1, 0], [1, 1, 0, 1], [1, 1, 1, 1], [4, 4, 4, 4], [2, 2, 0, 2], [0, 0, 2, 0], [0, 2, 0, 0], [2, 0, 2, 0]], "output": [[3, 3, 0, 3], [3, 0, 3, 0], [3, 3, 0, 3], [3, 3, 3, 3]]}, {"input": [[1, 0, 1, 0], [1, 1, 0, 1], [1, 0, 1, 1], [0, 1, 0, 1], [4, 4, 4, 4], [2, 2, 0, 0], [0, 0, 2, 0], [2, 2, 0, 0], [0, 0, 2, 0]], "output": [[3, 3, 3, 0], [3, 3, 3, 3], [3, 3, 3, 3], [0, 3, 3, 3]]}], "test": [{"input": [[1, 0, 1, 0], [1, 0, 1, 0], [0, 1, 0, 0], [1, 0, 1, 0], [4, 4, 4, 4], [2, 2, 0, 0], [0, 0, 2, 0], [0, 2, 0, 2], [2, 2, 2, 0]], "output": [[3, 3, 3, 0], [3, 0, 3, 0], [0, 3, 0, 3], [3, 3, 3, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_pixels(input_grid: np.ndarray, mindex: int, ngrid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Traverse all pixels in the inputgrid whose line number is less than mindex, if the value of the pixel is black and t\n    \"\"\"\n    for i in range(mindex):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == black and input_grid[min(i + mindex + 1, input_grid.shape[0] - 1)][j] == black:\n                ngrid[i][j] = black\n            else:\n                ngrid[i][j] = green\n    return ngrid\n\ndef find_yellow_line_index(input_grid: np.ndarray) -> int:\n    \"\"\"\n    This function takes in a numpy array of shape (n,m) and returns the index of the first row that contains a yellow pixel.\n    \"\"\"\n    for i in range(input_grid.shape[0]):\n        if yellow in input_grid[i]:\n            return i\n    return -1\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*m grid with multiple color pixels.\n    \"\"\"\n    mindex = find_yellow_line_index(input_grid)\n    ngrid = np.zeros((input_grid.shape[0] // 2, input_grid.shape[1]))\n    ans_grid = color_pixels(input_grid, mindex, ngrid)\n    return ans_grid"},
{"name": "a61ba2ce.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[8, 8, 2, 2], [8, 0, 0, 2], [3, 0, 0, 1], [3, 3, 1, 1]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[1, 1, 8, 8], [1, 0, 0, 8], [4, 0, 0, 2], [4, 4, 2, 2]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 8, 8, 0], [0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 8, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3, 3, 8, 8], [3, 0, 0, 8], [1, 0, 0, 6], [1, 1, 6, 6]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_input_points_to_input_color(output_grid: np.ndarray, color: int, points: List[Tuple[int, int]]) -> np.ndarray:\n    for point in points:\n        output_grid[point[0]][point[1]] = color\n    return output_grid\n\ndef find_color_of_non_black_square_on_lower_right(input_grid: np.ndarray) -> int:\n    for i in range(input_grid.shape[0] - 1):\n        for j in range(input_grid.shape[1] - 1):\n            if input_grid[i][j] == black and input_grid[i + 1][j] != black and (input_grid[i][j + 1] != black):\n                return input_grid[i + 1][j + 1]\n    return -1\n\ndef find_non_black_square_on_lower_left(input_grid: np.ndarray) -> int:\n    for i in range(input_grid.shape[0] - 1):\n        for j in range(input_grid.shape[1] - 1):\n            if input_grid[i][j] == black and input_grid[i + 1][j] != black and (input_grid[i][j - 1] != black):\n                return input_grid[i][j - 1]\n    return -1\n\ndef find_non_black_square_on_upper_right(input_grid: np.ndarray) -> int:\n    for i in range(1, input_grid.shape[0]):\n        for j in range(1, input_grid.shape[1]):\n            if input_grid[i][j] == black and input_grid[i - 1][j] != black and (input_grid[i][j + 1] != black):\n                return input_grid[i][j + 1]\n    return -1\n\ndef find_color(input_grid: np.ndarray) -> int:\n    for i in range(1, input_grid.shape[0]):\n        for j in range(1, input_grid.shape[1]):\n            if input_grid[i][j] == black and input_grid[i - 1][j] != black and (input_grid[i][j - 1] != black):\n                return input_grid[i][j - 1]\n    return -1\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    color1 = find_color(input_grid)\n    color2 = find_non_black_square_on_upper_right(input_grid)\n    color3 = find_non_black_square_on_lower_left(input_grid)\n    color4 = find_color_of_non_black_square_on_lower_right(input_grid)\n    output_grid = np.zeros((4, 4), dtype=int)\n    output_grid = change_input_points_to_input_color(output_grid, color1, [(0, 0), (0, 1), (1, 0)])\n    output_grid = change_input_points_to_input_color(output_grid, color2, [(0, 2), (0, 3), (1, 3)])\n    output_grid = change_input_points_to_input_color(output_grid, color3, [(2, 0), (3, 0), (3, 1)])\n    output_grid = change_input_points_to_input_color(output_grid, color4, [(2, 3), (3, 2), (3, 3)])\n    return output_grid"},
{"name": "178fcbfb.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 2, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 2, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0], [3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 0, 2, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0]], "output": [[0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0]]}], "test": [{"input": [[0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0], [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef draw_blue_horizontal_lines(input_grid: np.ndarray, blue_loc: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    This function takes an input grid and the location of all blue pixels in the grid and draws horizontal blue lines\n    passing through each blue pixel.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    blue_loc: A tuple containing the row and column indices of all blue pixels in the grid.\n\n    Returns:\n    A numpy array representing the output grid with horizontal blue lines passing through each blue pixel.\n    \"\"\"\n    for i in range(len(blue_loc[0])):\n        input_grid[blue_loc[0][i], :] = blue\n    return input_grid\n\ndef draw_green_horizontal_lines(input_grid: np.ndarray, green_loc: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    This function takes an input grid and the location of all green pixels in the grid and draws horizontal green lines\n    passing through each green pixel.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    green_loc: A tuple containing the row and column indices of all green pixels in the grid.\n\n    Returns:\n    A numpy array representing the output grid with horizontal green lines passing through each green pixel.\n    \"\"\"\n    for i in range(len(green_loc[0])):\n        input_grid[green_loc[0][i], :] = green\n    return input_grid\n\ndef draw_red_vertical_lines(input_grid: np.ndarray, red_loc: Tuple[int, int]) -> np.ndarray:\n    \"\"\"\n    This function takes an input grid and the location of all red pixels in the grid and draws vertical red lines\n    passing through each red pixel.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n    red_loc: A tuple containing the row and column indices of all red pixels in the grid.\n\n    Returns:\n    A numpy array representing the output grid with vertical red lines passing through each red pixel.\n    \"\"\"\n    for i in range(len(red_loc[0])):\n        input_grid[:, red_loc[1][i]] = red\n    return input_grid\n\ndef get_blue_pixels_location(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    This function takes an input grid and returns the location of all blue pixels in the grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A tuple containing the row and column indices of all blue pixels in the grid.\n    \"\"\"\n    return np.where(input_grid == blue)\n\ndef get_green_pixels_location(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    This function takes an input grid and returns the location of all green pixels in the grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A tuple containing the row and column indices of all green pixels in the grid.\n    \"\"\"\n    return np.where(input_grid == green)\n\ndef get_red_pixels_location(input_grid: np.ndarray) -> Tuple[int, int]:\n    \"\"\"\n    This function takes an input grid and returns the location of all red pixels in the grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A tuple containing the row and column indices of all red pixels in the grid.\n    \"\"\"\n    return np.where(input_grid == red)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    red_loc = get_red_pixels_location(input_grid)\n    green_loc = get_green_pixels_location(input_grid)\n    blue_loc = get_blue_pixels_location(input_grid)\n    out_grid = draw_red_vertical_lines(input_grid, red_loc)\n    out_grid = draw_green_horizontal_lines(out_grid, green_loc)\n    out_grid = draw_blue_horizontal_lines(out_grid, blue_loc)\n    return out_grid"},
{"name": "80af3007.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[5, 0, 5, 0, 0, 0, 5, 0, 5], [0, 5, 0, 0, 0, 0, 0, 5, 0], [5, 0, 5, 0, 0, 0, 5, 0, 5], [0, 0, 0, 5, 0, 5, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 5, 0, 5, 0, 0, 0], [5, 0, 5, 0, 0, 0, 5, 0, 5], [0, 5, 0, 0, 0, 0, 0, 5, 0], [5, 0, 5, 0, 0, 0, 5, 0, 5]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[5, 5, 0, 5, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 5, 0, 0, 0], [5, 5, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5], [0, 0, 0, 0, 0, 0, 5, 5, 0], [5, 5, 0, 5, 5, 0, 0, 0, 0], [0, 0, 5, 0, 0, 5, 0, 0, 0], [5, 5, 0, 5, 5, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 5, 5, 0, 5, 5, 0, 5, 5], [5, 0, 5, 5, 0, 5, 5, 0, 5], [0, 0, 0, 5, 5, 5, 5, 5, 5], [0, 0, 0, 0, 5, 5, 0, 5, 5], [0, 0, 0, 5, 0, 5, 5, 0, 5], [5, 5, 5, 0, 0, 0, 5, 5, 5], [0, 5, 5, 0, 0, 0, 0, 5, 5], [5, 0, 5, 0, 0, 0, 5, 0, 5]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[5, 5, 5, 5, 5, 5, 5, 5, 5], [0, 5, 0, 0, 5, 0, 0, 5, 0], [5, 0, 5, 5, 0, 5, 5, 0, 5], [0, 0, 0, 5, 5, 5, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 5, 0, 5, 0, 0, 0], [5, 5, 5, 0, 0, 0, 5, 5, 5], [0, 5, 0, 0, 0, 0, 0, 5, 0], [5, 0, 5, 0, 0, 0, 5, 0, 5]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef make_black_subgrid_black(input_grid: np.ndarray, output_grid: np.ndarray, rows_of_pattern: List[int], cols_of_pattern: List[int]) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    This function takes in a 9x9 numpy array representing the input grid, a 9x9 numpy array representing the output grid, a list of row indices that contain more than t\n    It returns a 9x9 numpy array representing the output grid with the sub grid of the 9x9 pattern that is all black set to black.                                      \n                                                                                                                                                                        \n    Args:                                                                                                                                                               \n    input_grid: A 9x9 numpy array representing the input grid.                                                                                                          \n    output_grid: A 9x9 numpy array representing the output grid.                                                                                                        \n    rows_of_pattern: A list of row indices that contain more than three grey pixels.                                                                                    \n    cols_of_pattern: A list of column indices that contain more than three grey pixels.                                                                                 \n                                                                                                                                                                        \n    Returns:                                                                                                                                                            \n    A 9x9 numpy array representing the output grid with the sub grid of the 9x9 pattern that is all black set to black.                                                 \n    \"\"\"\n    rows_of_pattern_start = rows_of_pattern[0]\n    cols_of_pattern_start = cols_of_pattern[0]\n    for i in range(3):\n        for j in range(3):\n            sub_grid = input_grid[i * 3 + rows_of_pattern_start:i * 3 + 3 + rows_of_pattern_start, j * 3 + cols_of_pattern_start:j * 3 + 3 + cols_of_pattern_start]\n            if np.all(sub_grid == black):\n                output_grid[i * 3:i * 3 + 3, j * 3:j * 3 + 3] = black\n    return output_grid\n\ndef replicate_small_grid(small_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes in a 3x3 numpy array representing the small grid and replicates it 3 times in row and 3 times in column.\n    \n    Args:\n    small_grid: A 3x3 numpy array representing the small grid.\n    \n    Returns:\n    A 9x9 numpy array representing the replicated small grid.\n    \"\"\"\n    replicated_grid = np.zeros((9, 9))\n    for i in range(3):\n        for j in range(3):\n            replicated_grid[i * 3:i * 3 + 3, j * 3:j * 3 + 3] = small_grid\n    return replicated_grid\n\ndef make_small_grid(input_grid: np.ndarray, rows_of_pattern: List[int], cols_of_pattern: List[int]) -> np.ndarray:\n    \"\"\"\n    This function takes in a 9x9 numpy array, a list of row indices that contain more than three grey pixels, and a list of column indices that contain more than three grey pixels.\n    It returns a 3x3 numpy array representing the small grid according to the pattern.\n    \n    Args:\n    input_grid: A 9x9 numpy array representing the input grid.\n    rows_of_pattern: A list of row indices that contain more than three grey pixels.\n    cols_of_pattern: A list of column indices that contain more than three grey pixels.\n    \n    Returns:\n    A 3x3 numpy array representing the small grid according to the pattern.\n    \"\"\"\n    small_grid = np.zeros((3, 3))\n    for i in range(3):\n        for j in range(3):\n            sub_grid = input_grid[rows_of_pattern[i * 3:i * 3 + 3], cols_of_pattern[j * 3:j * 3 + 3]]\n            if np.all(sub_grid == black):\n                small_grid[i][j] = black\n            elif np.all(sub_grid == grey):\n                small_grid[i][j] = grey\n    return small_grid\n\ndef get_cols_with_grey_pixels(input_grid: np.ndarray) -> List[int]:\n    \"\"\"                                                                                                                                                                 \n    This function takes in a 9x9 numpy array and returns a list of column indices that contain more than three grey pixels.                                             \n                                                                                                                                                                        \n    Args:                                                                                                                                                               \n    input_grid: A 9x9 numpy array representing the input grid.                                                                                                          \n                                                                                                                                                                        \n    Returns:                                                                                                                                                            \n    A list of column indices that contain more than three grey pixels.                                                                                                  \n    \"\"\"\n    cols_with_grey_pixels = []\n    for i in range(input_grid.shape[1]):\n        if np.count_nonzero(input_grid[:, i] == grey) >= 3:\n            cols_with_grey_pixels.append(i)\n    return cols_with_grey_pixels\n\ndef get_rows_with_grey_pixels(input_grid: np.ndarray) -> List[int]:\n    \"\"\"                                                                                                                                                                 \n    This function takes in a 9x9 numpy array and returns a list of row indices that contain more than three grey pixels.                                                \n                                                                                                                                                                        \n    Args:                                                                                                                                                               \n    input_grid: A 9x9 numpy array representing the input grid.                                                                                                          \n                                                                                                                                                                        \n    Returns:                                                                                                                                                            \n    A list of row indices that contain more than three grey pixels.                                                                                                     \n    \"\"\"\n    rows_with_grey_pixels = []\n    for i in range(input_grid.shape[0]):\n        if np.count_nonzero(input_grid[i] == grey) >= 3:\n            rows_with_grey_pixels.append(i)\n    return rows_with_grey_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"                                                                                                                                                                 \n    In the input, you should see a 9x9 pattern on the black background.                                                                                                 \n    The output grid is 9x9.                                                                                                                                             \n    To make the output, you should first get the pattern from the input grid, each row of the pattern contains at least three grey pixels, and each column of the patter\n    then make a 3x3 grid according to the 9x9 pattern, to do this, divide the 9x9 pattern into nine 3x3 sub grid, if a 3x3 sub grid of the pattern are all black, make t\n    if it is all grey, make the corresponding pixel of the make grid grey.grey                                                                                          \n    Then replicate the make grid nine times on the output.                                                                                                              \n    Finally, if the sub grid of the 9x9 pattern is all black, make the correspoinding position of the output grid all black.                                            \n    \"\"\"\n    rows_of_pattern = get_rows_with_grey_pixels(input_grid)\n    cols_of_pattern = get_cols_with_grey_pixels(input_grid)\n    small_grid = np.zeros((3, 3))\n    output_grid = np.zeros((9, 9))\n    small_grid = make_small_grid(input_grid, rows_of_pattern, cols_of_pattern)\n    output_grid = replicate_small_grid(small_grid)\n    output_grid = make_black_subgrid_black(input_grid, output_grid, rows_of_pattern, cols_of_pattern)\n    return output_grid"},
{"name": "88a10436.json", "data": {"train": [{"input": [[0, 2, 0, 0, 0, 0, 0, 0, 0], [2, 2, 1, 0, 0, 0, 0, 0, 0], [0, 1, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 2, 0, 0, 0, 0, 0, 0, 0], [2, 2, 1, 0, 0, 0, 0, 0, 0], [0, 1, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 2, 0, 0, 0], [0, 0, 0, 0, 2, 2, 1, 0, 0], [0, 0, 0, 0, 0, 1, 3, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 6, 0, 0], [0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 2, 2, 2], [0, 0, 0, 0, 0, 0, 0], [6, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0], [2, 2, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0], [0, 0, 3, 1, 0, 0, 0, 0], [0, 3, 3, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 3, 1, 0, 0], [0, 0, 0, 3, 3, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 2, 2, 0, 0, 0, 0, 0], [0, 0, 3, 1, 0, 0, 0, 0], [0, 3, 3, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef copy_area_to_new_location(input_grid: np.ndarray, a: Tuple[int, int, int, int], n: List[Tuple[int, int]]) -> np.ndarray:\n    out = np.copy(input_grid)\n    for i, j in n:\n        out[i][j] = input_grid[a[0] + i - n[0][0]][a[2] + j - n[0][1]]\n    return out\n\ndef get_centered_3x3_area_index(x: int, y: int) -> List[Tuple[int, int]]:\n    return [(i, j) for i in range(x - 1, x + 2) for j in range(y - 1, y + 2)]\n\ndef find_grey_pixel(input_grid: np.ndarray) -> Tuple[int, int]:\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == grey:\n                return (i, j)\n\ndef find_grey_centered_3x3_area(a: Tuple[int, int, int, int], input_grid: np.ndarray) -> np.ndarray:\n    x, y = find_grey_pixel(input_grid)\n    n = get_centered_3x3_area_index(x, y)\n    out = copy_area_to_new_location(input_grid, a, n)\n    return out\n\ndef find_covering_area(input_grid: np.ndarray, p: List[Tuple[int, int]]) -> Tuple[int, int, int, int]:\n    min_i, min_j = input_grid.shape\n    max_i = max_j = 0\n    for i, j in p:\n        min_i = min(min_i, i)\n        max_i = max(max_i, i)\n        min_j = min(min_j, j)\n        max_j = max(max_j, j)\n    return (min_i, max_i + 1, min_j, max_j + 1)\n\ndef find_non_black_grey_pixels(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    non_black_grey_pixels = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] not in [black, grey]:\n                non_black_grey_pixels.append((i, j))\n    return non_black_grey_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    p = find_non_black_grey_pixels(input_grid)\n    a = find_covering_area(input_grid, p)\n    out = find_grey_centered_3x3_area(a, input_grid)\n    return out"},
{"name": "363442ee.json", "data": {"train": [{"input": [[4, 2, 2, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 6, 2, 5, 0, 1, 0, 0, 0, 0, 0, 0, 0], [6, 4, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[4, 2, 2, 5, 4, 2, 2, 0, 0, 0, 0, 0, 0], [2, 6, 2, 5, 2, 6, 2, 0, 0, 0, 0, 0, 0], [6, 4, 4, 5, 6, 4, 4, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 4, 2, 2, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 2, 6, 2, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 6, 4, 4, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 4, 2, 2, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 2, 6, 2, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 6, 4, 4, 0, 0, 0]]}, {"input": [[2, 7, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 3, 3, 5, 0, 0, 0, 0, 1, 0, 0, 0, 0], [3, 7, 7, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[2, 7, 3, 5, 0, 0, 0, 2, 7, 3, 0, 0, 0], [2, 3, 3, 5, 0, 0, 0, 2, 3, 3, 0, 0, 0], [3, 7, 7, 5, 0, 0, 0, 3, 7, 7, 0, 0, 0], [0, 0, 0, 5, 2, 7, 3, 0, 0, 0, 2, 7, 3], [0, 0, 0, 5, 2, 3, 3, 0, 0, 0, 2, 3, 3], [0, 0, 0, 5, 3, 7, 7, 0, 0, 0, 3, 7, 7], [0, 0, 0, 5, 2, 7, 3, 2, 7, 3, 0, 0, 0], [0, 0, 0, 5, 2, 3, 3, 2, 3, 3, 0, 0, 0], [0, 0, 0, 5, 3, 7, 7, 3, 7, 7, 0, 0, 0]]}, {"input": [[3, 8, 6, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [9, 8, 2, 5, 0, 1, 0, 0, 0, 0, 0, 1, 0], [9, 9, 9, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3, 8, 6, 5, 3, 8, 6, 0, 0, 0, 3, 8, 6], [9, 8, 2, 5, 9, 8, 2, 0, 0, 0, 9, 8, 2], [9, 9, 9, 5, 9, 9, 9, 0, 0, 0, 9, 9, 9], [0, 0, 0, 5, 0, 0, 0, 3, 8, 6, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 9, 8, 2, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 9, 9, 9, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 3, 8, 6, 3, 8, 6], [0, 0, 0, 5, 0, 0, 0, 9, 8, 2, 9, 8, 2], [0, 0, 0, 5, 0, 0, 0, 9, 9, 9, 9, 9, 9]]}], "test": [{"input": [[3, 3, 9, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [8, 4, 4, 5, 0, 0, 0, 0, 1, 0, 0, 1, 0], [8, 9, 8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3, 3, 9, 5, 0, 0, 0, 3, 3, 9, 3, 3, 9], [8, 4, 4, 5, 0, 0, 0, 8, 4, 4, 8, 4, 4], [8, 9, 8, 5, 0, 0, 0, 8, 9, 8, 8, 9, 8], [0, 0, 0, 5, 3, 3, 9, 0, 0, 0, 3, 3, 9], [0, 0, 0, 5, 8, 4, 4, 0, 0, 0, 8, 4, 4], [0, 0, 0, 5, 8, 9, 8, 0, 0, 0, 8, 9, 8], [0, 0, 0, 5, 3, 3, 9, 3, 3, 9, 0, 0, 0], [0, 0, 0, 5, 8, 4, 4, 8, 4, 4, 0, 0, 0], [0, 0, 0, 5, 8, 9, 8, 8, 9, 8, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef copy_block_to_blue_points(input_grid: np.ndarray, blue_points: List[Tuple[int, int]]) -> np.ndarray:\n    output_grid = np.copy(input_grid)\n    block = input_grid[:3, :3]\n    for point in blue_points:\n        i, j = point\n        output_grid[i - 1:i + 2, j - 1:j + 2] = block\n    return output_grid\n\ndef find_blue_points(input_grid: np.ndarray) -> List[Tuple[int, int]]:\n    blue_points = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == blue:\n                blue_points.append((i, j))\n    return blue_points\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    blue_points = find_blue_points(input_grid)\n    output_grid = copy_block_to_blue_points(input_grid, blue_points)\n    return output_grid"},
{"name": "8e5a5113.json", "data": {"train": [{"input": [[1, 1, 2, 5, 0, 0, 0, 5, 0, 0, 0], [4, 1, 1, 5, 0, 0, 0, 5, 0, 0, 0], [4, 4, 1, 5, 0, 0, 0, 5, 0, 0, 0]], "output": [[1, 1, 2, 5, 4, 4, 1, 5, 1, 4, 4], [4, 1, 1, 5, 4, 1, 1, 5, 1, 1, 4], [4, 4, 1, 5, 1, 1, 2, 5, 2, 1, 1]]}, {"input": [[6, 3, 3, 5, 0, 0, 0, 5, 0, 0, 0], [6, 3, 3, 5, 0, 0, 0, 5, 0, 0, 0], [6, 3, 2, 5, 0, 0, 0, 5, 0, 0, 0]], "output": [[6, 3, 3, 5, 6, 6, 6, 5, 2, 3, 6], [6, 3, 3, 5, 3, 3, 3, 5, 3, 3, 6], [6, 3, 2, 5, 2, 3, 3, 5, 3, 3, 6]]}, {"input": [[2, 7, 8, 5, 0, 0, 0, 5, 0, 0, 0], [7, 7, 8, 5, 0, 0, 0, 5, 0, 0, 0], [8, 8, 8, 5, 0, 0, 0, 5, 0, 0, 0]], "output": [[2, 7, 8, 5, 8, 7, 2, 5, 8, 8, 8], [7, 7, 8, 5, 8, 7, 7, 5, 8, 7, 7], [8, 8, 8, 5, 8, 8, 8, 5, 8, 7, 2]]}], "test": [{"input": [[3, 3, 9, 5, 0, 0, 0, 5, 0, 0, 0], [9, 9, 9, 5, 0, 0, 0, 5, 0, 0, 0], [2, 9, 9, 5, 0, 0, 0, 5, 0, 0, 0]], "output": [[3, 3, 9, 5, 2, 9, 3, 5, 9, 9, 2], [9, 9, 9, 5, 9, 9, 3, 5, 9, 9, 9], [2, 9, 9, 5, 9, 9, 9, 5, 9, 3, 3]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef cover_pattern(input_grid: np.ndarray, pattern_grid1: np.ndarray, pattern_grid2: np.ndarray) -> np.ndarray:\n    input_grid[0:3, 4:7] = pattern_grid1\n    input_grid[0:3, 8:11] = pattern_grid2\n    return input_grid\n\ndef rotate_grid_90(input_grid: np.ndarray) -> np.ndarray:\n    return np.rot90(input_grid, k=-1)\n\ndef extract_3x3_matrix(input_grid: np.ndarray) -> np.ndarray:\n    return input_grid[:3, :3]\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    pattern_grid = extract_3x3_matrix(input_grid)\n    pattern_grid1 = rotate_grid_90(pattern_grid)\n    pattern_grid2 = rotate_grid_90(pattern_grid1)\n    output_grid = cover_pattern(input_grid, pattern_grid1, pattern_grid2)\n    return output_grid"},
{"name": "2bee17df.json", "data": {"train": [{"input": [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [8, 0, 0, 0, 2, 2, 0, 2, 2, 2, 2, 2], [8, 0, 0, 0, 0, 2, 0, 0, 2, 2, 0, 2], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [8, 8, 0, 0, 0, 0, 8, 8, 0, 0, 0, 8], [8, 8, 8, 0, 0, 8, 8, 8, 0, 0, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]], "output": [[2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], [8, 0, 0, 3, 2, 2, 0, 2, 2, 2, 2, 2], [8, 0, 0, 3, 0, 2, 0, 0, 2, 2, 0, 2], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8], [8, 8, 0, 3, 0, 0, 8, 8, 0, 0, 0, 8], [8, 8, 8, 3, 0, 8, 8, 8, 0, 0, 8, 8], [8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]]}, {"input": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [2, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8], [2, 2, 0, 0, 0, 0, 0, 8, 8, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [2, 2, 0, 2, 0, 0, 2, 0, 0, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]], "output": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [2, 0, 0, 0, 3, 3, 8, 8, 8, 8, 8, 8], [2, 2, 0, 0, 3, 3, 0, 8, 8, 0, 0, 8], [2, 0, 0, 0, 3, 3, 0, 8, 0, 0, 0, 8], [2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8], [2, 2, 2, 0, 3, 3, 0, 0, 0, 0, 0, 8], [2, 2, 0, 0, 3, 3, 0, 0, 0, 0, 0, 8], [2, 2, 0, 0, 3, 3, 0, 0, 0, 0, 0, 8], [2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 8], [2, 0, 0, 0, 3, 3, 0, 0, 0, 0, 2, 2], [2, 2, 0, 2, 3, 3, 2, 0, 0, 2, 2, 2], [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]}, {"input": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 2], [8, 8, 8, 0, 8, 8, 0, 8, 0, 2], [8, 8, 0, 0, 8, 0, 0, 0, 0, 2], [8, 8, 0, 0, 0, 0, 0, 0, 2, 2], [8, 0, 0, 0, 0, 0, 0, 0, 2, 2], [8, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 0, 0, 0, 0, 0, 2, 2, 0, 2], [8, 2, 0, 0, 0, 2, 2, 2, 2, 2], [8, 2, 2, 2, 2, 2, 2, 2, 2, 2]], "output": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 2], [8, 8, 8, 3, 8, 8, 0, 8, 0, 2], [8, 8, 0, 3, 8, 0, 0, 0, 0, 2], [8, 8, 0, 3, 0, 0, 0, 0, 2, 2], [8, 0, 0, 3, 0, 0, 0, 0, 2, 2], [8, 3, 3, 3, 3, 3, 3, 3, 3, 2], [8, 3, 3, 3, 3, 3, 3, 3, 3, 2], [8, 0, 0, 3, 0, 0, 2, 2, 0, 2], [8, 2, 0, 3, 0, 2, 2, 2, 2, 2], [8, 2, 2, 2, 2, 2, 2, 2, 2, 2]]}], "test": [{"input": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 0, 0, 8, 8, 8, 0, 0, 8, 2, 2], [8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2], [8, 8, 0, 2, 0, 2, 2, 0, 0, 0, 0, 2, 2, 2], [8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]], "output": [[8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 3, 0, 8, 8, 8, 3, 3, 8, 2, 2], [8, 8, 8, 0, 3, 0, 0, 0, 0, 3, 3, 0, 0, 2], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2], [8, 8, 8, 0, 3, 0, 0, 0, 0, 3, 3, 0, 2, 2], [8, 8, 0, 0, 3, 0, 0, 0, 0, 3, 3, 2, 2, 2], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2], [8, 8, 0, 0, 3, 0, 0, 0, 0, 3, 3, 0, 0, 2], [8, 8, 0, 0, 3, 0, 0, 0, 0, 3, 3, 0, 0, 2], [8, 8, 0, 0, 3, 0, 0, 0, 0, 3, 3, 0, 0, 2], [8, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2], [8, 8, 0, 0, 3, 0, 0, 0, 0, 3, 3, 0, 2, 2], [8, 8, 0, 2, 3, 2, 2, 0, 0, 3, 3, 2, 2, 2], [8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef change_black_pixels_to_green_in_columns(column_indices: List[int], output_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes in a list of column indices and a numpy array as input and changes the black pixels in the specified columns to green.\n    \n    Args:\n    - column_indices: a list of column indices to change the black pixels to green\n    - output_grid: a numpy array representing the output grid\n    \n    Returns:\n    - A numpy array with the specified black pixels changed to green\n    \"\"\"\n    for column_index in column_indices:\n        output_grid[:, column_index][output_grid[:, column_index] == black] = green\n    return output_grid\n\ndef change_black_pixels_to_green_in_rows(row_indices: List[int], output_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    This function takes in a list of row indices and a numpy array as input and changes the black pixels in the specified rows to green.\n    \n    Args:\n    - row_indices: a list of row indices to change the black pixels to green\n    - output_grid: a numpy array representing the output grid\n    \n    Returns:\n    - A numpy array with the specified black pixels changed to green\n    \"\"\"\n    for row_index in row_indices:\n        output_grid[row_index][output_grid[row_index] == black] = green\n    return output_grid\n\ndef find_columns_with_most_black_pixels(input_grid: np.ndarray) -> List[int]:\n    \"\"\"\n    This function takes in a numpy array as input and returns a list of column indices that contain the most black pixels.\n    If there are multiple columns with the same number of black pixels, all of them are returned.\n    \n    Args:\n    - input_grid: a numpy array representing the input grid\n    \n    Returns:\n    - A list of column indices that contain the most black pixels\n    \"\"\"\n    column_sums = np.sum(input_grid == black, axis=0)\n    max_sum = np.max(column_sums)\n    return [i for i, sum in enumerate(column_sums) if sum == max_sum]\n\ndef find_rows_with_most_black_pixels(input_grid: np.ndarray) -> List[int]:\n    \"\"\"\n    This function takes in a numpy array as input and returns a list of row indices that contain the most black pixels.\n    If there are multiple rows with the same number of black pixels, all of them are returned.\n    \n    Args:\n    - input_grid: a numpy array representing the input grid\n    \n    Returns:\n    - A list of row indices that contain the most black pixels\n    \"\"\"\n    row_sums = np.sum(input_grid == black, axis=1)\n    max_sum = np.max(row_sums)\n    return [i for i, sum in enumerate(row_sums) if sum == max_sum]\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    row_indices = find_rows_with_most_black_pixels(input_grid)\n    column_indices = find_columns_with_most_black_pixels(input_grid)\n    output_grid = input_grid.copy()\n    output_grid = change_black_pixels_to_green_in_rows(row_indices, output_grid)\n    output_grid = change_black_pixels_to_green_in_columns(column_indices, output_grid)\n    return output_grid"},
{"name": "08ed6ac7.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 5, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 5, 0, 5, 0, 5, 0, 0, 0], [0, 5, 0, 5, 0, 5, 0, 0, 0], [0, 5, 0, 5, 0, 5, 0, 0, 0], [0, 5, 0, 5, 0, 5, 0, 5, 0], [0, 5, 0, 5, 0, 5, 0, 5, 0], [0, 5, 0, 5, 0, 5, 0, 5, 0]], "output": [[0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 2, 0, 0, 0, 1, 0, 0, 0], [0, 2, 0, 0, 0, 1, 0, 0, 0], [0, 2, 0, 3, 0, 1, 0, 0, 0], [0, 2, 0, 3, 0, 1, 0, 0, 0], [0, 2, 0, 3, 0, 1, 0, 0, 0], [0, 2, 0, 3, 0, 1, 0, 4, 0], [0, 2, 0, 3, 0, 1, 0, 4, 0], [0, 2, 0, 3, 0, 1, 0, 4, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 5, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0], [0, 0, 0, 5, 0, 5, 0, 5, 0], [0, 0, 0, 5, 0, 5, 0, 5, 0], [0, 5, 0, 5, 0, 5, 0, 5, 0], [0, 5, 0, 5, 0, 5, 0, 5, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 2, 0, 0, 0, 1, 0], [0, 0, 0, 2, 0, 3, 0, 1, 0], [0, 0, 0, 2, 0, 3, 0, 1, 0], [0, 4, 0, 2, 0, 3, 0, 1, 0], [0, 4, 0, 2, 0, 3, 0, 1, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 5, 0], [0, 5, 0, 0, 0, 5, 0, 5, 0], [0, 5, 0, 5, 0, 5, 0, 5, 0], [0, 5, 0, 5, 0, 5, 0, 5, 0], [0, 5, 0, 5, 0, 5, 0, 5, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 2, 0, 0, 0], [0, 1, 0, 0, 0, 2, 0, 0, 0], [0, 1, 0, 0, 0, 2, 0, 3, 0], [0, 1, 0, 0, 0, 2, 0, 3, 0], [0, 1, 0, 4, 0, 2, 0, 3, 0], [0, 1, 0, 4, 0, 2, 0, 3, 0], [0, 1, 0, 4, 0, 2, 0, 3, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef paint_grey_point(input_grid: np.ndarray, col: int, color: int) -> np.ndarray:\n    \"\"\"\n    Paints all grey points in the specified column of the input grid to the specified color.\n\n    Args:\n    - input_grid: A numpy array representing the input grid.\n    - col: An integer representing the index of the column to be painted.\n    - color: An integer representing the color to which the grey points in the specified column should be painted.\n\n    Returns:\n    - A numpy array representing the updated input grid with the grey points in the specified column painted to the specified color.\n    \"\"\"\n    input_grid[input_grid[:, col] == grey, col] = color\n    return input_grid\n\ndef sort_grey_num(grey_num: List[int]) -> List[int]:\n    return np.argsort(grey_num)[::-1]\n\ndef count_grey_per_column(input_grid: np.ndarray) -> List[int]:\n    return np.count_nonzero(input_grid == grey, axis=0)\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    grey_num = count_grey_per_column(input_grid)\n    sorted_list = sort_grey_num(grey_num)\n    color_list = [blue, red, green, yellow]\n    for i in range(4):\n        output = paint_grey_point(input_grid, sorted_list[i], color_list[i])\n    return output"},
{"name": "c0f76784.json", "data": {"train": [{"input": [[0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5], [0, 0, 5, 5, 5, 0, 0, 5, 0, 0, 0, 5], [0, 0, 5, 0, 5, 0, 0, 5, 0, 0, 0, 5], [0, 0, 5, 5, 5, 0, 0, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 5, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 5, 8, 8, 8, 5], [0, 0, 5, 5, 5, 0, 0, 5, 8, 8, 8, 5], [0, 0, 5, 6, 5, 0, 0, 5, 8, 8, 8, 5], [0, 0, 5, 5, 5, 0, 0, 5, 5, 5, 5, 5], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 5, 7, 7, 5, 0, 0], [0, 0, 0, 0, 0, 0, 5, 7, 7, 5, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 0], [0, 5, 5, 5, 0, 0, 5, 0, 0, 0, 5, 0], [0, 5, 0, 5, 0, 0, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 7, 7, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 7, 7, 5, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 5, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 5, 8, 8, 8, 5, 0], [0, 0, 0, 0, 0, 0, 5, 8, 8, 8, 5, 0], [0, 5, 5, 5, 0, 0, 5, 8, 8, 8, 5, 0], [0, 5, 6, 5, 0, 0, 5, 5, 5, 5, 5, 0], [0, 5, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 5, 8, 8, 8, 5, 0, 0, 0, 0, 0, 0], [0, 5, 8, 8, 8, 5, 0, 0, 0, 0, 0, 0], [0, 5, 8, 8, 8, 5, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]}], "test": [{"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0], [0, 5, 0, 0, 0, 5, 0, 0, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 0, 0, 5, 0, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0]], "output": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 5, 5, 5, 5, 5, 0, 0, 0, 0, 0, 0], [0, 5, 8, 8, 8, 5, 0, 0, 0, 0, 0, 0], [0, 5, 8, 8, 8, 5, 0, 0, 0, 0, 0, 0], [0, 5, 8, 8, 8, 5, 0, 0, 5, 5, 5, 0], [0, 5, 5, 5, 5, 5, 0, 0, 5, 6, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 5, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 7, 7, 5, 0, 0, 0, 0], [0, 0, 0, 0, 5, 5, 5, 5, 0, 0, 0, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef color_subgrid(input_grid: np.ndarray, x: int, y: int, length: int, color: int) -> np.ndarray:\n    \"\"\"\n    Given the input grid, the upper left corner (x, y) and the length of the sub-grid, color the sub-grid with the given color.\n    \"\"\"\n    for i in range(x, x + length - 1):\n        for j in range(y, y + length - 1):\n            input_grid[i][j] = color\n    return input_grid\n\ndef color_by_length(length: int) -> int:\n    \"\"\"\n    Given the length of the sub-grid, return the corresponding color.\n    \"\"\"\n    if length == 2:\n        return pink\n    elif length == 3:\n        return orange\n    elif length == 4:\n        return teal\n    else:\n        return maroon\n\ndef color_gray_pixels(input_grid: np.ndarray, target_list: List[Tuple[int, int, int]]) -> np.ndarray:\n    \"\"\"\n    Traverse the target_list, for each item (x, y, length), take (x+1, y+1) in the inputgrid as the upper left corner, \n    and color the sub-grid whose shape is (length-1, length-1): if length If the length is 2, the sub-grid will be painted in pink; \n    if the length is 3, the sub-grid will be painted in orange; if the length is 4, the sub-grid will be painted in teal.\n    \"\"\"\n    for target in target_list:\n        x, y, length = target\n        color = color_by_length(length)\n        input_grid = color_subgrid(input_grid, x + 1, y + 1, length, color)\n    return input_grid\n\ndef find_gray_pixels(input_grid: np.ndarray) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Iterate over all pixels in the input grid, if a pixel (x, y) is gray, and the pixels below and to the right of it are also gray. \n    Then traverse all the pixels in the same line, if there is a gray pixel (bx,by) and the pixel on the right side of the pixel is black, \n    record cnt=by-y. If cnt is not None, add (x, y, cnt) to the answer list.\n    \"\"\"\n    gray_pixels = []\n    n = input_grid.shape[0]\n    for i in range(n - 1):\n        for j in range(n - 1):\n            if input_grid[i][j] == grey and input_grid[i + 1][j] == grey and (input_grid[i][j + 1] == grey):\n                cnt = None\n                for k in range(j + 1, n):\n                    if input_grid[i][k] == black:\n                        break\n                    if input_grid[i][k] == grey:\n                        if input_grid[i + 1][k] == grey:\n                            cnt = k - j\n                            break\n                if cnt is not None:\n                    gray_pixels.append((i, j, cnt))\n    return gray_pixels\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    In the input, you should see a n*n grid with multiple color pixels.\n    \"\"\"\n    target_list = find_gray_pixels(input_grid)\n    ans_grid = color_gray_pixels(input_grid, target_list)\n    return ans_grid"},
{"name": "1f85a75f.json", "data": {"train": [{"input": [[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 5, 1, 0, 0, 0, 5, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 5, 0, 1, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 1, 0, 1, 5, 1, 0, 5, 0, 0, 0, 0, 0, 1, 0, 0], [5, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [5, 0, 5, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 3, 3, 3, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 3, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 3, 3, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0], [0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 5, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 5], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0, 5, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[3, 3, 0], [3, 3, 3], [3, 0, 3], [3, 3, 3], [0, 3, 3]]}, {"input": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [2, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "output": [[0, 4, 0], [4, 4, 4], [0, 4, 4]]}], "test": [{"input": [[0, 0, 1, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 1, 3, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 0, 8, 0, 0, 1, 0, 0, 0, 8, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 8], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 1, 8, 0, 8, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8], [0, 8, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 8, 0, 3], [0, 0, 0, 1, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 8, 0, 3, 0, 0, 0, 8, 0, 0, 3, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 8, 0, 0, 3, 0, 0, 0, 0, 8, 3, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 3, 0, 0, 2, 2, 2, 0, 8, 3, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 8, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 8, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 3, 0, 1, 0, 0, 3, 0, 0, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 0, 8, 0, 8, 0, 0, 1, 1, 1, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 8, 0, 0, 0, 1, 0, 0, 8, 0, 3, 0, 3, 0, 0], [0, 0, 1, 0, 0, 3, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 8, 0, 3, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 8, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3]], "output": [[0, 2, 2, 2], [2, 2, 0, 2], [2, 2, 0, 2], [0, 2, 2, 2]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef find_block(input_grid: np.ndarray, positions: List[Tuple[int, int]]) -> np.ndarray:\n    min_pos = np.min(positions, axis=0)\n    max_pos = np.max(positions, axis=0)\n    block = input_grid[min_pos[0]:max_pos[0] + 1, min_pos[1]:max_pos[1] + 1]\n    return block\n\ndef collect_positions(input_grid: np.ndarray, element: int) -> List[Tuple[int, int]]:\n    positions = []\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i][j] == element:\n                positions.append((i, j))\n    return positions\n\ndef find_min_element(input_grid: np.ndarray) -> int:\n    \"\"\"\n    This function finds the element with the minimum amount in the input grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    The element with the minimum amount in the input grid.\n    \"\"\"\n    unique_elements, counts = np.unique(input_grid, return_counts=True)\n    min_element = unique_elements[np.argmin(counts)]\n    return min_element\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    element = find_min_element(input_grid)\n    positions = collect_positions(input_grid, element)\n    block = find_block(input_grid, positions)\n    return block"},
{"name": "77fdfe62.json", "data": {"train": [{"input": [[2, 1, 0, 0, 0, 0, 1, 3], [1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 8, 0, 0, 1, 0], [0, 1, 8, 8, 0, 8, 1, 0], [0, 1, 0, 0, 8, 0, 1, 0], [0, 1, 8, 0, 8, 8, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1], [4, 1, 0, 0, 0, 0, 1, 6]], "output": [[0, 2, 0, 0], [2, 2, 0, 3], [0, 0, 6, 0], [4, 0, 6, 6]]}, {"input": [[9, 1, 0, 0, 1, 4], [1, 1, 1, 1, 1, 1], [0, 1, 8, 8, 1, 0], [0, 1, 8, 0, 1, 0], [1, 1, 1, 1, 1, 1], [2, 1, 0, 0, 1, 3]], "output": [[9, 4], [2, 0]]}, {"input": [[6, 1, 0, 0, 0, 0, 1, 2], [1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 8, 0, 8, 1, 0], [0, 1, 8, 8, 8, 0, 1, 0], [0, 1, 8, 0, 8, 8, 1, 0], [0, 1, 8, 8, 8, 0, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1], [7, 1, 0, 0, 0, 0, 1, 4]], "output": [[0, 6, 0, 2], [6, 6, 2, 0], [7, 0, 4, 4], [7, 7, 4, 0]]}], "test": [{"input": [[3, 1, 0, 0, 0, 0, 0, 0, 1, 4], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 8, 8, 0, 0, 0, 1, 0], [0, 1, 8, 8, 8, 0, 8, 0, 1, 0], [0, 1, 0, 0, 8, 0, 8, 0, 1, 0], [0, 1, 0, 8, 0, 8, 8, 0, 1, 0], [0, 1, 8, 8, 0, 8, 0, 8, 1, 0], [0, 1, 0, 8, 0, 0, 8, 0, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [7, 1, 0, 0, 0, 0, 0, 0, 1, 5]], "output": [[0, 3, 3, 0, 0, 0], [3, 3, 3, 0, 4, 0], [0, 0, 3, 0, 4, 0], [0, 7, 0, 5, 5, 0], [7, 7, 0, 5, 0, 5], [0, 7, 0, 0, 5, 0]]}]}, "code": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef turn_lower_right_quarter(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Turns non-black pixels in lower right quarter of output_grid into the color of the lower right pixel of input grid.\n\n    Args:\n    output_grid: A numpy array representing the output grid.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    lower_right_color = input_grid[-1, -1]\n    rows, cols = output_grid.shape\n    for i in range(rows // 2, rows):\n        for j in range(cols // 2, cols):\n            if output_grid[i, j] != black:\n                output_grid[i, j] = lower_right_color\n    return output_grid\n\ndef turn_lower_left_quarter(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Turns non-black pixels in lower left quarter of output_grid into the color of the lower left pixel of input grid.\n\n    Args:\n    output_grid: A numpy array representing the output grid.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    lower_left_color = input_grid[-1, 0]\n    rows, cols = output_grid.shape\n    for i in range(rows // 2, rows):\n        for j in range(cols // 2):\n            if output_grid[i, j] != black:\n                output_grid[i, j] = lower_left_color\n    return output_grid\n\ndef turn_upper_right_quarter(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Turns non-black pixels in upper right quarter of output_grid into the color of the upper right pixel of input grid.\n\n    Args:\n    output_grid: A numpy array representing the output grid.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    upper_right_color = input_grid[0, -1]\n    rows, cols = output_grid.shape\n    for i in range(rows // 2):\n        for j in range(cols // 2, cols):\n            if output_grid[i, j] != black:\n                output_grid[i, j] = upper_right_color\n    return output_grid\n\ndef turn_upper_left_quarter(output_grid: np.ndarray, input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Turns non-black pixels in upper left quarter of output_grid into the color of the upper left pixel of input grid.\n\n    Args:\n    output_grid: A numpy array representing the output grid.\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the updated output grid.\n    \"\"\"\n    upper_left_color = input_grid[0, 0]\n    rows, cols = output_grid.shape\n    for i in range(rows // 2):\n        for j in range(cols // 2):\n            if output_grid[i, j] != black:\n                output_grid[i, j] = upper_left_color\n    return output_grid\n\ndef divide_input(input_grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Divides the input grid by all blue rows and pixels, and returns the center grid.\n\n    Args:\n    input_grid: A numpy array representing the input grid.\n\n    Returns:\n    A numpy array representing the center grid.\n    \"\"\"\n    blue_rows = np.where(np.all(input_grid == blue, axis=1))[0]\n    blue_cols = np.where(np.all(input_grid == blue, axis=0))[0]\n    center_grid = input_grid[blue_rows[0] + 1:blue_rows[-1], blue_cols[0] + 1:blue_cols[-1]]\n    return center_grid\n\ndef transform_grid(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = divide_input(input_grid)\n    output_grid = turn_upper_left_quarter(output_grid, input_grid)\n    output_grid = turn_upper_right_quarter(output_grid, input_grid)\n    output_grid = turn_lower_left_quarter(output_grid, input_grid)\n    output_grid = turn_lower_right_quarter(output_grid, input_grid)\n    return output_grid"}
]