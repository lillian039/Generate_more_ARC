{"id": 226, "train_io": {"inputs": [[[0, 0, 0, 0], [0, 3, 3, 0], [0, 0, 0, 0], [3, 0, 0, 3], [0, 0, 0, 1], [1, 0, 1, 1], [1, 1, 1, 1], [0, 1, 0, 1]], [[3, 3, 3, 3], [0, 3, 3, 0], [0, 0, 3, 3], [3, 0, 0, 0], [0, 0, 0, 1], [0, 0, 0, 1], [0, 1, 0, 0], [1, 0, 0, 1]], [[0, 3, 3, 0], [0, 3, 0, 3], [0, 0, 3, 0], [3, 3, 3, 3], [1, 1, 1, 1], [1, 1, 0, 0], [1, 1, 0, 0], [0, 1, 1, 0]], [[3, 3, 3, 3], [3, 0, 0, 0], [3, 0, 3, 3], [3, 3, 0, 3], [1, 1, 1, 0], [0, 1, 1, 1], [1, 0, 1, 1], [0, 1, 1, 1]]], "outputs": [[[2, 2, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 2, 0]], [[0, 0, 0, 0], [2, 0, 0, 0], [2, 0, 0, 0], [0, 2, 2, 0]], [[0, 0, 0, 0], [0, 0, 2, 0], [0, 0, 0, 2], [0, 0, 0, 0]], [[0, 0, 0, 0], [0, 0, 0, 0], [0, 2, 0, 0], [0, 0, 0, 0]]]}, "test_io": {"inputs": [[[0, 3, 0, 3], [3, 3, 3, 0], [0, 0, 0, 3], [3, 3, 3, 0], [0, 0, 1, 1], [0, 0, 1, 1], [0, 1, 0, 0], [1, 1, 0, 0]]], "outputs": [[[2, 0, 0, 0], [0, 0, 0, 0], [2, 0, 2, 0], [0, 0, 0, 2]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    top_grid = input_grid[:4, :]\n    bottom_grid = input_grid[4:, :]\n    black_pixels_top = \"find the black pixels index of the grid\"(top_grid)\n    black_pixels_bottom = \"find the black pixels index of the grid\"(bottom_grid)\n    output_grid = np.zeros([4, 4])\n    intersection = \"find the intersection pixels\"(black_pixels_top, black_pixels_bottom)\n    \"fill the output_grid's intersection with red\"(output_grid, intersection)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef fill_intersection_with_red(output_grid: np.ndarray, intersection: List[Tuple[int, int]]) -> None:\n    for pixel in intersection:\n        output_grid[pixel[0]][pixel[1]] = red\n\ndef find_intersection(black_pixels_top: List[Tuple[int, int]], black_pixels_bottom: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    intersection = []\n    for pixel_top in black_pixels_top:\n        if pixel_top in black_pixels_bottom:\n            intersection.append(pixel_top)\n    return intersection\n\ndef find_black_pixels(grid: np.ndarray) -> List[Tuple[int, int]]:\n    black_pixels = []\n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if grid[i][j] == black:\n                black_pixels.append((i, j))\n    return black_pixels\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    top_grid = input_grid[:4, :]\n    bottom_grid = input_grid[4:, :]\n    black_pixels_top = find_black_pixels(top_grid)\n    black_pixels_bottom = find_black_pixels(bottom_grid)\n    output_grid = np.zeros([4, 4])\n    intersection = find_intersection(black_pixels_top, black_pixels_bottom)\n    fill_intersection_with_red(output_grid, intersection)\n    return output_grid", "name": "94f9d214.json", "description": {"object": "In the input, you should see...is a 4x8 grid. The top 4x4 is a pattern of green pixels. The bottom is a 4x4 is a pattern of blue pixels.", "size": "The output grid size...is a 4x4 grid.", "description": "To make the output, you have to...overlay the top 4x4 grid of green pixels over the bottom 4x4 grid of blue pixels or vice versa.After you complete the overlay whichever pixels are still black will be changed to red in the output. All the other pixels which are green, blue, or both will be changed to black", "confidence": 8}}