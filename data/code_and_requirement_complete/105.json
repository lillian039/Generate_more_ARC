{"id": 105, "train_io": {"inputs": [[[8, 6], [6, 8]], [[7, 7, 8], [7, 7, 8], [8, 8, 8]], [[6, 9, 9], [6, 4, 4], [6, 4, 4]]], "outputs": [[[8, 6, 6, 8], [6, 8, 8, 6], [6, 8, 8, 6], [8, 6, 6, 8]], [[7, 7, 8, 8, 7, 7], [7, 7, 8, 8, 7, 7], [8, 8, 8, 8, 8, 8], [8, 8, 8, 8, 8, 8], [7, 7, 8, 8, 7, 7], [7, 7, 8, 8, 7, 7]], [[6, 9, 9, 6, 6, 6], [6, 4, 4, 4, 4, 9], [6, 4, 4, 4, 4, 9], [9, 4, 4, 4, 4, 6], [9, 4, 4, 4, 4, 6], [6, 6, 6, 9, 9, 6]]]}, "test_io": {"inputs": [[[1, 4, 1], [4, 9, 4], [9, 1, 9]]], "outputs": [[[1, 4, 1, 9, 4, 1], [4, 9, 4, 1, 9, 4], [9, 1, 9, 9, 4, 1], [1, 4, 9, 9, 1, 9], [4, 9, 1, 4, 9, 4], [1, 4, 9, 1, 4, 1]]]}, "solved": true, "generalizable": true, "anpl": "def main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = \"return the empty grid which is the double size of input_grid\"(input_grid)\n    output_grid = \"put the input_grid at the top-left of output_grid\"(input_grid, output_grid)\n    input_grid = \"rotate the input_grid 90 degrees clockwise\"(input_grid)\n    output_grid = \"put the input_grid at the top-right of output_grid\"(input_grid, output_grid)\n    input_grid = \"rotate the input_grid 90 degrees clockwise\"(input_grid)\n    output_grid = \"put the input_grid at the bottom-right of output_grid\"(input_grid, output_grid)\n    input_grid = \"rotate the input_grid 90 degrees clockwise\"(input_grid)\n    output_grid = \"put the input_grid at the bottom-left of output_grid\"(input_grid, output_grid)\n    return output_grid", "python": "import numpy as np\nfrom typing import *\nblack, blue, red, green, yellow, grey, pink, orange, teal, maroon = range(10)\n\ndef put_input_grid_at_bottom_left(input_grid: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    output_grid[-input_grid.shape[0]:, :input_grid.shape[1]] = input_grid\n    return output_grid\n\ndef put_input_grid_at_bottom_right(input_grid: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    output_grid[-input_grid.shape[0]:, -input_grid.shape[1]:] = input_grid\n    return output_grid\n\ndef put_input_grid_at_top_right(input_grid: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    output_grid[:input_grid.shape[0], -input_grid.shape[1]:] = input_grid\n    return output_grid\n\ndef rotate_90_degrees_clockwise(input_grid: np.ndarray) -> np.ndarray:\n    return np.rot90(input_grid, k=-1)\n\ndef put_input_grid_at_top_left(input_grid: np.ndarray, output_grid: np.ndarray) -> np.ndarray:\n    output_grid[:input_grid.shape[0], :input_grid.shape[1]] = input_grid\n    return output_grid\n\ndef get_empty_grid(input_grid: np.ndarray) -> np.ndarray:\n    return np.zeros((input_grid.shape[0] * 2, input_grid.shape[1] * 2))\n\ndef main(input_grid: np.ndarray) -> np.ndarray:\n    output_grid = get_empty_grid(input_grid)\n    output_grid = put_input_grid_at_top_left(input_grid, output_grid)\n    input_grid = rotate_90_degrees_clockwise(input_grid)\n    output_grid = put_input_grid_at_top_right(input_grid, output_grid)\n    input_grid = rotate_90_degrees_clockwise(input_grid)\n    output_grid = put_input_grid_at_bottom_right(input_grid, output_grid)\n    input_grid = rotate_90_degrees_clockwise(input_grid)\n    output_grid = put_input_grid_at_bottom_left(input_grid, output_grid)\n    return output_grid", "name": "46442a0e.json", "description": {"object": "In the input, you should see... A grid with colored pixels.", "size": "The output grid size...  Is twice as large as the input, so a 2x2 becomes 4x4 and a 3x3 becomes 6x6 and so on.", "description": "To make the output, you have to...  Create a grid twice the size of the input.  Divide the output grid into 4 quadrants.  Replicate the input grid pixels in the upper right quad.  In the upper left quad, place the input grid that's been rotated clockwise 90 degrees.  In the lower right quad, place the input grid colored pixels that has been rotated 180 degrees.  In the lower left quad place a copy of the input grid that's been rotated 90 degrees COUNTER-CLOCKWISE.  Done.", "confidence": 9}}